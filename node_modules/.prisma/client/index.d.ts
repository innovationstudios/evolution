
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Instance
 * 
 */
export type Instance = $Result.DefaultSelection<Prisma.$InstancePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageUpdate
 * 
 */
export type MessageUpdate = $Result.DefaultSelection<Prisma.$MessageUpdatePayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model Chatwoot
 * 
 */
export type Chatwoot = $Result.DefaultSelection<Prisma.$ChatwootPayload>
/**
 * Model Label
 * 
 */
export type Label = $Result.DefaultSelection<Prisma.$LabelPayload>
/**
 * Model Proxy
 * 
 */
export type Proxy = $Result.DefaultSelection<Prisma.$ProxyPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model Rabbitmq
 * 
 */
export type Rabbitmq = $Result.DefaultSelection<Prisma.$RabbitmqPayload>
/**
 * Model Sqs
 * 
 */
export type Sqs = $Result.DefaultSelection<Prisma.$SqsPayload>
/**
 * Model Websocket
 * 
 */
export type Websocket = $Result.DefaultSelection<Prisma.$WebsocketPayload>
/**
 * Model Pusher
 * 
 */
export type Pusher = $Result.DefaultSelection<Prisma.$PusherPayload>
/**
 * Model Typebot
 * 
 */
export type Typebot = $Result.DefaultSelection<Prisma.$TypebotPayload>
/**
 * Model TypebotSetting
 * 
 */
export type TypebotSetting = $Result.DefaultSelection<Prisma.$TypebotSettingPayload>
/**
 * Model IntegrationSession
 * 
 */
export type IntegrationSession = $Result.DefaultSelection<Prisma.$IntegrationSessionPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model OpenaiCreds
 * 
 */
export type OpenaiCreds = $Result.DefaultSelection<Prisma.$OpenaiCredsPayload>
/**
 * Model OpenaiBot
 * 
 */
export type OpenaiBot = $Result.DefaultSelection<Prisma.$OpenaiBotPayload>
/**
 * Model OpenaiSetting
 * 
 */
export type OpenaiSetting = $Result.DefaultSelection<Prisma.$OpenaiSettingPayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model Dify
 * 
 */
export type Dify = $Result.DefaultSelection<Prisma.$DifyPayload>
/**
 * Model DifySetting
 * 
 */
export type DifySetting = $Result.DefaultSelection<Prisma.$DifySettingPayload>
/**
 * Model EvolutionBot
 * 
 */
export type EvolutionBot = $Result.DefaultSelection<Prisma.$EvolutionBotPayload>
/**
 * Model EvolutionBotSetting
 * 
 */
export type EvolutionBotSetting = $Result.DefaultSelection<Prisma.$EvolutionBotSettingPayload>
/**
 * Model Flowise
 * 
 */
export type Flowise = $Result.DefaultSelection<Prisma.$FlowisePayload>
/**
 * Model FlowiseSetting
 * 
 */
export type FlowiseSetting = $Result.DefaultSelection<Prisma.$FlowiseSettingPayload>
/**
 * Model IsOnWhatsapp
 * 
 */
export type IsOnWhatsapp = $Result.DefaultSelection<Prisma.$IsOnWhatsappPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InstanceConnectionStatus: {
  open: 'open',
  close: 'close',
  connecting: 'connecting'
};

export type InstanceConnectionStatus = (typeof InstanceConnectionStatus)[keyof typeof InstanceConnectionStatus]


export const DeviceMessage: {
  ios: 'ios',
  android: 'android',
  web: 'web',
  unknown: 'unknown',
  desktop: 'desktop'
};

export type DeviceMessage = (typeof DeviceMessage)[keyof typeof DeviceMessage]


export const SessionStatus: {
  opened: 'opened',
  closed: 'closed',
  paused: 'paused'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const TriggerType: {
  all: 'all',
  keyword: 'keyword',
  none: 'none',
  advanced: 'advanced'
};

export type TriggerType = (typeof TriggerType)[keyof typeof TriggerType]


export const TriggerOperator: {
  contains: 'contains',
  equals: 'equals',
  startsWith: 'startsWith',
  endsWith: 'endsWith',
  regex: 'regex'
};

export type TriggerOperator = (typeof TriggerOperator)[keyof typeof TriggerOperator]


export const OpenaiBotType: {
  assistant: 'assistant',
  chatCompletion: 'chatCompletion'
};

export type OpenaiBotType = (typeof OpenaiBotType)[keyof typeof OpenaiBotType]


export const DifyBotType: {
  chatBot: 'chatBot',
  textGenerator: 'textGenerator',
  agent: 'agent',
  workflow: 'workflow'
};

export type DifyBotType = (typeof DifyBotType)[keyof typeof DifyBotType]

}

export type InstanceConnectionStatus = $Enums.InstanceConnectionStatus

export const InstanceConnectionStatus: typeof $Enums.InstanceConnectionStatus

export type DeviceMessage = $Enums.DeviceMessage

export const DeviceMessage: typeof $Enums.DeviceMessage

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type TriggerType = $Enums.TriggerType

export const TriggerType: typeof $Enums.TriggerType

export type TriggerOperator = $Enums.TriggerOperator

export const TriggerOperator: typeof $Enums.TriggerOperator

export type OpenaiBotType = $Enums.OpenaiBotType

export const OpenaiBotType: typeof $Enums.OpenaiBotType

export type DifyBotType = $Enums.DifyBotType

export const DifyBotType: typeof $Enums.DifyBotType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Instances
 * const instances = await prisma.instance.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Instances
   * const instances = await prisma.instance.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.instance`: Exposes CRUD operations for the **Instance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instances
    * const instances = await prisma.instance.findMany()
    * ```
    */
  get instance(): Prisma.InstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageUpdate`: Exposes CRUD operations for the **MessageUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageUpdates
    * const messageUpdates = await prisma.messageUpdate.findMany()
    * ```
    */
  get messageUpdate(): Prisma.MessageUpdateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatwoot`: Exposes CRUD operations for the **Chatwoot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatwoots
    * const chatwoots = await prisma.chatwoot.findMany()
    * ```
    */
  get chatwoot(): Prisma.ChatwootDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.label`: Exposes CRUD operations for the **Label** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labels
    * const labels = await prisma.label.findMany()
    * ```
    */
  get label(): Prisma.LabelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxy`: Exposes CRUD operations for the **Proxy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proxies
    * const proxies = await prisma.proxy.findMany()
    * ```
    */
  get proxy(): Prisma.ProxyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rabbitmq`: Exposes CRUD operations for the **Rabbitmq** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rabbitmqs
    * const rabbitmqs = await prisma.rabbitmq.findMany()
    * ```
    */
  get rabbitmq(): Prisma.RabbitmqDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sqs`: Exposes CRUD operations for the **Sqs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sqs
    * const sqs = await prisma.sqs.findMany()
    * ```
    */
  get sqs(): Prisma.SqsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.websocket`: Exposes CRUD operations for the **Websocket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Websockets
    * const websockets = await prisma.websocket.findMany()
    * ```
    */
  get websocket(): Prisma.WebsocketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pusher`: Exposes CRUD operations for the **Pusher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pushers
    * const pushers = await prisma.pusher.findMany()
    * ```
    */
  get pusher(): Prisma.PusherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.typebot`: Exposes CRUD operations for the **Typebot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Typebots
    * const typebots = await prisma.typebot.findMany()
    * ```
    */
  get typebot(): Prisma.TypebotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.typebotSetting`: Exposes CRUD operations for the **TypebotSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypebotSettings
    * const typebotSettings = await prisma.typebotSetting.findMany()
    * ```
    */
  get typebotSetting(): Prisma.TypebotSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integrationSession`: Exposes CRUD operations for the **IntegrationSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntegrationSessions
    * const integrationSessions = await prisma.integrationSession.findMany()
    * ```
    */
  get integrationSession(): Prisma.IntegrationSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.openaiCreds`: Exposes CRUD operations for the **OpenaiCreds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenaiCreds
    * const openaiCreds = await prisma.openaiCreds.findMany()
    * ```
    */
  get openaiCreds(): Prisma.OpenaiCredsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.openaiBot`: Exposes CRUD operations for the **OpenaiBot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenaiBots
    * const openaiBots = await prisma.openaiBot.findMany()
    * ```
    */
  get openaiBot(): Prisma.OpenaiBotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.openaiSetting`: Exposes CRUD operations for the **OpenaiSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpenaiSettings
    * const openaiSettings = await prisma.openaiSetting.findMany()
    * ```
    */
  get openaiSetting(): Prisma.OpenaiSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dify`: Exposes CRUD operations for the **Dify** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Difies
    * const difies = await prisma.dify.findMany()
    * ```
    */
  get dify(): Prisma.DifyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.difySetting`: Exposes CRUD operations for the **DifySetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DifySettings
    * const difySettings = await prisma.difySetting.findMany()
    * ```
    */
  get difySetting(): Prisma.DifySettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evolutionBot`: Exposes CRUD operations for the **EvolutionBot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvolutionBots
    * const evolutionBots = await prisma.evolutionBot.findMany()
    * ```
    */
  get evolutionBot(): Prisma.EvolutionBotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evolutionBotSetting`: Exposes CRUD operations for the **EvolutionBotSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvolutionBotSettings
    * const evolutionBotSettings = await prisma.evolutionBotSetting.findMany()
    * ```
    */
  get evolutionBotSetting(): Prisma.EvolutionBotSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowise`: Exposes CRUD operations for the **Flowise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flowises
    * const flowises = await prisma.flowise.findMany()
    * ```
    */
  get flowise(): Prisma.FlowiseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flowiseSetting`: Exposes CRUD operations for the **FlowiseSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlowiseSettings
    * const flowiseSettings = await prisma.flowiseSetting.findMany()
    * ```
    */
  get flowiseSetting(): Prisma.FlowiseSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.isOnWhatsapp`: Exposes CRUD operations for the **IsOnWhatsapp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IsOnWhatsapps
    * const isOnWhatsapps = await prisma.isOnWhatsapp.findMany()
    * ```
    */
  get isOnWhatsapp(): Prisma.IsOnWhatsappDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.0
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Instance: 'Instance',
    Session: 'Session',
    Chat: 'Chat',
    Contact: 'Contact',
    Message: 'Message',
    MessageUpdate: 'MessageUpdate',
    Webhook: 'Webhook',
    Chatwoot: 'Chatwoot',
    Label: 'Label',
    Proxy: 'Proxy',
    Setting: 'Setting',
    Rabbitmq: 'Rabbitmq',
    Sqs: 'Sqs',
    Websocket: 'Websocket',
    Pusher: 'Pusher',
    Typebot: 'Typebot',
    TypebotSetting: 'TypebotSetting',
    IntegrationSession: 'IntegrationSession',
    Media: 'Media',
    OpenaiCreds: 'OpenaiCreds',
    OpenaiBot: 'OpenaiBot',
    OpenaiSetting: 'OpenaiSetting',
    Template: 'Template',
    Dify: 'Dify',
    DifySetting: 'DifySetting',
    EvolutionBot: 'EvolutionBot',
    EvolutionBotSetting: 'EvolutionBotSetting',
    Flowise: 'Flowise',
    FlowiseSetting: 'FlowiseSetting',
    IsOnWhatsapp: 'IsOnWhatsapp'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "instance" | "session" | "chat" | "contact" | "message" | "messageUpdate" | "webhook" | "chatwoot" | "label" | "proxy" | "setting" | "rabbitmq" | "sqs" | "websocket" | "pusher" | "typebot" | "typebotSetting" | "integrationSession" | "media" | "openaiCreds" | "openaiBot" | "openaiSetting" | "template" | "dify" | "difySetting" | "evolutionBot" | "evolutionBotSetting" | "flowise" | "flowiseSetting" | "isOnWhatsapp"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Instance: {
        payload: Prisma.$InstancePayload<ExtArgs>
        fields: Prisma.InstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findFirst: {
            args: Prisma.InstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          findMany: {
            args: Prisma.InstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>[]
          }
          create: {
            args: Prisma.InstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          createMany: {
            args: Prisma.InstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          update: {
            args: Prisma.InstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          deleteMany: {
            args: Prisma.InstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstancePayload>
          }
          aggregate: {
            args: Prisma.InstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstance>
          }
          groupBy: {
            args: Prisma.InstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstanceCountArgs<ExtArgs>
            result: $Utils.Optional<InstanceCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageUpdate: {
        payload: Prisma.$MessageUpdatePayload<ExtArgs>
        fields: Prisma.MessageUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUpdatePayload>
          }
          findFirst: {
            args: Prisma.MessageUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUpdatePayload>
          }
          findMany: {
            args: Prisma.MessageUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUpdatePayload>[]
          }
          create: {
            args: Prisma.MessageUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUpdatePayload>
          }
          createMany: {
            args: Prisma.MessageUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUpdatePayload>
          }
          update: {
            args: Prisma.MessageUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUpdatePayload>
          }
          deleteMany: {
            args: Prisma.MessageUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageUpdatePayload>
          }
          aggregate: {
            args: Prisma.MessageUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageUpdate>
          }
          groupBy: {
            args: Prisma.MessageUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<MessageUpdateCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      Chatwoot: {
        payload: Prisma.$ChatwootPayload<ExtArgs>
        fields: Prisma.ChatwootFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatwootFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatwootPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatwootFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatwootPayload>
          }
          findFirst: {
            args: Prisma.ChatwootFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatwootPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatwootFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatwootPayload>
          }
          findMany: {
            args: Prisma.ChatwootFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatwootPayload>[]
          }
          create: {
            args: Prisma.ChatwootCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatwootPayload>
          }
          createMany: {
            args: Prisma.ChatwootCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChatwootDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatwootPayload>
          }
          update: {
            args: Prisma.ChatwootUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatwootPayload>
          }
          deleteMany: {
            args: Prisma.ChatwootDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatwootUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatwootUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatwootPayload>
          }
          aggregate: {
            args: Prisma.ChatwootAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatwoot>
          }
          groupBy: {
            args: Prisma.ChatwootGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatwootGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatwootCountArgs<ExtArgs>
            result: $Utils.Optional<ChatwootCountAggregateOutputType> | number
          }
        }
      }
      Label: {
        payload: Prisma.$LabelPayload<ExtArgs>
        fields: Prisma.LabelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findFirst: {
            args: Prisma.LabelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          findMany: {
            args: Prisma.LabelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>[]
          }
          create: {
            args: Prisma.LabelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          createMany: {
            args: Prisma.LabelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LabelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          update: {
            args: Prisma.LabelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          deleteMany: {
            args: Prisma.LabelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabelPayload>
          }
          aggregate: {
            args: Prisma.LabelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabel>
          }
          groupBy: {
            args: Prisma.LabelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabelCountArgs<ExtArgs>
            result: $Utils.Optional<LabelCountAggregateOutputType> | number
          }
        }
      }
      Proxy: {
        payload: Prisma.$ProxyPayload<ExtArgs>
        fields: Prisma.ProxyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          findFirst: {
            args: Prisma.ProxyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          findMany: {
            args: Prisma.ProxyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>[]
          }
          create: {
            args: Prisma.ProxyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          createMany: {
            args: Prisma.ProxyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProxyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          update: {
            args: Prisma.ProxyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          deleteMany: {
            args: Prisma.ProxyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProxyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          aggregate: {
            args: Prisma.ProxyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxy>
          }
          groupBy: {
            args: Prisma.ProxyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxyCountArgs<ExtArgs>
            result: $Utils.Optional<ProxyCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      Rabbitmq: {
        payload: Prisma.$RabbitmqPayload<ExtArgs>
        fields: Prisma.RabbitmqFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RabbitmqFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RabbitmqPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RabbitmqFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RabbitmqPayload>
          }
          findFirst: {
            args: Prisma.RabbitmqFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RabbitmqPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RabbitmqFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RabbitmqPayload>
          }
          findMany: {
            args: Prisma.RabbitmqFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RabbitmqPayload>[]
          }
          create: {
            args: Prisma.RabbitmqCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RabbitmqPayload>
          }
          createMany: {
            args: Prisma.RabbitmqCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RabbitmqDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RabbitmqPayload>
          }
          update: {
            args: Prisma.RabbitmqUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RabbitmqPayload>
          }
          deleteMany: {
            args: Prisma.RabbitmqDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RabbitmqUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RabbitmqUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RabbitmqPayload>
          }
          aggregate: {
            args: Prisma.RabbitmqAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRabbitmq>
          }
          groupBy: {
            args: Prisma.RabbitmqGroupByArgs<ExtArgs>
            result: $Utils.Optional<RabbitmqGroupByOutputType>[]
          }
          count: {
            args: Prisma.RabbitmqCountArgs<ExtArgs>
            result: $Utils.Optional<RabbitmqCountAggregateOutputType> | number
          }
        }
      }
      Sqs: {
        payload: Prisma.$SqsPayload<ExtArgs>
        fields: Prisma.SqsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SqsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SqsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SqsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SqsPayload>
          }
          findFirst: {
            args: Prisma.SqsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SqsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SqsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SqsPayload>
          }
          findMany: {
            args: Prisma.SqsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SqsPayload>[]
          }
          create: {
            args: Prisma.SqsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SqsPayload>
          }
          createMany: {
            args: Prisma.SqsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SqsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SqsPayload>
          }
          update: {
            args: Prisma.SqsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SqsPayload>
          }
          deleteMany: {
            args: Prisma.SqsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SqsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SqsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SqsPayload>
          }
          aggregate: {
            args: Prisma.SqsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSqs>
          }
          groupBy: {
            args: Prisma.SqsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SqsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SqsCountArgs<ExtArgs>
            result: $Utils.Optional<SqsCountAggregateOutputType> | number
          }
        }
      }
      Websocket: {
        payload: Prisma.$WebsocketPayload<ExtArgs>
        fields: Prisma.WebsocketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebsocketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsocketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebsocketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsocketPayload>
          }
          findFirst: {
            args: Prisma.WebsocketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsocketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebsocketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsocketPayload>
          }
          findMany: {
            args: Prisma.WebsocketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsocketPayload>[]
          }
          create: {
            args: Prisma.WebsocketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsocketPayload>
          }
          createMany: {
            args: Prisma.WebsocketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WebsocketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsocketPayload>
          }
          update: {
            args: Prisma.WebsocketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsocketPayload>
          }
          deleteMany: {
            args: Prisma.WebsocketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebsocketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebsocketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebsocketPayload>
          }
          aggregate: {
            args: Prisma.WebsocketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebsocket>
          }
          groupBy: {
            args: Prisma.WebsocketGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebsocketGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebsocketCountArgs<ExtArgs>
            result: $Utils.Optional<WebsocketCountAggregateOutputType> | number
          }
        }
      }
      Pusher: {
        payload: Prisma.$PusherPayload<ExtArgs>
        fields: Prisma.PusherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PusherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PusherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PusherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PusherPayload>
          }
          findFirst: {
            args: Prisma.PusherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PusherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PusherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PusherPayload>
          }
          findMany: {
            args: Prisma.PusherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PusherPayload>[]
          }
          create: {
            args: Prisma.PusherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PusherPayload>
          }
          createMany: {
            args: Prisma.PusherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PusherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PusherPayload>
          }
          update: {
            args: Prisma.PusherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PusherPayload>
          }
          deleteMany: {
            args: Prisma.PusherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PusherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PusherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PusherPayload>
          }
          aggregate: {
            args: Prisma.PusherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePusher>
          }
          groupBy: {
            args: Prisma.PusherGroupByArgs<ExtArgs>
            result: $Utils.Optional<PusherGroupByOutputType>[]
          }
          count: {
            args: Prisma.PusherCountArgs<ExtArgs>
            result: $Utils.Optional<PusherCountAggregateOutputType> | number
          }
        }
      }
      Typebot: {
        payload: Prisma.$TypebotPayload<ExtArgs>
        fields: Prisma.TypebotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypebotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypebotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotPayload>
          }
          findFirst: {
            args: Prisma.TypebotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypebotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotPayload>
          }
          findMany: {
            args: Prisma.TypebotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotPayload>[]
          }
          create: {
            args: Prisma.TypebotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotPayload>
          }
          createMany: {
            args: Prisma.TypebotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TypebotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotPayload>
          }
          update: {
            args: Prisma.TypebotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotPayload>
          }
          deleteMany: {
            args: Prisma.TypebotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypebotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TypebotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotPayload>
          }
          aggregate: {
            args: Prisma.TypebotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTypebot>
          }
          groupBy: {
            args: Prisma.TypebotGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypebotGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypebotCountArgs<ExtArgs>
            result: $Utils.Optional<TypebotCountAggregateOutputType> | number
          }
        }
      }
      TypebotSetting: {
        payload: Prisma.$TypebotSettingPayload<ExtArgs>
        fields: Prisma.TypebotSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypebotSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypebotSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotSettingPayload>
          }
          findFirst: {
            args: Prisma.TypebotSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypebotSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotSettingPayload>
          }
          findMany: {
            args: Prisma.TypebotSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotSettingPayload>[]
          }
          create: {
            args: Prisma.TypebotSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotSettingPayload>
          }
          createMany: {
            args: Prisma.TypebotSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TypebotSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotSettingPayload>
          }
          update: {
            args: Prisma.TypebotSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotSettingPayload>
          }
          deleteMany: {
            args: Prisma.TypebotSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypebotSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TypebotSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypebotSettingPayload>
          }
          aggregate: {
            args: Prisma.TypebotSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTypebotSetting>
          }
          groupBy: {
            args: Prisma.TypebotSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypebotSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypebotSettingCountArgs<ExtArgs>
            result: $Utils.Optional<TypebotSettingCountAggregateOutputType> | number
          }
        }
      }
      IntegrationSession: {
        payload: Prisma.$IntegrationSessionPayload<ExtArgs>
        fields: Prisma.IntegrationSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSessionPayload>
          }
          findFirst: {
            args: Prisma.IntegrationSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSessionPayload>
          }
          findMany: {
            args: Prisma.IntegrationSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSessionPayload>[]
          }
          create: {
            args: Prisma.IntegrationSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSessionPayload>
          }
          createMany: {
            args: Prisma.IntegrationSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IntegrationSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSessionPayload>
          }
          update: {
            args: Prisma.IntegrationSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSessionPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationSessionPayload>
          }
          aggregate: {
            args: Prisma.IntegrationSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegrationSession>
          }
          groupBy: {
            args: Prisma.IntegrationSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationSessionCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationSessionCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      OpenaiCreds: {
        payload: Prisma.$OpenaiCredsPayload<ExtArgs>
        fields: Prisma.OpenaiCredsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenaiCredsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiCredsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenaiCredsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiCredsPayload>
          }
          findFirst: {
            args: Prisma.OpenaiCredsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiCredsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenaiCredsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiCredsPayload>
          }
          findMany: {
            args: Prisma.OpenaiCredsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiCredsPayload>[]
          }
          create: {
            args: Prisma.OpenaiCredsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiCredsPayload>
          }
          createMany: {
            args: Prisma.OpenaiCredsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OpenaiCredsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiCredsPayload>
          }
          update: {
            args: Prisma.OpenaiCredsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiCredsPayload>
          }
          deleteMany: {
            args: Prisma.OpenaiCredsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenaiCredsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpenaiCredsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiCredsPayload>
          }
          aggregate: {
            args: Prisma.OpenaiCredsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenaiCreds>
          }
          groupBy: {
            args: Prisma.OpenaiCredsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenaiCredsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenaiCredsCountArgs<ExtArgs>
            result: $Utils.Optional<OpenaiCredsCountAggregateOutputType> | number
          }
        }
      }
      OpenaiBot: {
        payload: Prisma.$OpenaiBotPayload<ExtArgs>
        fields: Prisma.OpenaiBotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenaiBotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiBotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenaiBotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiBotPayload>
          }
          findFirst: {
            args: Prisma.OpenaiBotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiBotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenaiBotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiBotPayload>
          }
          findMany: {
            args: Prisma.OpenaiBotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiBotPayload>[]
          }
          create: {
            args: Prisma.OpenaiBotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiBotPayload>
          }
          createMany: {
            args: Prisma.OpenaiBotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OpenaiBotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiBotPayload>
          }
          update: {
            args: Prisma.OpenaiBotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiBotPayload>
          }
          deleteMany: {
            args: Prisma.OpenaiBotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenaiBotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpenaiBotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiBotPayload>
          }
          aggregate: {
            args: Prisma.OpenaiBotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenaiBot>
          }
          groupBy: {
            args: Prisma.OpenaiBotGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenaiBotGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenaiBotCountArgs<ExtArgs>
            result: $Utils.Optional<OpenaiBotCountAggregateOutputType> | number
          }
        }
      }
      OpenaiSetting: {
        payload: Prisma.$OpenaiSettingPayload<ExtArgs>
        fields: Prisma.OpenaiSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpenaiSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpenaiSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiSettingPayload>
          }
          findFirst: {
            args: Prisma.OpenaiSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpenaiSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiSettingPayload>
          }
          findMany: {
            args: Prisma.OpenaiSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiSettingPayload>[]
          }
          create: {
            args: Prisma.OpenaiSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiSettingPayload>
          }
          createMany: {
            args: Prisma.OpenaiSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OpenaiSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiSettingPayload>
          }
          update: {
            args: Prisma.OpenaiSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiSettingPayload>
          }
          deleteMany: {
            args: Prisma.OpenaiSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpenaiSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpenaiSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpenaiSettingPayload>
          }
          aggregate: {
            args: Prisma.OpenaiSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpenaiSetting>
          }
          groupBy: {
            args: Prisma.OpenaiSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpenaiSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpenaiSettingCountArgs<ExtArgs>
            result: $Utils.Optional<OpenaiSettingCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      Dify: {
        payload: Prisma.$DifyPayload<ExtArgs>
        fields: Prisma.DifyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DifyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DifyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifyPayload>
          }
          findFirst: {
            args: Prisma.DifyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DifyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifyPayload>
          }
          findMany: {
            args: Prisma.DifyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifyPayload>[]
          }
          create: {
            args: Prisma.DifyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifyPayload>
          }
          createMany: {
            args: Prisma.DifyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DifyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifyPayload>
          }
          update: {
            args: Prisma.DifyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifyPayload>
          }
          deleteMany: {
            args: Prisma.DifyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DifyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DifyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifyPayload>
          }
          aggregate: {
            args: Prisma.DifyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDify>
          }
          groupBy: {
            args: Prisma.DifyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DifyGroupByOutputType>[]
          }
          count: {
            args: Prisma.DifyCountArgs<ExtArgs>
            result: $Utils.Optional<DifyCountAggregateOutputType> | number
          }
        }
      }
      DifySetting: {
        payload: Prisma.$DifySettingPayload<ExtArgs>
        fields: Prisma.DifySettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DifySettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifySettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DifySettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifySettingPayload>
          }
          findFirst: {
            args: Prisma.DifySettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifySettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DifySettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifySettingPayload>
          }
          findMany: {
            args: Prisma.DifySettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifySettingPayload>[]
          }
          create: {
            args: Prisma.DifySettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifySettingPayload>
          }
          createMany: {
            args: Prisma.DifySettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DifySettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifySettingPayload>
          }
          update: {
            args: Prisma.DifySettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifySettingPayload>
          }
          deleteMany: {
            args: Prisma.DifySettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DifySettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DifySettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DifySettingPayload>
          }
          aggregate: {
            args: Prisma.DifySettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDifySetting>
          }
          groupBy: {
            args: Prisma.DifySettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DifySettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DifySettingCountArgs<ExtArgs>
            result: $Utils.Optional<DifySettingCountAggregateOutputType> | number
          }
        }
      }
      EvolutionBot: {
        payload: Prisma.$EvolutionBotPayload<ExtArgs>
        fields: Prisma.EvolutionBotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvolutionBotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvolutionBotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotPayload>
          }
          findFirst: {
            args: Prisma.EvolutionBotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvolutionBotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotPayload>
          }
          findMany: {
            args: Prisma.EvolutionBotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotPayload>[]
          }
          create: {
            args: Prisma.EvolutionBotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotPayload>
          }
          createMany: {
            args: Prisma.EvolutionBotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EvolutionBotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotPayload>
          }
          update: {
            args: Prisma.EvolutionBotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotPayload>
          }
          deleteMany: {
            args: Prisma.EvolutionBotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvolutionBotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvolutionBotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotPayload>
          }
          aggregate: {
            args: Prisma.EvolutionBotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvolutionBot>
          }
          groupBy: {
            args: Prisma.EvolutionBotGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvolutionBotGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvolutionBotCountArgs<ExtArgs>
            result: $Utils.Optional<EvolutionBotCountAggregateOutputType> | number
          }
        }
      }
      EvolutionBotSetting: {
        payload: Prisma.$EvolutionBotSettingPayload<ExtArgs>
        fields: Prisma.EvolutionBotSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvolutionBotSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvolutionBotSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotSettingPayload>
          }
          findFirst: {
            args: Prisma.EvolutionBotSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvolutionBotSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotSettingPayload>
          }
          findMany: {
            args: Prisma.EvolutionBotSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotSettingPayload>[]
          }
          create: {
            args: Prisma.EvolutionBotSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotSettingPayload>
          }
          createMany: {
            args: Prisma.EvolutionBotSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EvolutionBotSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotSettingPayload>
          }
          update: {
            args: Prisma.EvolutionBotSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotSettingPayload>
          }
          deleteMany: {
            args: Prisma.EvolutionBotSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvolutionBotSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvolutionBotSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvolutionBotSettingPayload>
          }
          aggregate: {
            args: Prisma.EvolutionBotSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvolutionBotSetting>
          }
          groupBy: {
            args: Prisma.EvolutionBotSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvolutionBotSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvolutionBotSettingCountArgs<ExtArgs>
            result: $Utils.Optional<EvolutionBotSettingCountAggregateOutputType> | number
          }
        }
      }
      Flowise: {
        payload: Prisma.$FlowisePayload<ExtArgs>
        fields: Prisma.FlowiseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowiseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowiseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowisePayload>
          }
          findFirst: {
            args: Prisma.FlowiseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowiseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowisePayload>
          }
          findMany: {
            args: Prisma.FlowiseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowisePayload>[]
          }
          create: {
            args: Prisma.FlowiseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowisePayload>
          }
          createMany: {
            args: Prisma.FlowiseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FlowiseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowisePayload>
          }
          update: {
            args: Prisma.FlowiseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowisePayload>
          }
          deleteMany: {
            args: Prisma.FlowiseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowiseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlowiseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowisePayload>
          }
          aggregate: {
            args: Prisma.FlowiseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowise>
          }
          groupBy: {
            args: Prisma.FlowiseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowiseGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowiseCountArgs<ExtArgs>
            result: $Utils.Optional<FlowiseCountAggregateOutputType> | number
          }
        }
      }
      FlowiseSetting: {
        payload: Prisma.$FlowiseSettingPayload<ExtArgs>
        fields: Prisma.FlowiseSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlowiseSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowiseSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlowiseSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowiseSettingPayload>
          }
          findFirst: {
            args: Prisma.FlowiseSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowiseSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlowiseSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowiseSettingPayload>
          }
          findMany: {
            args: Prisma.FlowiseSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowiseSettingPayload>[]
          }
          create: {
            args: Prisma.FlowiseSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowiseSettingPayload>
          }
          createMany: {
            args: Prisma.FlowiseSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FlowiseSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowiseSettingPayload>
          }
          update: {
            args: Prisma.FlowiseSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowiseSettingPayload>
          }
          deleteMany: {
            args: Prisma.FlowiseSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlowiseSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlowiseSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlowiseSettingPayload>
          }
          aggregate: {
            args: Prisma.FlowiseSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlowiseSetting>
          }
          groupBy: {
            args: Prisma.FlowiseSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlowiseSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlowiseSettingCountArgs<ExtArgs>
            result: $Utils.Optional<FlowiseSettingCountAggregateOutputType> | number
          }
        }
      }
      IsOnWhatsapp: {
        payload: Prisma.$IsOnWhatsappPayload<ExtArgs>
        fields: Prisma.IsOnWhatsappFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IsOnWhatsappFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IsOnWhatsappPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IsOnWhatsappFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IsOnWhatsappPayload>
          }
          findFirst: {
            args: Prisma.IsOnWhatsappFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IsOnWhatsappPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IsOnWhatsappFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IsOnWhatsappPayload>
          }
          findMany: {
            args: Prisma.IsOnWhatsappFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IsOnWhatsappPayload>[]
          }
          create: {
            args: Prisma.IsOnWhatsappCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IsOnWhatsappPayload>
          }
          createMany: {
            args: Prisma.IsOnWhatsappCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IsOnWhatsappDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IsOnWhatsappPayload>
          }
          update: {
            args: Prisma.IsOnWhatsappUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IsOnWhatsappPayload>
          }
          deleteMany: {
            args: Prisma.IsOnWhatsappDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IsOnWhatsappUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IsOnWhatsappUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IsOnWhatsappPayload>
          }
          aggregate: {
            args: Prisma.IsOnWhatsappAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIsOnWhatsapp>
          }
          groupBy: {
            args: Prisma.IsOnWhatsappGroupByArgs<ExtArgs>
            result: $Utils.Optional<IsOnWhatsappGroupByOutputType>[]
          }
          count: {
            args: Prisma.IsOnWhatsappCountArgs<ExtArgs>
            result: $Utils.Optional<IsOnWhatsappCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    instance?: InstanceOmit
    session?: SessionOmit
    chat?: ChatOmit
    contact?: ContactOmit
    message?: MessageOmit
    messageUpdate?: MessageUpdateOmit
    webhook?: WebhookOmit
    chatwoot?: ChatwootOmit
    label?: LabelOmit
    proxy?: ProxyOmit
    setting?: SettingOmit
    rabbitmq?: RabbitmqOmit
    sqs?: SqsOmit
    websocket?: WebsocketOmit
    pusher?: PusherOmit
    typebot?: TypebotOmit
    typebotSetting?: TypebotSettingOmit
    integrationSession?: IntegrationSessionOmit
    media?: MediaOmit
    openaiCreds?: OpenaiCredsOmit
    openaiBot?: OpenaiBotOmit
    openaiSetting?: OpenaiSettingOmit
    template?: TemplateOmit
    dify?: DifyOmit
    difySetting?: DifySettingOmit
    evolutionBot?: EvolutionBotOmit
    evolutionBotSetting?: EvolutionBotSettingOmit
    flowise?: FlowiseOmit
    flowiseSetting?: FlowiseSettingOmit
    isOnWhatsapp?: IsOnWhatsappOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type InstanceCountOutputType
   */

  export type InstanceCountOutputType = {
    Chat: number
    Contact: number
    Message: number
    Label: number
    Typebot: number
    MessageUpdate: number
    Media: number
    OpenaiCreds: number
    OpenaiBot: number
    Template: number
    Dify: number
    integrationSessions: number
    EvolutionBot: number
    Flowise: number
  }

  export type InstanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chat?: boolean | InstanceCountOutputTypeCountChatArgs
    Contact?: boolean | InstanceCountOutputTypeCountContactArgs
    Message?: boolean | InstanceCountOutputTypeCountMessageArgs
    Label?: boolean | InstanceCountOutputTypeCountLabelArgs
    Typebot?: boolean | InstanceCountOutputTypeCountTypebotArgs
    MessageUpdate?: boolean | InstanceCountOutputTypeCountMessageUpdateArgs
    Media?: boolean | InstanceCountOutputTypeCountMediaArgs
    OpenaiCreds?: boolean | InstanceCountOutputTypeCountOpenaiCredsArgs
    OpenaiBot?: boolean | InstanceCountOutputTypeCountOpenaiBotArgs
    Template?: boolean | InstanceCountOutputTypeCountTemplateArgs
    Dify?: boolean | InstanceCountOutputTypeCountDifyArgs
    integrationSessions?: boolean | InstanceCountOutputTypeCountIntegrationSessionsArgs
    EvolutionBot?: boolean | InstanceCountOutputTypeCountEvolutionBotArgs
    Flowise?: boolean | InstanceCountOutputTypeCountFlowiseArgs
  }

  // Custom InputTypes
  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstanceCountOutputType
     */
    select?: InstanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountLabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountTypebotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypebotWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageUpdateWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountOpenaiCredsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenaiCredsWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountOpenaiBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenaiBotWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountDifyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DifyWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountIntegrationSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationSessionWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountEvolutionBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolutionBotWhereInput
  }

  /**
   * InstanceCountOutputType without action
   */
  export type InstanceCountOutputTypeCountFlowiseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowiseWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    MessageUpdate: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MessageUpdate?: boolean | MessageCountOutputTypeCountMessageUpdateArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageUpdateWhereInput
  }


  /**
   * Count Type TypebotCountOutputType
   */

  export type TypebotCountOutputType = {
    TypebotSetting: number
  }

  export type TypebotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TypebotSetting?: boolean | TypebotCountOutputTypeCountTypebotSettingArgs
  }

  // Custom InputTypes
  /**
   * TypebotCountOutputType without action
   */
  export type TypebotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotCountOutputType
     */
    select?: TypebotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TypebotCountOutputType without action
   */
  export type TypebotCountOutputTypeCountTypebotSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypebotSettingWhereInput
  }


  /**
   * Count Type IntegrationSessionCountOutputType
   */

  export type IntegrationSessionCountOutputType = {
    Message: number
  }

  export type IntegrationSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Message?: boolean | IntegrationSessionCountOutputTypeCountMessageArgs
  }

  // Custom InputTypes
  /**
   * IntegrationSessionCountOutputType without action
   */
  export type IntegrationSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSessionCountOutputType
     */
    select?: IntegrationSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IntegrationSessionCountOutputType without action
   */
  export type IntegrationSessionCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type OpenaiCredsCountOutputType
   */

  export type OpenaiCredsCountOutputType = {
    OpenaiAssistant: number
  }

  export type OpenaiCredsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OpenaiAssistant?: boolean | OpenaiCredsCountOutputTypeCountOpenaiAssistantArgs
  }

  // Custom InputTypes
  /**
   * OpenaiCredsCountOutputType without action
   */
  export type OpenaiCredsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCredsCountOutputType
     */
    select?: OpenaiCredsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpenaiCredsCountOutputType without action
   */
  export type OpenaiCredsCountOutputTypeCountOpenaiAssistantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenaiBotWhereInput
  }


  /**
   * Count Type OpenaiBotCountOutputType
   */

  export type OpenaiBotCountOutputType = {
    OpenaiSetting: number
  }

  export type OpenaiBotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OpenaiSetting?: boolean | OpenaiBotCountOutputTypeCountOpenaiSettingArgs
  }

  // Custom InputTypes
  /**
   * OpenaiBotCountOutputType without action
   */
  export type OpenaiBotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBotCountOutputType
     */
    select?: OpenaiBotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpenaiBotCountOutputType without action
   */
  export type OpenaiBotCountOutputTypeCountOpenaiSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenaiSettingWhereInput
  }


  /**
   * Count Type DifyCountOutputType
   */

  export type DifyCountOutputType = {
    DifySetting: number
  }

  export type DifyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DifySetting?: boolean | DifyCountOutputTypeCountDifySettingArgs
  }

  // Custom InputTypes
  /**
   * DifyCountOutputType without action
   */
  export type DifyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifyCountOutputType
     */
    select?: DifyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DifyCountOutputType without action
   */
  export type DifyCountOutputTypeCountDifySettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DifySettingWhereInput
  }


  /**
   * Count Type EvolutionBotCountOutputType
   */

  export type EvolutionBotCountOutputType = {
    EvolutionBotSetting: number
  }

  export type EvolutionBotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EvolutionBotSetting?: boolean | EvolutionBotCountOutputTypeCountEvolutionBotSettingArgs
  }

  // Custom InputTypes
  /**
   * EvolutionBotCountOutputType without action
   */
  export type EvolutionBotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotCountOutputType
     */
    select?: EvolutionBotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvolutionBotCountOutputType without action
   */
  export type EvolutionBotCountOutputTypeCountEvolutionBotSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolutionBotSettingWhereInput
  }


  /**
   * Count Type FlowiseCountOutputType
   */

  export type FlowiseCountOutputType = {
    FlowiseSetting: number
  }

  export type FlowiseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FlowiseSetting?: boolean | FlowiseCountOutputTypeCountFlowiseSettingArgs
  }

  // Custom InputTypes
  /**
   * FlowiseCountOutputType without action
   */
  export type FlowiseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseCountOutputType
     */
    select?: FlowiseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlowiseCountOutputType without action
   */
  export type FlowiseCountOutputTypeCountFlowiseSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowiseSettingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Instance
   */

  export type AggregateInstance = {
    _count: InstanceCountAggregateOutputType | null
    _avg: InstanceAvgAggregateOutputType | null
    _sum: InstanceSumAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  export type InstanceAvgAggregateOutputType = {
    disconnectionReasonCode: number | null
  }

  export type InstanceSumAggregateOutputType = {
    disconnectionReasonCode: number | null
  }

  export type InstanceMinAggregateOutputType = {
    id: string | null
    name: string | null
    connectionStatus: $Enums.InstanceConnectionStatus | null
    ownerJid: string | null
    profileName: string | null
    profilePicUrl: string | null
    integration: string | null
    number: string | null
    businessId: string | null
    token: string | null
    clientName: string | null
    disconnectionReasonCode: number | null
    disconnectionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstanceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    connectionStatus: $Enums.InstanceConnectionStatus | null
    ownerJid: string | null
    profileName: string | null
    profilePicUrl: string | null
    integration: string | null
    number: string | null
    businessId: string | null
    token: string | null
    clientName: string | null
    disconnectionReasonCode: number | null
    disconnectionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstanceCountAggregateOutputType = {
    id: number
    name: number
    connectionStatus: number
    ownerJid: number
    profileName: number
    profilePicUrl: number
    integration: number
    number: number
    businessId: number
    token: number
    clientName: number
    disconnectionReasonCode: number
    disconnectionObject: number
    disconnectionAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstanceAvgAggregateInputType = {
    disconnectionReasonCode?: true
  }

  export type InstanceSumAggregateInputType = {
    disconnectionReasonCode?: true
  }

  export type InstanceMinAggregateInputType = {
    id?: true
    name?: true
    connectionStatus?: true
    ownerJid?: true
    profileName?: true
    profilePicUrl?: true
    integration?: true
    number?: true
    businessId?: true
    token?: true
    clientName?: true
    disconnectionReasonCode?: true
    disconnectionAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstanceMaxAggregateInputType = {
    id?: true
    name?: true
    connectionStatus?: true
    ownerJid?: true
    profileName?: true
    profilePicUrl?: true
    integration?: true
    number?: true
    businessId?: true
    token?: true
    clientName?: true
    disconnectionReasonCode?: true
    disconnectionAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstanceCountAggregateInputType = {
    id?: true
    name?: true
    connectionStatus?: true
    ownerJid?: true
    profileName?: true
    profilePicUrl?: true
    integration?: true
    number?: true
    businessId?: true
    token?: true
    clientName?: true
    disconnectionReasonCode?: true
    disconnectionObject?: true
    disconnectionAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instance to aggregate.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instances
    **/
    _count?: true | InstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstanceMaxAggregateInputType
  }

  export type GetInstanceAggregateType<T extends InstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstance[P]>
      : GetScalarType<T[P], AggregateInstance[P]>
  }




  export type InstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstanceWhereInput
    orderBy?: InstanceOrderByWithAggregationInput | InstanceOrderByWithAggregationInput[]
    by: InstanceScalarFieldEnum[] | InstanceScalarFieldEnum
    having?: InstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstanceCountAggregateInputType | true
    _avg?: InstanceAvgAggregateInputType
    _sum?: InstanceSumAggregateInputType
    _min?: InstanceMinAggregateInputType
    _max?: InstanceMaxAggregateInputType
  }

  export type InstanceGroupByOutputType = {
    id: string
    name: string
    connectionStatus: $Enums.InstanceConnectionStatus
    ownerJid: string | null
    profileName: string | null
    profilePicUrl: string | null
    integration: string | null
    number: string | null
    businessId: string | null
    token: string | null
    clientName: string | null
    disconnectionReasonCode: number | null
    disconnectionObject: JsonValue | null
    disconnectionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: InstanceCountAggregateOutputType | null
    _avg: InstanceAvgAggregateOutputType | null
    _sum: InstanceSumAggregateOutputType | null
    _min: InstanceMinAggregateOutputType | null
    _max: InstanceMaxAggregateOutputType | null
  }

  type GetInstanceGroupByPayload<T extends InstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstanceGroupByOutputType[P]>
            : GetScalarType<T[P], InstanceGroupByOutputType[P]>
        }
      >
    >


  export type InstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    connectionStatus?: boolean
    ownerJid?: boolean
    profileName?: boolean
    profilePicUrl?: boolean
    integration?: boolean
    number?: boolean
    businessId?: boolean
    token?: boolean
    clientName?: boolean
    disconnectionReasonCode?: boolean
    disconnectionObject?: boolean
    disconnectionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Chat?: boolean | Instance$ChatArgs<ExtArgs>
    Contact?: boolean | Instance$ContactArgs<ExtArgs>
    Message?: boolean | Instance$MessageArgs<ExtArgs>
    Webhook?: boolean | Instance$WebhookArgs<ExtArgs>
    Chatwoot?: boolean | Instance$ChatwootArgs<ExtArgs>
    Label?: boolean | Instance$LabelArgs<ExtArgs>
    Proxy?: boolean | Instance$ProxyArgs<ExtArgs>
    Setting?: boolean | Instance$SettingArgs<ExtArgs>
    Rabbitmq?: boolean | Instance$RabbitmqArgs<ExtArgs>
    Sqs?: boolean | Instance$SqsArgs<ExtArgs>
    Websocket?: boolean | Instance$WebsocketArgs<ExtArgs>
    Typebot?: boolean | Instance$TypebotArgs<ExtArgs>
    Session?: boolean | Instance$SessionArgs<ExtArgs>
    MessageUpdate?: boolean | Instance$MessageUpdateArgs<ExtArgs>
    TypebotSetting?: boolean | Instance$TypebotSettingArgs<ExtArgs>
    Media?: boolean | Instance$MediaArgs<ExtArgs>
    OpenaiCreds?: boolean | Instance$OpenaiCredsArgs<ExtArgs>
    OpenaiBot?: boolean | Instance$OpenaiBotArgs<ExtArgs>
    OpenaiSetting?: boolean | Instance$OpenaiSettingArgs<ExtArgs>
    Template?: boolean | Instance$TemplateArgs<ExtArgs>
    Dify?: boolean | Instance$DifyArgs<ExtArgs>
    DifySetting?: boolean | Instance$DifySettingArgs<ExtArgs>
    integrationSessions?: boolean | Instance$integrationSessionsArgs<ExtArgs>
    EvolutionBot?: boolean | Instance$EvolutionBotArgs<ExtArgs>
    EvolutionBotSetting?: boolean | Instance$EvolutionBotSettingArgs<ExtArgs>
    Flowise?: boolean | Instance$FlowiseArgs<ExtArgs>
    FlowiseSetting?: boolean | Instance$FlowiseSettingArgs<ExtArgs>
    Pusher?: boolean | Instance$PusherArgs<ExtArgs>
    _count?: boolean | InstanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instance"]>



  export type InstanceSelectScalar = {
    id?: boolean
    name?: boolean
    connectionStatus?: boolean
    ownerJid?: boolean
    profileName?: boolean
    profilePicUrl?: boolean
    integration?: boolean
    number?: boolean
    businessId?: boolean
    token?: boolean
    clientName?: boolean
    disconnectionReasonCode?: boolean
    disconnectionObject?: boolean
    disconnectionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "connectionStatus" | "ownerJid" | "profileName" | "profilePicUrl" | "integration" | "number" | "businessId" | "token" | "clientName" | "disconnectionReasonCode" | "disconnectionObject" | "disconnectionAt" | "createdAt" | "updatedAt", ExtArgs["result"]["instance"]>
  export type InstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Chat?: boolean | Instance$ChatArgs<ExtArgs>
    Contact?: boolean | Instance$ContactArgs<ExtArgs>
    Message?: boolean | Instance$MessageArgs<ExtArgs>
    Webhook?: boolean | Instance$WebhookArgs<ExtArgs>
    Chatwoot?: boolean | Instance$ChatwootArgs<ExtArgs>
    Label?: boolean | Instance$LabelArgs<ExtArgs>
    Proxy?: boolean | Instance$ProxyArgs<ExtArgs>
    Setting?: boolean | Instance$SettingArgs<ExtArgs>
    Rabbitmq?: boolean | Instance$RabbitmqArgs<ExtArgs>
    Sqs?: boolean | Instance$SqsArgs<ExtArgs>
    Websocket?: boolean | Instance$WebsocketArgs<ExtArgs>
    Typebot?: boolean | Instance$TypebotArgs<ExtArgs>
    Session?: boolean | Instance$SessionArgs<ExtArgs>
    MessageUpdate?: boolean | Instance$MessageUpdateArgs<ExtArgs>
    TypebotSetting?: boolean | Instance$TypebotSettingArgs<ExtArgs>
    Media?: boolean | Instance$MediaArgs<ExtArgs>
    OpenaiCreds?: boolean | Instance$OpenaiCredsArgs<ExtArgs>
    OpenaiBot?: boolean | Instance$OpenaiBotArgs<ExtArgs>
    OpenaiSetting?: boolean | Instance$OpenaiSettingArgs<ExtArgs>
    Template?: boolean | Instance$TemplateArgs<ExtArgs>
    Dify?: boolean | Instance$DifyArgs<ExtArgs>
    DifySetting?: boolean | Instance$DifySettingArgs<ExtArgs>
    integrationSessions?: boolean | Instance$integrationSessionsArgs<ExtArgs>
    EvolutionBot?: boolean | Instance$EvolutionBotArgs<ExtArgs>
    EvolutionBotSetting?: boolean | Instance$EvolutionBotSettingArgs<ExtArgs>
    Flowise?: boolean | Instance$FlowiseArgs<ExtArgs>
    FlowiseSetting?: boolean | Instance$FlowiseSettingArgs<ExtArgs>
    Pusher?: boolean | Instance$PusherArgs<ExtArgs>
    _count?: boolean | InstanceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instance"
    objects: {
      Chat: Prisma.$ChatPayload<ExtArgs>[]
      Contact: Prisma.$ContactPayload<ExtArgs>[]
      Message: Prisma.$MessagePayload<ExtArgs>[]
      Webhook: Prisma.$WebhookPayload<ExtArgs> | null
      Chatwoot: Prisma.$ChatwootPayload<ExtArgs> | null
      Label: Prisma.$LabelPayload<ExtArgs>[]
      Proxy: Prisma.$ProxyPayload<ExtArgs> | null
      Setting: Prisma.$SettingPayload<ExtArgs> | null
      Rabbitmq: Prisma.$RabbitmqPayload<ExtArgs> | null
      Sqs: Prisma.$SqsPayload<ExtArgs> | null
      Websocket: Prisma.$WebsocketPayload<ExtArgs> | null
      Typebot: Prisma.$TypebotPayload<ExtArgs>[]
      Session: Prisma.$SessionPayload<ExtArgs> | null
      MessageUpdate: Prisma.$MessageUpdatePayload<ExtArgs>[]
      TypebotSetting: Prisma.$TypebotSettingPayload<ExtArgs> | null
      Media: Prisma.$MediaPayload<ExtArgs>[]
      OpenaiCreds: Prisma.$OpenaiCredsPayload<ExtArgs>[]
      OpenaiBot: Prisma.$OpenaiBotPayload<ExtArgs>[]
      OpenaiSetting: Prisma.$OpenaiSettingPayload<ExtArgs> | null
      Template: Prisma.$TemplatePayload<ExtArgs>[]
      Dify: Prisma.$DifyPayload<ExtArgs>[]
      DifySetting: Prisma.$DifySettingPayload<ExtArgs> | null
      integrationSessions: Prisma.$IntegrationSessionPayload<ExtArgs>[]
      EvolutionBot: Prisma.$EvolutionBotPayload<ExtArgs>[]
      EvolutionBotSetting: Prisma.$EvolutionBotSettingPayload<ExtArgs> | null
      Flowise: Prisma.$FlowisePayload<ExtArgs>[]
      FlowiseSetting: Prisma.$FlowiseSettingPayload<ExtArgs> | null
      Pusher: Prisma.$PusherPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      connectionStatus: $Enums.InstanceConnectionStatus
      ownerJid: string | null
      profileName: string | null
      profilePicUrl: string | null
      integration: string | null
      number: string | null
      businessId: string | null
      token: string | null
      clientName: string | null
      disconnectionReasonCode: number | null
      disconnectionObject: Prisma.JsonValue | null
      disconnectionAt: Date | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["instance"]>
    composites: {}
  }

  type InstanceGetPayload<S extends boolean | null | undefined | InstanceDefaultArgs> = $Result.GetResult<Prisma.$InstancePayload, S>

  type InstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstanceCountAggregateInputType | true
    }

  export interface InstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instance'], meta: { name: 'Instance' } }
    /**
     * Find zero or one Instance that matches the filter.
     * @param {InstanceFindUniqueArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstanceFindUniqueArgs>(args: SelectSubset<T, InstanceFindUniqueArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Instance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstanceFindUniqueOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, InstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Instance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstanceFindFirstArgs>(args?: SelectSubset<T, InstanceFindFirstArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Instance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindFirstOrThrowArgs} args - Arguments to find a Instance
     * @example
     * // Get one Instance
     * const instance = await prisma.instance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, InstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Instances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instances
     * const instances = await prisma.instance.findMany()
     * 
     * // Get first 10 Instances
     * const instances = await prisma.instance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instanceWithIdOnly = await prisma.instance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstanceFindManyArgs>(args?: SelectSubset<T, InstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Instance.
     * @param {InstanceCreateArgs} args - Arguments to create a Instance.
     * @example
     * // Create one Instance
     * const Instance = await prisma.instance.create({
     *   data: {
     *     // ... data to create a Instance
     *   }
     * })
     * 
     */
    create<T extends InstanceCreateArgs>(args: SelectSubset<T, InstanceCreateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Instances.
     * @param {InstanceCreateManyArgs} args - Arguments to create many Instances.
     * @example
     * // Create many Instances
     * const instance = await prisma.instance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstanceCreateManyArgs>(args?: SelectSubset<T, InstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Instance.
     * @param {InstanceDeleteArgs} args - Arguments to delete one Instance.
     * @example
     * // Delete one Instance
     * const Instance = await prisma.instance.delete({
     *   where: {
     *     // ... filter to delete one Instance
     *   }
     * })
     * 
     */
    delete<T extends InstanceDeleteArgs>(args: SelectSubset<T, InstanceDeleteArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Instance.
     * @param {InstanceUpdateArgs} args - Arguments to update one Instance.
     * @example
     * // Update one Instance
     * const instance = await prisma.instance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstanceUpdateArgs>(args: SelectSubset<T, InstanceUpdateArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Instances.
     * @param {InstanceDeleteManyArgs} args - Arguments to filter Instances to delete.
     * @example
     * // Delete a few Instances
     * const { count } = await prisma.instance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstanceDeleteManyArgs>(args?: SelectSubset<T, InstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instances
     * const instance = await prisma.instance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstanceUpdateManyArgs>(args: SelectSubset<T, InstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instance.
     * @param {InstanceUpsertArgs} args - Arguments to update or create a Instance.
     * @example
     * // Update or create a Instance
     * const instance = await prisma.instance.upsert({
     *   create: {
     *     // ... data to create a Instance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instance we want to update
     *   }
     * })
     */
    upsert<T extends InstanceUpsertArgs>(args: SelectSubset<T, InstanceUpsertArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Instances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceCountArgs} args - Arguments to filter Instances to count.
     * @example
     * // Count the number of Instances
     * const count = await prisma.instance.count({
     *   where: {
     *     // ... the filter for the Instances we want to count
     *   }
     * })
    **/
    count<T extends InstanceCountArgs>(
      args?: Subset<T, InstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstanceAggregateArgs>(args: Subset<T, InstanceAggregateArgs>): Prisma.PrismaPromise<GetInstanceAggregateType<T>>

    /**
     * Group by Instance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstanceGroupByArgs['orderBy'] }
        : { orderBy?: InstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instance model
   */
  readonly fields: InstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Chat<T extends Instance$ChatArgs<ExtArgs> = {}>(args?: Subset<T, Instance$ChatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Contact<T extends Instance$ContactArgs<ExtArgs> = {}>(args?: Subset<T, Instance$ContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Message<T extends Instance$MessageArgs<ExtArgs> = {}>(args?: Subset<T, Instance$MessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Webhook<T extends Instance$WebhookArgs<ExtArgs> = {}>(args?: Subset<T, Instance$WebhookArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Chatwoot<T extends Instance$ChatwootArgs<ExtArgs> = {}>(args?: Subset<T, Instance$ChatwootArgs<ExtArgs>>): Prisma__ChatwootClient<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Label<T extends Instance$LabelArgs<ExtArgs> = {}>(args?: Subset<T, Instance$LabelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Proxy<T extends Instance$ProxyArgs<ExtArgs> = {}>(args?: Subset<T, Instance$ProxyArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Setting<T extends Instance$SettingArgs<ExtArgs> = {}>(args?: Subset<T, Instance$SettingArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Rabbitmq<T extends Instance$RabbitmqArgs<ExtArgs> = {}>(args?: Subset<T, Instance$RabbitmqArgs<ExtArgs>>): Prisma__RabbitmqClient<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Sqs<T extends Instance$SqsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$SqsArgs<ExtArgs>>): Prisma__SqsClient<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Websocket<T extends Instance$WebsocketArgs<ExtArgs> = {}>(args?: Subset<T, Instance$WebsocketArgs<ExtArgs>>): Prisma__WebsocketClient<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Typebot<T extends Instance$TypebotArgs<ExtArgs> = {}>(args?: Subset<T, Instance$TypebotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Session<T extends Instance$SessionArgs<ExtArgs> = {}>(args?: Subset<T, Instance$SessionArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    MessageUpdate<T extends Instance$MessageUpdateArgs<ExtArgs> = {}>(args?: Subset<T, Instance$MessageUpdateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TypebotSetting<T extends Instance$TypebotSettingArgs<ExtArgs> = {}>(args?: Subset<T, Instance$TypebotSettingArgs<ExtArgs>>): Prisma__TypebotSettingClient<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Media<T extends Instance$MediaArgs<ExtArgs> = {}>(args?: Subset<T, Instance$MediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    OpenaiCreds<T extends Instance$OpenaiCredsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$OpenaiCredsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    OpenaiBot<T extends Instance$OpenaiBotArgs<ExtArgs> = {}>(args?: Subset<T, Instance$OpenaiBotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    OpenaiSetting<T extends Instance$OpenaiSettingArgs<ExtArgs> = {}>(args?: Subset<T, Instance$OpenaiSettingArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Template<T extends Instance$TemplateArgs<ExtArgs> = {}>(args?: Subset<T, Instance$TemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Dify<T extends Instance$DifyArgs<ExtArgs> = {}>(args?: Subset<T, Instance$DifyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DifySetting<T extends Instance$DifySettingArgs<ExtArgs> = {}>(args?: Subset<T, Instance$DifySettingArgs<ExtArgs>>): Prisma__DifySettingClient<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    integrationSessions<T extends Instance$integrationSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Instance$integrationSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    EvolutionBot<T extends Instance$EvolutionBotArgs<ExtArgs> = {}>(args?: Subset<T, Instance$EvolutionBotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    EvolutionBotSetting<T extends Instance$EvolutionBotSettingArgs<ExtArgs> = {}>(args?: Subset<T, Instance$EvolutionBotSettingArgs<ExtArgs>>): Prisma__EvolutionBotSettingClient<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Flowise<T extends Instance$FlowiseArgs<ExtArgs> = {}>(args?: Subset<T, Instance$FlowiseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    FlowiseSetting<T extends Instance$FlowiseSettingArgs<ExtArgs> = {}>(args?: Subset<T, Instance$FlowiseSettingArgs<ExtArgs>>): Prisma__FlowiseSettingClient<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Pusher<T extends Instance$PusherArgs<ExtArgs> = {}>(args?: Subset<T, Instance$PusherArgs<ExtArgs>>): Prisma__PusherClient<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instance model
   */ 
  interface InstanceFieldRefs {
    readonly id: FieldRef<"Instance", 'String'>
    readonly name: FieldRef<"Instance", 'String'>
    readonly connectionStatus: FieldRef<"Instance", 'InstanceConnectionStatus'>
    readonly ownerJid: FieldRef<"Instance", 'String'>
    readonly profileName: FieldRef<"Instance", 'String'>
    readonly profilePicUrl: FieldRef<"Instance", 'String'>
    readonly integration: FieldRef<"Instance", 'String'>
    readonly number: FieldRef<"Instance", 'String'>
    readonly businessId: FieldRef<"Instance", 'String'>
    readonly token: FieldRef<"Instance", 'String'>
    readonly clientName: FieldRef<"Instance", 'String'>
    readonly disconnectionReasonCode: FieldRef<"Instance", 'Int'>
    readonly disconnectionObject: FieldRef<"Instance", 'Json'>
    readonly disconnectionAt: FieldRef<"Instance", 'DateTime'>
    readonly createdAt: FieldRef<"Instance", 'DateTime'>
    readonly updatedAt: FieldRef<"Instance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Instance findUnique
   */
  export type InstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findUniqueOrThrow
   */
  export type InstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance findFirst
   */
  export type InstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findFirstOrThrow
   */
  export type InstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instance to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instances.
     */
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance findMany
   */
  export type InstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter, which Instances to fetch.
     */
    where?: InstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instances to fetch.
     */
    orderBy?: InstanceOrderByWithRelationInput | InstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instances.
     */
    cursor?: InstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instances.
     */
    skip?: number
    distinct?: InstanceScalarFieldEnum | InstanceScalarFieldEnum[]
  }

  /**
   * Instance create
   */
  export type InstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Instance.
     */
    data: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
  }

  /**
   * Instance createMany
   */
  export type InstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instances.
     */
    data: InstanceCreateManyInput | InstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instance update
   */
  export type InstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Instance.
     */
    data: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
    /**
     * Choose, which Instance to update.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance updateMany
   */
  export type InstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instances.
     */
    data: XOR<InstanceUpdateManyMutationInput, InstanceUncheckedUpdateManyInput>
    /**
     * Filter which Instances to update
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to update.
     */
    limit?: number
  }

  /**
   * Instance upsert
   */
  export type InstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Instance to update in case it exists.
     */
    where: InstanceWhereUniqueInput
    /**
     * In case the Instance found by the `where` argument doesn't exist, create a new Instance with this data.
     */
    create: XOR<InstanceCreateInput, InstanceUncheckedCreateInput>
    /**
     * In case the Instance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstanceUpdateInput, InstanceUncheckedUpdateInput>
  }

  /**
   * Instance delete
   */
  export type InstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
    /**
     * Filter which Instance to delete.
     */
    where: InstanceWhereUniqueInput
  }

  /**
   * Instance deleteMany
   */
  export type InstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instances to delete
     */
    where?: InstanceWhereInput
    /**
     * Limit how many Instances to delete.
     */
    limit?: number
  }

  /**
   * Instance.Chat
   */
  export type Instance$ChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Instance.Contact
   */
  export type Instance$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Instance.Message
   */
  export type Instance$MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Instance.Webhook
   */
  export type Instance$WebhookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    where?: WebhookWhereInput
  }

  /**
   * Instance.Chatwoot
   */
  export type Instance$ChatwootArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    where?: ChatwootWhereInput
  }

  /**
   * Instance.Label
   */
  export type Instance$LabelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    cursor?: LabelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Instance.Proxy
   */
  export type Instance$ProxyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    where?: ProxyWhereInput
  }

  /**
   * Instance.Setting
   */
  export type Instance$SettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    where?: SettingWhereInput
  }

  /**
   * Instance.Rabbitmq
   */
  export type Instance$RabbitmqArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    where?: RabbitmqWhereInput
  }

  /**
   * Instance.Sqs
   */
  export type Instance$SqsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    where?: SqsWhereInput
  }

  /**
   * Instance.Websocket
   */
  export type Instance$WebsocketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    where?: WebsocketWhereInput
  }

  /**
   * Instance.Typebot
   */
  export type Instance$TypebotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    where?: TypebotWhereInput
    orderBy?: TypebotOrderByWithRelationInput | TypebotOrderByWithRelationInput[]
    cursor?: TypebotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TypebotScalarFieldEnum | TypebotScalarFieldEnum[]
  }

  /**
   * Instance.Session
   */
  export type Instance$SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
  }

  /**
   * Instance.MessageUpdate
   */
  export type Instance$MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    where?: MessageUpdateWhereInput
    orderBy?: MessageUpdateOrderByWithRelationInput | MessageUpdateOrderByWithRelationInput[]
    cursor?: MessageUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageUpdateScalarFieldEnum | MessageUpdateScalarFieldEnum[]
  }

  /**
   * Instance.TypebotSetting
   */
  export type Instance$TypebotSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    where?: TypebotSettingWhereInput
  }

  /**
   * Instance.Media
   */
  export type Instance$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Instance.OpenaiCreds
   */
  export type Instance$OpenaiCredsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    where?: OpenaiCredsWhereInput
    orderBy?: OpenaiCredsOrderByWithRelationInput | OpenaiCredsOrderByWithRelationInput[]
    cursor?: OpenaiCredsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpenaiCredsScalarFieldEnum | OpenaiCredsScalarFieldEnum[]
  }

  /**
   * Instance.OpenaiBot
   */
  export type Instance$OpenaiBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    where?: OpenaiBotWhereInput
    orderBy?: OpenaiBotOrderByWithRelationInput | OpenaiBotOrderByWithRelationInput[]
    cursor?: OpenaiBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpenaiBotScalarFieldEnum | OpenaiBotScalarFieldEnum[]
  }

  /**
   * Instance.OpenaiSetting
   */
  export type Instance$OpenaiSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    where?: OpenaiSettingWhereInput
  }

  /**
   * Instance.Template
   */
  export type Instance$TemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    cursor?: TemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Instance.Dify
   */
  export type Instance$DifyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    where?: DifyWhereInput
    orderBy?: DifyOrderByWithRelationInput | DifyOrderByWithRelationInput[]
    cursor?: DifyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DifyScalarFieldEnum | DifyScalarFieldEnum[]
  }

  /**
   * Instance.DifySetting
   */
  export type Instance$DifySettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    where?: DifySettingWhereInput
  }

  /**
   * Instance.integrationSessions
   */
  export type Instance$integrationSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    where?: IntegrationSessionWhereInput
    orderBy?: IntegrationSessionOrderByWithRelationInput | IntegrationSessionOrderByWithRelationInput[]
    cursor?: IntegrationSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationSessionScalarFieldEnum | IntegrationSessionScalarFieldEnum[]
  }

  /**
   * Instance.EvolutionBot
   */
  export type Instance$EvolutionBotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    where?: EvolutionBotWhereInput
    orderBy?: EvolutionBotOrderByWithRelationInput | EvolutionBotOrderByWithRelationInput[]
    cursor?: EvolutionBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolutionBotScalarFieldEnum | EvolutionBotScalarFieldEnum[]
  }

  /**
   * Instance.EvolutionBotSetting
   */
  export type Instance$EvolutionBotSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    where?: EvolutionBotSettingWhereInput
  }

  /**
   * Instance.Flowise
   */
  export type Instance$FlowiseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    where?: FlowiseWhereInput
    orderBy?: FlowiseOrderByWithRelationInput | FlowiseOrderByWithRelationInput[]
    cursor?: FlowiseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowiseScalarFieldEnum | FlowiseScalarFieldEnum[]
  }

  /**
   * Instance.FlowiseSetting
   */
  export type Instance$FlowiseSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    where?: FlowiseSettingWhereInput
  }

  /**
   * Instance.Pusher
   */
  export type Instance$PusherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    where?: PusherWhereInput
  }

  /**
   * Instance without action
   */
  export type InstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instance
     */
    select?: InstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instance
     */
    omit?: InstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstanceInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    creds: string | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    creds: string | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionId: number
    creds: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    creds?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    creds?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    creds?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionId: string
    creds: string | null
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    creds?: boolean
    createdAt?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    creds?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "creds" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      creds: string | null
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionId: FieldRef<"Session", 'String'>
    readonly creds: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatAvgAggregateOutputType = {
    unreadMessages: number | null
  }

  export type ChatSumAggregateOutputType = {
    unreadMessages: number | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    remoteJid: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
    unreadMessages: number | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    remoteJid: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
    unreadMessages: number | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    remoteJid: number
    name: number
    labels: number
    createdAt: number
    updatedAt: number
    instanceId: number
    unreadMessages: number
    _all: number
  }


  export type ChatAvgAggregateInputType = {
    unreadMessages?: true
  }

  export type ChatSumAggregateInputType = {
    unreadMessages?: true
  }

  export type ChatMinAggregateInputType = {
    id?: true
    remoteJid?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    unreadMessages?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    remoteJid?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    unreadMessages?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    remoteJid?: true
    name?: true
    labels?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    unreadMessages?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _avg?: ChatAvgAggregateInputType
    _sum?: ChatSumAggregateInputType
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    remoteJid: string
    name: string | null
    labels: JsonValue | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string
    unreadMessages: number
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    remoteJid?: boolean
    name?: boolean
    labels?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    unreadMessages?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>



  export type ChatSelectScalar = {
    id?: boolean
    remoteJid?: boolean
    name?: boolean
    labels?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    unreadMessages?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "remoteJid" | "name" | "labels" | "createdAt" | "updatedAt" | "instanceId" | "unreadMessages", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      remoteJid: string
      name: string | null
      labels: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date | null
      instanceId: string
      unreadMessages: number
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly remoteJid: FieldRef<"Chat", 'String'>
    readonly name: FieldRef<"Chat", 'String'>
    readonly labels: FieldRef<"Chat", 'Json'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
    readonly instanceId: FieldRef<"Chat", 'String'>
    readonly unreadMessages: FieldRef<"Chat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    remoteJid: string | null
    pushName: string | null
    profilePicUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    remoteJid: string | null
    pushName: string | null
    profilePicUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    remoteJid: number
    pushName: number
    profilePicUrl: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    remoteJid?: true
    pushName?: true
    profilePicUrl?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    remoteJid?: true
    pushName?: true
    profilePicUrl?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    remoteJid?: true
    pushName?: true
    profilePicUrl?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    remoteJid: string
    pushName: string | null
    profilePicUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    remoteJid?: boolean
    pushName?: boolean
    profilePicUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>



  export type ContactSelectScalar = {
    id?: boolean
    remoteJid?: boolean
    pushName?: boolean
    profilePicUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "remoteJid" | "pushName" | "profilePicUrl" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      remoteJid: string
      pushName: string | null
      profilePicUrl: string | null
      createdAt: Date | null
      updatedAt: Date | null
      instanceId: string
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly remoteJid: FieldRef<"Contact", 'String'>
    readonly pushName: FieldRef<"Contact", 'String'>
    readonly profilePicUrl: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly instanceId: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    messageTimestamp: number | null
    chatwootMessageId: number | null
    chatwootInboxId: number | null
    chatwootConversationId: number | null
  }

  export type MessageSumAggregateOutputType = {
    messageTimestamp: number | null
    chatwootMessageId: number | null
    chatwootInboxId: number | null
    chatwootConversationId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    pushName: string | null
    participant: string | null
    messageType: string | null
    source: $Enums.DeviceMessage | null
    messageTimestamp: number | null
    chatwootMessageId: number | null
    chatwootInboxId: number | null
    chatwootConversationId: number | null
    chatwootContactInboxSourceId: string | null
    chatwootIsRead: boolean | null
    instanceId: string | null
    typebotSessionId: string | null
    webhookUrl: string | null
    status: string | null
    sessionId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    pushName: string | null
    participant: string | null
    messageType: string | null
    source: $Enums.DeviceMessage | null
    messageTimestamp: number | null
    chatwootMessageId: number | null
    chatwootInboxId: number | null
    chatwootConversationId: number | null
    chatwootContactInboxSourceId: string | null
    chatwootIsRead: boolean | null
    instanceId: string | null
    typebotSessionId: string | null
    webhookUrl: string | null
    status: string | null
    sessionId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    key: number
    pushName: number
    participant: number
    messageType: number
    message: number
    contextInfo: number
    source: number
    messageTimestamp: number
    chatwootMessageId: number
    chatwootInboxId: number
    chatwootConversationId: number
    chatwootContactInboxSourceId: number
    chatwootIsRead: number
    instanceId: number
    typebotSessionId: number
    webhookUrl: number
    status: number
    sessionId: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    messageTimestamp?: true
    chatwootMessageId?: true
    chatwootInboxId?: true
    chatwootConversationId?: true
  }

  export type MessageSumAggregateInputType = {
    messageTimestamp?: true
    chatwootMessageId?: true
    chatwootInboxId?: true
    chatwootConversationId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    pushName?: true
    participant?: true
    messageType?: true
    source?: true
    messageTimestamp?: true
    chatwootMessageId?: true
    chatwootInboxId?: true
    chatwootConversationId?: true
    chatwootContactInboxSourceId?: true
    chatwootIsRead?: true
    instanceId?: true
    typebotSessionId?: true
    webhookUrl?: true
    status?: true
    sessionId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    pushName?: true
    participant?: true
    messageType?: true
    source?: true
    messageTimestamp?: true
    chatwootMessageId?: true
    chatwootInboxId?: true
    chatwootConversationId?: true
    chatwootContactInboxSourceId?: true
    chatwootIsRead?: true
    instanceId?: true
    typebotSessionId?: true
    webhookUrl?: true
    status?: true
    sessionId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    key?: true
    pushName?: true
    participant?: true
    messageType?: true
    message?: true
    contextInfo?: true
    source?: true
    messageTimestamp?: true
    chatwootMessageId?: true
    chatwootInboxId?: true
    chatwootConversationId?: true
    chatwootContactInboxSourceId?: true
    chatwootIsRead?: true
    instanceId?: true
    typebotSessionId?: true
    webhookUrl?: true
    status?: true
    sessionId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    key: JsonValue
    pushName: string | null
    participant: string | null
    messageType: string
    message: JsonValue
    contextInfo: JsonValue | null
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId: number | null
    chatwootInboxId: number | null
    chatwootConversationId: number | null
    chatwootContactInboxSourceId: string | null
    chatwootIsRead: boolean | null
    instanceId: string
    typebotSessionId: string | null
    webhookUrl: string | null
    status: string | null
    sessionId: string | null
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    pushName?: boolean
    participant?: boolean
    messageType?: boolean
    message?: boolean
    contextInfo?: boolean
    source?: boolean
    messageTimestamp?: boolean
    chatwootMessageId?: boolean
    chatwootInboxId?: boolean
    chatwootConversationId?: boolean
    chatwootContactInboxSourceId?: boolean
    chatwootIsRead?: boolean
    instanceId?: boolean
    typebotSessionId?: boolean
    webhookUrl?: boolean
    status?: boolean
    sessionId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    MessageUpdate?: boolean | Message$MessageUpdateArgs<ExtArgs>
    Media?: boolean | Message$MediaArgs<ExtArgs>
    session?: boolean | Message$sessionArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>



  export type MessageSelectScalar = {
    id?: boolean
    key?: boolean
    pushName?: boolean
    participant?: boolean
    messageType?: boolean
    message?: boolean
    contextInfo?: boolean
    source?: boolean
    messageTimestamp?: boolean
    chatwootMessageId?: boolean
    chatwootInboxId?: boolean
    chatwootConversationId?: boolean
    chatwootContactInboxSourceId?: boolean
    chatwootIsRead?: boolean
    instanceId?: boolean
    typebotSessionId?: boolean
    webhookUrl?: boolean
    status?: boolean
    sessionId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "pushName" | "participant" | "messageType" | "message" | "contextInfo" | "source" | "messageTimestamp" | "chatwootMessageId" | "chatwootInboxId" | "chatwootConversationId" | "chatwootContactInboxSourceId" | "chatwootIsRead" | "instanceId" | "typebotSessionId" | "webhookUrl" | "status" | "sessionId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    MessageUpdate?: boolean | Message$MessageUpdateArgs<ExtArgs>
    Media?: boolean | Message$MediaArgs<ExtArgs>
    session?: boolean | Message$sessionArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
      MessageUpdate: Prisma.$MessageUpdatePayload<ExtArgs>[]
      Media: Prisma.$MediaPayload<ExtArgs> | null
      session: Prisma.$IntegrationSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: Prisma.JsonValue
      pushName: string | null
      participant: string | null
      messageType: string
      message: Prisma.JsonValue
      contextInfo: Prisma.JsonValue | null
      source: $Enums.DeviceMessage
      messageTimestamp: number
      chatwootMessageId: number | null
      chatwootInboxId: number | null
      chatwootConversationId: number | null
      chatwootContactInboxSourceId: string | null
      chatwootIsRead: boolean | null
      instanceId: string
      typebotSessionId: string | null
      webhookUrl: string | null
      status: string | null
      sessionId: string | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    MessageUpdate<T extends Message$MessageUpdateArgs<ExtArgs> = {}>(args?: Subset<T, Message$MessageUpdateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Media<T extends Message$MediaArgs<ExtArgs> = {}>(args?: Subset<T, Message$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    session<T extends Message$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Message$sessionArgs<ExtArgs>>): Prisma__IntegrationSessionClient<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly key: FieldRef<"Message", 'Json'>
    readonly pushName: FieldRef<"Message", 'String'>
    readonly participant: FieldRef<"Message", 'String'>
    readonly messageType: FieldRef<"Message", 'String'>
    readonly message: FieldRef<"Message", 'Json'>
    readonly contextInfo: FieldRef<"Message", 'Json'>
    readonly source: FieldRef<"Message", 'DeviceMessage'>
    readonly messageTimestamp: FieldRef<"Message", 'Int'>
    readonly chatwootMessageId: FieldRef<"Message", 'Int'>
    readonly chatwootInboxId: FieldRef<"Message", 'Int'>
    readonly chatwootConversationId: FieldRef<"Message", 'Int'>
    readonly chatwootContactInboxSourceId: FieldRef<"Message", 'String'>
    readonly chatwootIsRead: FieldRef<"Message", 'Boolean'>
    readonly instanceId: FieldRef<"Message", 'String'>
    readonly typebotSessionId: FieldRef<"Message", 'String'>
    readonly webhookUrl: FieldRef<"Message", 'String'>
    readonly status: FieldRef<"Message", 'String'>
    readonly sessionId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.MessageUpdate
   */
  export type Message$MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    where?: MessageUpdateWhereInput
    orderBy?: MessageUpdateOrderByWithRelationInput | MessageUpdateOrderByWithRelationInput[]
    cursor?: MessageUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageUpdateScalarFieldEnum | MessageUpdateScalarFieldEnum[]
  }

  /**
   * Message.Media
   */
  export type Message$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Message.session
   */
  export type Message$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    where?: IntegrationSessionWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageUpdate
   */

  export type AggregateMessageUpdate = {
    _count: MessageUpdateCountAggregateOutputType | null
    _min: MessageUpdateMinAggregateOutputType | null
    _max: MessageUpdateMaxAggregateOutputType | null
  }

  export type MessageUpdateMinAggregateOutputType = {
    id: string | null
    keyId: string | null
    remoteJid: string | null
    fromMe: boolean | null
    participant: string | null
    status: string | null
    messageId: string | null
    instanceId: string | null
  }

  export type MessageUpdateMaxAggregateOutputType = {
    id: string | null
    keyId: string | null
    remoteJid: string | null
    fromMe: boolean | null
    participant: string | null
    status: string | null
    messageId: string | null
    instanceId: string | null
  }

  export type MessageUpdateCountAggregateOutputType = {
    id: number
    keyId: number
    remoteJid: number
    fromMe: number
    participant: number
    pollUpdates: number
    status: number
    messageId: number
    instanceId: number
    _all: number
  }


  export type MessageUpdateMinAggregateInputType = {
    id?: true
    keyId?: true
    remoteJid?: true
    fromMe?: true
    participant?: true
    status?: true
    messageId?: true
    instanceId?: true
  }

  export type MessageUpdateMaxAggregateInputType = {
    id?: true
    keyId?: true
    remoteJid?: true
    fromMe?: true
    participant?: true
    status?: true
    messageId?: true
    instanceId?: true
  }

  export type MessageUpdateCountAggregateInputType = {
    id?: true
    keyId?: true
    remoteJid?: true
    fromMe?: true
    participant?: true
    pollUpdates?: true
    status?: true
    messageId?: true
    instanceId?: true
    _all?: true
  }

  export type MessageUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageUpdate to aggregate.
     */
    where?: MessageUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageUpdates to fetch.
     */
    orderBy?: MessageUpdateOrderByWithRelationInput | MessageUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageUpdates
    **/
    _count?: true | MessageUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageUpdateMaxAggregateInputType
  }

  export type GetMessageUpdateAggregateType<T extends MessageUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageUpdate[P]>
      : GetScalarType<T[P], AggregateMessageUpdate[P]>
  }




  export type MessageUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageUpdateWhereInput
    orderBy?: MessageUpdateOrderByWithAggregationInput | MessageUpdateOrderByWithAggregationInput[]
    by: MessageUpdateScalarFieldEnum[] | MessageUpdateScalarFieldEnum
    having?: MessageUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageUpdateCountAggregateInputType | true
    _min?: MessageUpdateMinAggregateInputType
    _max?: MessageUpdateMaxAggregateInputType
  }

  export type MessageUpdateGroupByOutputType = {
    id: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant: string | null
    pollUpdates: JsonValue | null
    status: string
    messageId: string
    instanceId: string
    _count: MessageUpdateCountAggregateOutputType | null
    _min: MessageUpdateMinAggregateOutputType | null
    _max: MessageUpdateMaxAggregateOutputType | null
  }

  type GetMessageUpdateGroupByPayload<T extends MessageUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], MessageUpdateGroupByOutputType[P]>
        }
      >
    >


  export type MessageUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyId?: boolean
    remoteJid?: boolean
    fromMe?: boolean
    participant?: boolean
    pollUpdates?: boolean
    status?: boolean
    messageId?: boolean
    instanceId?: boolean
    Message?: boolean | MessageDefaultArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageUpdate"]>



  export type MessageUpdateSelectScalar = {
    id?: boolean
    keyId?: boolean
    remoteJid?: boolean
    fromMe?: boolean
    participant?: boolean
    pollUpdates?: boolean
    status?: boolean
    messageId?: boolean
    instanceId?: boolean
  }

  export type MessageUpdateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyId" | "remoteJid" | "fromMe" | "participant" | "pollUpdates" | "status" | "messageId" | "instanceId", ExtArgs["result"]["messageUpdate"]>
  export type MessageUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Message?: boolean | MessageDefaultArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $MessageUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageUpdate"
    objects: {
      Message: Prisma.$MessagePayload<ExtArgs>
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyId: string
      remoteJid: string
      fromMe: boolean
      participant: string | null
      pollUpdates: Prisma.JsonValue | null
      status: string
      messageId: string
      instanceId: string
    }, ExtArgs["result"]["messageUpdate"]>
    composites: {}
  }

  type MessageUpdateGetPayload<S extends boolean | null | undefined | MessageUpdateDefaultArgs> = $Result.GetResult<Prisma.$MessageUpdatePayload, S>

  type MessageUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageUpdateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageUpdateCountAggregateInputType | true
    }

  export interface MessageUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageUpdate'], meta: { name: 'MessageUpdate' } }
    /**
     * Find zero or one MessageUpdate that matches the filter.
     * @param {MessageUpdateFindUniqueArgs} args - Arguments to find a MessageUpdate
     * @example
     * // Get one MessageUpdate
     * const messageUpdate = await prisma.messageUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageUpdateFindUniqueArgs>(args: SelectSubset<T, MessageUpdateFindUniqueArgs<ExtArgs>>): Prisma__MessageUpdateClient<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MessageUpdate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageUpdateFindUniqueOrThrowArgs} args - Arguments to find a MessageUpdate
     * @example
     * // Get one MessageUpdate
     * const messageUpdate = await prisma.messageUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageUpdateClient<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MessageUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateFindFirstArgs} args - Arguments to find a MessageUpdate
     * @example
     * // Get one MessageUpdate
     * const messageUpdate = await prisma.messageUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageUpdateFindFirstArgs>(args?: SelectSubset<T, MessageUpdateFindFirstArgs<ExtArgs>>): Prisma__MessageUpdateClient<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MessageUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateFindFirstOrThrowArgs} args - Arguments to find a MessageUpdate
     * @example
     * // Get one MessageUpdate
     * const messageUpdate = await prisma.messageUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageUpdateClient<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MessageUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageUpdates
     * const messageUpdates = await prisma.messageUpdate.findMany()
     * 
     * // Get first 10 MessageUpdates
     * const messageUpdates = await prisma.messageUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageUpdateWithIdOnly = await prisma.messageUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageUpdateFindManyArgs>(args?: SelectSubset<T, MessageUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MessageUpdate.
     * @param {MessageUpdateCreateArgs} args - Arguments to create a MessageUpdate.
     * @example
     * // Create one MessageUpdate
     * const MessageUpdate = await prisma.messageUpdate.create({
     *   data: {
     *     // ... data to create a MessageUpdate
     *   }
     * })
     * 
     */
    create<T extends MessageUpdateCreateArgs>(args: SelectSubset<T, MessageUpdateCreateArgs<ExtArgs>>): Prisma__MessageUpdateClient<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MessageUpdates.
     * @param {MessageUpdateCreateManyArgs} args - Arguments to create many MessageUpdates.
     * @example
     * // Create many MessageUpdates
     * const messageUpdate = await prisma.messageUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageUpdateCreateManyArgs>(args?: SelectSubset<T, MessageUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageUpdate.
     * @param {MessageUpdateDeleteArgs} args - Arguments to delete one MessageUpdate.
     * @example
     * // Delete one MessageUpdate
     * const MessageUpdate = await prisma.messageUpdate.delete({
     *   where: {
     *     // ... filter to delete one MessageUpdate
     *   }
     * })
     * 
     */
    delete<T extends MessageUpdateDeleteArgs>(args: SelectSubset<T, MessageUpdateDeleteArgs<ExtArgs>>): Prisma__MessageUpdateClient<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MessageUpdate.
     * @param {MessageUpdateUpdateArgs} args - Arguments to update one MessageUpdate.
     * @example
     * // Update one MessageUpdate
     * const messageUpdate = await prisma.messageUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateUpdateArgs>(args: SelectSubset<T, MessageUpdateUpdateArgs<ExtArgs>>): Prisma__MessageUpdateClient<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MessageUpdates.
     * @param {MessageUpdateDeleteManyArgs} args - Arguments to filter MessageUpdates to delete.
     * @example
     * // Delete a few MessageUpdates
     * const { count } = await prisma.messageUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageUpdateDeleteManyArgs>(args?: SelectSubset<T, MessageUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageUpdates
     * const messageUpdate = await prisma.messageUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateUpdateManyArgs>(args: SelectSubset<T, MessageUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageUpdate.
     * @param {MessageUpdateUpsertArgs} args - Arguments to update or create a MessageUpdate.
     * @example
     * // Update or create a MessageUpdate
     * const messageUpdate = await prisma.messageUpdate.upsert({
     *   create: {
     *     // ... data to create a MessageUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageUpdate we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpdateUpsertArgs>(args: SelectSubset<T, MessageUpdateUpsertArgs<ExtArgs>>): Prisma__MessageUpdateClient<$Result.GetResult<Prisma.$MessageUpdatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MessageUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateCountArgs} args - Arguments to filter MessageUpdates to count.
     * @example
     * // Count the number of MessageUpdates
     * const count = await prisma.messageUpdate.count({
     *   where: {
     *     // ... the filter for the MessageUpdates we want to count
     *   }
     * })
    **/
    count<T extends MessageUpdateCountArgs>(
      args?: Subset<T, MessageUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageUpdateAggregateArgs>(args: Subset<T, MessageUpdateAggregateArgs>): Prisma.PrismaPromise<GetMessageUpdateAggregateType<T>>

    /**
     * Group by MessageUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageUpdateGroupByArgs['orderBy'] }
        : { orderBy?: MessageUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageUpdate model
   */
  readonly fields: MessageUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageUpdate model
   */ 
  interface MessageUpdateFieldRefs {
    readonly id: FieldRef<"MessageUpdate", 'String'>
    readonly keyId: FieldRef<"MessageUpdate", 'String'>
    readonly remoteJid: FieldRef<"MessageUpdate", 'String'>
    readonly fromMe: FieldRef<"MessageUpdate", 'Boolean'>
    readonly participant: FieldRef<"MessageUpdate", 'String'>
    readonly pollUpdates: FieldRef<"MessageUpdate", 'Json'>
    readonly status: FieldRef<"MessageUpdate", 'String'>
    readonly messageId: FieldRef<"MessageUpdate", 'String'>
    readonly instanceId: FieldRef<"MessageUpdate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MessageUpdate findUnique
   */
  export type MessageUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    /**
     * Filter, which MessageUpdate to fetch.
     */
    where: MessageUpdateWhereUniqueInput
  }

  /**
   * MessageUpdate findUniqueOrThrow
   */
  export type MessageUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    /**
     * Filter, which MessageUpdate to fetch.
     */
    where: MessageUpdateWhereUniqueInput
  }

  /**
   * MessageUpdate findFirst
   */
  export type MessageUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    /**
     * Filter, which MessageUpdate to fetch.
     */
    where?: MessageUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageUpdates to fetch.
     */
    orderBy?: MessageUpdateOrderByWithRelationInput | MessageUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageUpdates.
     */
    cursor?: MessageUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageUpdates.
     */
    distinct?: MessageUpdateScalarFieldEnum | MessageUpdateScalarFieldEnum[]
  }

  /**
   * MessageUpdate findFirstOrThrow
   */
  export type MessageUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    /**
     * Filter, which MessageUpdate to fetch.
     */
    where?: MessageUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageUpdates to fetch.
     */
    orderBy?: MessageUpdateOrderByWithRelationInput | MessageUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageUpdates.
     */
    cursor?: MessageUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageUpdates.
     */
    distinct?: MessageUpdateScalarFieldEnum | MessageUpdateScalarFieldEnum[]
  }

  /**
   * MessageUpdate findMany
   */
  export type MessageUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    /**
     * Filter, which MessageUpdates to fetch.
     */
    where?: MessageUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageUpdates to fetch.
     */
    orderBy?: MessageUpdateOrderByWithRelationInput | MessageUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageUpdates.
     */
    cursor?: MessageUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageUpdates.
     */
    skip?: number
    distinct?: MessageUpdateScalarFieldEnum | MessageUpdateScalarFieldEnum[]
  }

  /**
   * MessageUpdate create
   */
  export type MessageUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageUpdate.
     */
    data: XOR<MessageUpdateCreateInput, MessageUpdateUncheckedCreateInput>
  }

  /**
   * MessageUpdate createMany
   */
  export type MessageUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageUpdates.
     */
    data: MessageUpdateCreateManyInput | MessageUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageUpdate update
   */
  export type MessageUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageUpdate.
     */
    data: XOR<MessageUpdateUpdateInput, MessageUpdateUncheckedUpdateInput>
    /**
     * Choose, which MessageUpdate to update.
     */
    where: MessageUpdateWhereUniqueInput
  }

  /**
   * MessageUpdate updateMany
   */
  export type MessageUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageUpdates.
     */
    data: XOR<MessageUpdateUpdateManyMutationInput, MessageUpdateUncheckedUpdateManyInput>
    /**
     * Filter which MessageUpdates to update
     */
    where?: MessageUpdateWhereInput
    /**
     * Limit how many MessageUpdates to update.
     */
    limit?: number
  }

  /**
   * MessageUpdate upsert
   */
  export type MessageUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageUpdate to update in case it exists.
     */
    where: MessageUpdateWhereUniqueInput
    /**
     * In case the MessageUpdate found by the `where` argument doesn't exist, create a new MessageUpdate with this data.
     */
    create: XOR<MessageUpdateCreateInput, MessageUpdateUncheckedCreateInput>
    /**
     * In case the MessageUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateUpdateInput, MessageUpdateUncheckedUpdateInput>
  }

  /**
   * MessageUpdate delete
   */
  export type MessageUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
    /**
     * Filter which MessageUpdate to delete.
     */
    where: MessageUpdateWhereUniqueInput
  }

  /**
   * MessageUpdate deleteMany
   */
  export type MessageUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageUpdates to delete
     */
    where?: MessageUpdateWhereInput
    /**
     * Limit how many MessageUpdates to delete.
     */
    limit?: number
  }

  /**
   * MessageUpdate without action
   */
  export type MessageUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageUpdate
     */
    select?: MessageUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageUpdate
     */
    omit?: MessageUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageUpdateInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    url: string | null
    enabled: boolean | null
    webhookByEvents: boolean | null
    webhookBase64: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    url: string | null
    enabled: boolean | null
    webhookByEvents: boolean | null
    webhookBase64: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    url: number
    headers: number
    enabled: number
    events: number
    webhookByEvents: number
    webhookBase64: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type WebhookMinAggregateInputType = {
    id?: true
    url?: true
    enabled?: true
    webhookByEvents?: true
    webhookBase64?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    url?: true
    enabled?: true
    webhookByEvents?: true
    webhookBase64?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    url?: true
    headers?: true
    enabled?: true
    events?: true
    webhookByEvents?: true
    webhookBase64?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    url: string
    headers: JsonValue | null
    enabled: boolean | null
    events: JsonValue | null
    webhookByEvents: boolean | null
    webhookBase64: boolean | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: WebhookCountAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    headers?: boolean
    enabled?: boolean
    events?: boolean
    webhookByEvents?: boolean
    webhookBase64?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["webhook"]>



  export type WebhookSelectScalar = {
    id?: boolean
    url?: boolean
    headers?: boolean
    enabled?: boolean
    events?: boolean
    webhookByEvents?: boolean
    webhookBase64?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type WebhookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "headers" | "enabled" | "events" | "webhookByEvents" | "webhookBase64" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["webhook"]>
  export type WebhookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      headers: Prisma.JsonValue | null
      enabled: boolean | null
      events: Prisma.JsonValue | null
      webhookByEvents: boolean | null
      webhookBase64: boolean | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */ 
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly headers: FieldRef<"Webhook", 'Json'>
    readonly enabled: FieldRef<"Webhook", 'Boolean'>
    readonly events: FieldRef<"Webhook", 'Json'>
    readonly webhookByEvents: FieldRef<"Webhook", 'Boolean'>
    readonly webhookBase64: FieldRef<"Webhook", 'Boolean'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
    readonly instanceId: FieldRef<"Webhook", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to update.
     */
    limit?: number
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
    /**
     * Limit how many Webhooks to delete.
     */
    limit?: number
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Webhook
     */
    omit?: WebhookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookInclude<ExtArgs> | null
  }


  /**
   * Model Chatwoot
   */

  export type AggregateChatwoot = {
    _count: ChatwootCountAggregateOutputType | null
    _avg: ChatwootAvgAggregateOutputType | null
    _sum: ChatwootSumAggregateOutputType | null
    _min: ChatwootMinAggregateOutputType | null
    _max: ChatwootMaxAggregateOutputType | null
  }

  export type ChatwootAvgAggregateOutputType = {
    daysLimitImportMessages: number | null
  }

  export type ChatwootSumAggregateOutputType = {
    daysLimitImportMessages: number | null
  }

  export type ChatwootMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    accountId: string | null
    token: string | null
    url: string | null
    nameInbox: string | null
    signMsg: boolean | null
    signDelimiter: string | null
    number: string | null
    reopenConversation: boolean | null
    conversationPending: boolean | null
    mergeBrazilContacts: boolean | null
    importContacts: boolean | null
    importMessages: boolean | null
    daysLimitImportMessages: number | null
    organization: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type ChatwootMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    accountId: string | null
    token: string | null
    url: string | null
    nameInbox: string | null
    signMsg: boolean | null
    signDelimiter: string | null
    number: string | null
    reopenConversation: boolean | null
    conversationPending: boolean | null
    mergeBrazilContacts: boolean | null
    importContacts: boolean | null
    importMessages: boolean | null
    daysLimitImportMessages: number | null
    organization: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type ChatwootCountAggregateOutputType = {
    id: number
    enabled: number
    accountId: number
    token: number
    url: number
    nameInbox: number
    signMsg: number
    signDelimiter: number
    number: number
    reopenConversation: number
    conversationPending: number
    mergeBrazilContacts: number
    importContacts: number
    importMessages: number
    daysLimitImportMessages: number
    organization: number
    logo: number
    ignoreJids: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type ChatwootAvgAggregateInputType = {
    daysLimitImportMessages?: true
  }

  export type ChatwootSumAggregateInputType = {
    daysLimitImportMessages?: true
  }

  export type ChatwootMinAggregateInputType = {
    id?: true
    enabled?: true
    accountId?: true
    token?: true
    url?: true
    nameInbox?: true
    signMsg?: true
    signDelimiter?: true
    number?: true
    reopenConversation?: true
    conversationPending?: true
    mergeBrazilContacts?: true
    importContacts?: true
    importMessages?: true
    daysLimitImportMessages?: true
    organization?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type ChatwootMaxAggregateInputType = {
    id?: true
    enabled?: true
    accountId?: true
    token?: true
    url?: true
    nameInbox?: true
    signMsg?: true
    signDelimiter?: true
    number?: true
    reopenConversation?: true
    conversationPending?: true
    mergeBrazilContacts?: true
    importContacts?: true
    importMessages?: true
    daysLimitImportMessages?: true
    organization?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type ChatwootCountAggregateInputType = {
    id?: true
    enabled?: true
    accountId?: true
    token?: true
    url?: true
    nameInbox?: true
    signMsg?: true
    signDelimiter?: true
    number?: true
    reopenConversation?: true
    conversationPending?: true
    mergeBrazilContacts?: true
    importContacts?: true
    importMessages?: true
    daysLimitImportMessages?: true
    organization?: true
    logo?: true
    ignoreJids?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type ChatwootAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatwoot to aggregate.
     */
    where?: ChatwootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatwoots to fetch.
     */
    orderBy?: ChatwootOrderByWithRelationInput | ChatwootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatwootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatwoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatwoots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chatwoots
    **/
    _count?: true | ChatwootCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatwootAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatwootSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatwootMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatwootMaxAggregateInputType
  }

  export type GetChatwootAggregateType<T extends ChatwootAggregateArgs> = {
        [P in keyof T & keyof AggregateChatwoot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatwoot[P]>
      : GetScalarType<T[P], AggregateChatwoot[P]>
  }




  export type ChatwootGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatwootWhereInput
    orderBy?: ChatwootOrderByWithAggregationInput | ChatwootOrderByWithAggregationInput[]
    by: ChatwootScalarFieldEnum[] | ChatwootScalarFieldEnum
    having?: ChatwootScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatwootCountAggregateInputType | true
    _avg?: ChatwootAvgAggregateInputType
    _sum?: ChatwootSumAggregateInputType
    _min?: ChatwootMinAggregateInputType
    _max?: ChatwootMaxAggregateInputType
  }

  export type ChatwootGroupByOutputType = {
    id: string
    enabled: boolean | null
    accountId: string | null
    token: string | null
    url: string | null
    nameInbox: string | null
    signMsg: boolean | null
    signDelimiter: string | null
    number: string | null
    reopenConversation: boolean | null
    conversationPending: boolean | null
    mergeBrazilContacts: boolean | null
    importContacts: boolean | null
    importMessages: boolean | null
    daysLimitImportMessages: number | null
    organization: string | null
    logo: string | null
    ignoreJids: JsonValue | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: ChatwootCountAggregateOutputType | null
    _avg: ChatwootAvgAggregateOutputType | null
    _sum: ChatwootSumAggregateOutputType | null
    _min: ChatwootMinAggregateOutputType | null
    _max: ChatwootMaxAggregateOutputType | null
  }

  type GetChatwootGroupByPayload<T extends ChatwootGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatwootGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatwootGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatwootGroupByOutputType[P]>
            : GetScalarType<T[P], ChatwootGroupByOutputType[P]>
        }
      >
    >


  export type ChatwootSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    accountId?: boolean
    token?: boolean
    url?: boolean
    nameInbox?: boolean
    signMsg?: boolean
    signDelimiter?: boolean
    number?: boolean
    reopenConversation?: boolean
    conversationPending?: boolean
    mergeBrazilContacts?: boolean
    importContacts?: boolean
    importMessages?: boolean
    daysLimitImportMessages?: boolean
    organization?: boolean
    logo?: boolean
    ignoreJids?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatwoot"]>



  export type ChatwootSelectScalar = {
    id?: boolean
    enabled?: boolean
    accountId?: boolean
    token?: boolean
    url?: boolean
    nameInbox?: boolean
    signMsg?: boolean
    signDelimiter?: boolean
    number?: boolean
    reopenConversation?: boolean
    conversationPending?: boolean
    mergeBrazilContacts?: boolean
    importContacts?: boolean
    importMessages?: boolean
    daysLimitImportMessages?: boolean
    organization?: boolean
    logo?: boolean
    ignoreJids?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type ChatwootOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "accountId" | "token" | "url" | "nameInbox" | "signMsg" | "signDelimiter" | "number" | "reopenConversation" | "conversationPending" | "mergeBrazilContacts" | "importContacts" | "importMessages" | "daysLimitImportMessages" | "organization" | "logo" | "ignoreJids" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["chatwoot"]>
  export type ChatwootInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $ChatwootPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chatwoot"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean | null
      accountId: string | null
      token: string | null
      url: string | null
      nameInbox: string | null
      signMsg: boolean | null
      signDelimiter: string | null
      number: string | null
      reopenConversation: boolean | null
      conversationPending: boolean | null
      mergeBrazilContacts: boolean | null
      importContacts: boolean | null
      importMessages: boolean | null
      daysLimitImportMessages: number | null
      organization: string | null
      logo: string | null
      ignoreJids: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["chatwoot"]>
    composites: {}
  }

  type ChatwootGetPayload<S extends boolean | null | undefined | ChatwootDefaultArgs> = $Result.GetResult<Prisma.$ChatwootPayload, S>

  type ChatwootCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatwootFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatwootCountAggregateInputType | true
    }

  export interface ChatwootDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chatwoot'], meta: { name: 'Chatwoot' } }
    /**
     * Find zero or one Chatwoot that matches the filter.
     * @param {ChatwootFindUniqueArgs} args - Arguments to find a Chatwoot
     * @example
     * // Get one Chatwoot
     * const chatwoot = await prisma.chatwoot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatwootFindUniqueArgs>(args: SelectSubset<T, ChatwootFindUniqueArgs<ExtArgs>>): Prisma__ChatwootClient<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Chatwoot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatwootFindUniqueOrThrowArgs} args - Arguments to find a Chatwoot
     * @example
     * // Get one Chatwoot
     * const chatwoot = await prisma.chatwoot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatwootFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatwootFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatwootClient<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Chatwoot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatwootFindFirstArgs} args - Arguments to find a Chatwoot
     * @example
     * // Get one Chatwoot
     * const chatwoot = await prisma.chatwoot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatwootFindFirstArgs>(args?: SelectSubset<T, ChatwootFindFirstArgs<ExtArgs>>): Prisma__ChatwootClient<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Chatwoot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatwootFindFirstOrThrowArgs} args - Arguments to find a Chatwoot
     * @example
     * // Get one Chatwoot
     * const chatwoot = await prisma.chatwoot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatwootFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatwootFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatwootClient<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Chatwoots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatwootFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatwoots
     * const chatwoots = await prisma.chatwoot.findMany()
     * 
     * // Get first 10 Chatwoots
     * const chatwoots = await prisma.chatwoot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatwootWithIdOnly = await prisma.chatwoot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatwootFindManyArgs>(args?: SelectSubset<T, ChatwootFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Chatwoot.
     * @param {ChatwootCreateArgs} args - Arguments to create a Chatwoot.
     * @example
     * // Create one Chatwoot
     * const Chatwoot = await prisma.chatwoot.create({
     *   data: {
     *     // ... data to create a Chatwoot
     *   }
     * })
     * 
     */
    create<T extends ChatwootCreateArgs>(args: SelectSubset<T, ChatwootCreateArgs<ExtArgs>>): Prisma__ChatwootClient<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Chatwoots.
     * @param {ChatwootCreateManyArgs} args - Arguments to create many Chatwoots.
     * @example
     * // Create many Chatwoots
     * const chatwoot = await prisma.chatwoot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatwootCreateManyArgs>(args?: SelectSubset<T, ChatwootCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Chatwoot.
     * @param {ChatwootDeleteArgs} args - Arguments to delete one Chatwoot.
     * @example
     * // Delete one Chatwoot
     * const Chatwoot = await prisma.chatwoot.delete({
     *   where: {
     *     // ... filter to delete one Chatwoot
     *   }
     * })
     * 
     */
    delete<T extends ChatwootDeleteArgs>(args: SelectSubset<T, ChatwootDeleteArgs<ExtArgs>>): Prisma__ChatwootClient<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Chatwoot.
     * @param {ChatwootUpdateArgs} args - Arguments to update one Chatwoot.
     * @example
     * // Update one Chatwoot
     * const chatwoot = await prisma.chatwoot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatwootUpdateArgs>(args: SelectSubset<T, ChatwootUpdateArgs<ExtArgs>>): Prisma__ChatwootClient<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Chatwoots.
     * @param {ChatwootDeleteManyArgs} args - Arguments to filter Chatwoots to delete.
     * @example
     * // Delete a few Chatwoots
     * const { count } = await prisma.chatwoot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatwootDeleteManyArgs>(args?: SelectSubset<T, ChatwootDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatwoots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatwootUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatwoots
     * const chatwoot = await prisma.chatwoot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatwootUpdateManyArgs>(args: SelectSubset<T, ChatwootUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chatwoot.
     * @param {ChatwootUpsertArgs} args - Arguments to update or create a Chatwoot.
     * @example
     * // Update or create a Chatwoot
     * const chatwoot = await prisma.chatwoot.upsert({
     *   create: {
     *     // ... data to create a Chatwoot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatwoot we want to update
     *   }
     * })
     */
    upsert<T extends ChatwootUpsertArgs>(args: SelectSubset<T, ChatwootUpsertArgs<ExtArgs>>): Prisma__ChatwootClient<$Result.GetResult<Prisma.$ChatwootPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Chatwoots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatwootCountArgs} args - Arguments to filter Chatwoots to count.
     * @example
     * // Count the number of Chatwoots
     * const count = await prisma.chatwoot.count({
     *   where: {
     *     // ... the filter for the Chatwoots we want to count
     *   }
     * })
    **/
    count<T extends ChatwootCountArgs>(
      args?: Subset<T, ChatwootCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatwootCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatwoot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatwootAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatwootAggregateArgs>(args: Subset<T, ChatwootAggregateArgs>): Prisma.PrismaPromise<GetChatwootAggregateType<T>>

    /**
     * Group by Chatwoot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatwootGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatwootGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatwootGroupByArgs['orderBy'] }
        : { orderBy?: ChatwootGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatwootGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatwootGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chatwoot model
   */
  readonly fields: ChatwootFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chatwoot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatwootClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chatwoot model
   */ 
  interface ChatwootFieldRefs {
    readonly id: FieldRef<"Chatwoot", 'String'>
    readonly enabled: FieldRef<"Chatwoot", 'Boolean'>
    readonly accountId: FieldRef<"Chatwoot", 'String'>
    readonly token: FieldRef<"Chatwoot", 'String'>
    readonly url: FieldRef<"Chatwoot", 'String'>
    readonly nameInbox: FieldRef<"Chatwoot", 'String'>
    readonly signMsg: FieldRef<"Chatwoot", 'Boolean'>
    readonly signDelimiter: FieldRef<"Chatwoot", 'String'>
    readonly number: FieldRef<"Chatwoot", 'String'>
    readonly reopenConversation: FieldRef<"Chatwoot", 'Boolean'>
    readonly conversationPending: FieldRef<"Chatwoot", 'Boolean'>
    readonly mergeBrazilContacts: FieldRef<"Chatwoot", 'Boolean'>
    readonly importContacts: FieldRef<"Chatwoot", 'Boolean'>
    readonly importMessages: FieldRef<"Chatwoot", 'Boolean'>
    readonly daysLimitImportMessages: FieldRef<"Chatwoot", 'Int'>
    readonly organization: FieldRef<"Chatwoot", 'String'>
    readonly logo: FieldRef<"Chatwoot", 'String'>
    readonly ignoreJids: FieldRef<"Chatwoot", 'Json'>
    readonly createdAt: FieldRef<"Chatwoot", 'DateTime'>
    readonly updatedAt: FieldRef<"Chatwoot", 'DateTime'>
    readonly instanceId: FieldRef<"Chatwoot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chatwoot findUnique
   */
  export type ChatwootFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    /**
     * Filter, which Chatwoot to fetch.
     */
    where: ChatwootWhereUniqueInput
  }

  /**
   * Chatwoot findUniqueOrThrow
   */
  export type ChatwootFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    /**
     * Filter, which Chatwoot to fetch.
     */
    where: ChatwootWhereUniqueInput
  }

  /**
   * Chatwoot findFirst
   */
  export type ChatwootFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    /**
     * Filter, which Chatwoot to fetch.
     */
    where?: ChatwootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatwoots to fetch.
     */
    orderBy?: ChatwootOrderByWithRelationInput | ChatwootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatwoots.
     */
    cursor?: ChatwootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatwoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatwoots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatwoots.
     */
    distinct?: ChatwootScalarFieldEnum | ChatwootScalarFieldEnum[]
  }

  /**
   * Chatwoot findFirstOrThrow
   */
  export type ChatwootFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    /**
     * Filter, which Chatwoot to fetch.
     */
    where?: ChatwootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatwoots to fetch.
     */
    orderBy?: ChatwootOrderByWithRelationInput | ChatwootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatwoots.
     */
    cursor?: ChatwootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatwoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatwoots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatwoots.
     */
    distinct?: ChatwootScalarFieldEnum | ChatwootScalarFieldEnum[]
  }

  /**
   * Chatwoot findMany
   */
  export type ChatwootFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    /**
     * Filter, which Chatwoots to fetch.
     */
    where?: ChatwootWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatwoots to fetch.
     */
    orderBy?: ChatwootOrderByWithRelationInput | ChatwootOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chatwoots.
     */
    cursor?: ChatwootWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatwoots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatwoots.
     */
    skip?: number
    distinct?: ChatwootScalarFieldEnum | ChatwootScalarFieldEnum[]
  }

  /**
   * Chatwoot create
   */
  export type ChatwootCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    /**
     * The data needed to create a Chatwoot.
     */
    data: XOR<ChatwootCreateInput, ChatwootUncheckedCreateInput>
  }

  /**
   * Chatwoot createMany
   */
  export type ChatwootCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chatwoots.
     */
    data: ChatwootCreateManyInput | ChatwootCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chatwoot update
   */
  export type ChatwootUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    /**
     * The data needed to update a Chatwoot.
     */
    data: XOR<ChatwootUpdateInput, ChatwootUncheckedUpdateInput>
    /**
     * Choose, which Chatwoot to update.
     */
    where: ChatwootWhereUniqueInput
  }

  /**
   * Chatwoot updateMany
   */
  export type ChatwootUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chatwoots.
     */
    data: XOR<ChatwootUpdateManyMutationInput, ChatwootUncheckedUpdateManyInput>
    /**
     * Filter which Chatwoots to update
     */
    where?: ChatwootWhereInput
    /**
     * Limit how many Chatwoots to update.
     */
    limit?: number
  }

  /**
   * Chatwoot upsert
   */
  export type ChatwootUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    /**
     * The filter to search for the Chatwoot to update in case it exists.
     */
    where: ChatwootWhereUniqueInput
    /**
     * In case the Chatwoot found by the `where` argument doesn't exist, create a new Chatwoot with this data.
     */
    create: XOR<ChatwootCreateInput, ChatwootUncheckedCreateInput>
    /**
     * In case the Chatwoot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatwootUpdateInput, ChatwootUncheckedUpdateInput>
  }

  /**
   * Chatwoot delete
   */
  export type ChatwootDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
    /**
     * Filter which Chatwoot to delete.
     */
    where: ChatwootWhereUniqueInput
  }

  /**
   * Chatwoot deleteMany
   */
  export type ChatwootDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatwoots to delete
     */
    where?: ChatwootWhereInput
    /**
     * Limit how many Chatwoots to delete.
     */
    limit?: number
  }

  /**
   * Chatwoot without action
   */
  export type ChatwootDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatwoot
     */
    select?: ChatwootSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatwoot
     */
    omit?: ChatwootOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatwootInclude<ExtArgs> | null
  }


  /**
   * Model Label
   */

  export type AggregateLabel = {
    _count: LabelCountAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  export type LabelMinAggregateOutputType = {
    id: string | null
    labelId: string | null
    name: string | null
    color: string | null
    predefinedId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type LabelMaxAggregateOutputType = {
    id: string | null
    labelId: string | null
    name: string | null
    color: string | null
    predefinedId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type LabelCountAggregateOutputType = {
    id: number
    labelId: number
    name: number
    color: number
    predefinedId: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type LabelMinAggregateInputType = {
    id?: true
    labelId?: true
    name?: true
    color?: true
    predefinedId?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type LabelMaxAggregateInputType = {
    id?: true
    labelId?: true
    name?: true
    color?: true
    predefinedId?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type LabelCountAggregateInputType = {
    id?: true
    labelId?: true
    name?: true
    color?: true
    predefinedId?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type LabelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Label to aggregate.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labels
    **/
    _count?: true | LabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelMaxAggregateInputType
  }

  export type GetLabelAggregateType<T extends LabelAggregateArgs> = {
        [P in keyof T & keyof AggregateLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabel[P]>
      : GetScalarType<T[P], AggregateLabel[P]>
  }




  export type LabelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabelWhereInput
    orderBy?: LabelOrderByWithAggregationInput | LabelOrderByWithAggregationInput[]
    by: LabelScalarFieldEnum[] | LabelScalarFieldEnum
    having?: LabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelCountAggregateInputType | true
    _min?: LabelMinAggregateInputType
    _max?: LabelMaxAggregateInputType
  }

  export type LabelGroupByOutputType = {
    id: string
    labelId: string | null
    name: string
    color: string
    predefinedId: string | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: LabelCountAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  type GetLabelGroupByPayload<T extends LabelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelGroupByOutputType[P]>
            : GetScalarType<T[P], LabelGroupByOutputType[P]>
        }
      >
    >


  export type LabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labelId?: boolean
    name?: boolean
    color?: boolean
    predefinedId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["label"]>



  export type LabelSelectScalar = {
    id?: boolean
    labelId?: boolean
    name?: boolean
    color?: boolean
    predefinedId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type LabelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "labelId" | "name" | "color" | "predefinedId" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["label"]>
  export type LabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $LabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Label"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      labelId: string | null
      name: string
      color: string
      predefinedId: string | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["label"]>
    composites: {}
  }

  type LabelGetPayload<S extends boolean | null | undefined | LabelDefaultArgs> = $Result.GetResult<Prisma.$LabelPayload, S>

  type LabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabelCountAggregateInputType | true
    }

  export interface LabelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Label'], meta: { name: 'Label' } }
    /**
     * Find zero or one Label that matches the filter.
     * @param {LabelFindUniqueArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabelFindUniqueArgs>(args: SelectSubset<T, LabelFindUniqueArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Label that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabelFindUniqueOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabelFindUniqueOrThrowArgs>(args: SelectSubset<T, LabelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Label that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabelFindFirstArgs>(args?: SelectSubset<T, LabelFindFirstArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Label that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstOrThrowArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabelFindFirstOrThrowArgs>(args?: SelectSubset<T, LabelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Labels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labels
     * const labels = await prisma.label.findMany()
     * 
     * // Get first 10 Labels
     * const labels = await prisma.label.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labelWithIdOnly = await prisma.label.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabelFindManyArgs>(args?: SelectSubset<T, LabelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Label.
     * @param {LabelCreateArgs} args - Arguments to create a Label.
     * @example
     * // Create one Label
     * const Label = await prisma.label.create({
     *   data: {
     *     // ... data to create a Label
     *   }
     * })
     * 
     */
    create<T extends LabelCreateArgs>(args: SelectSubset<T, LabelCreateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Labels.
     * @param {LabelCreateManyArgs} args - Arguments to create many Labels.
     * @example
     * // Create many Labels
     * const label = await prisma.label.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabelCreateManyArgs>(args?: SelectSubset<T, LabelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Label.
     * @param {LabelDeleteArgs} args - Arguments to delete one Label.
     * @example
     * // Delete one Label
     * const Label = await prisma.label.delete({
     *   where: {
     *     // ... filter to delete one Label
     *   }
     * })
     * 
     */
    delete<T extends LabelDeleteArgs>(args: SelectSubset<T, LabelDeleteArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Label.
     * @param {LabelUpdateArgs} args - Arguments to update one Label.
     * @example
     * // Update one Label
     * const label = await prisma.label.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabelUpdateArgs>(args: SelectSubset<T, LabelUpdateArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Labels.
     * @param {LabelDeleteManyArgs} args - Arguments to filter Labels to delete.
     * @example
     * // Delete a few Labels
     * const { count } = await prisma.label.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabelDeleteManyArgs>(args?: SelectSubset<T, LabelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabelUpdateManyArgs>(args: SelectSubset<T, LabelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Label.
     * @param {LabelUpsertArgs} args - Arguments to update or create a Label.
     * @example
     * // Update or create a Label
     * const label = await prisma.label.upsert({
     *   create: {
     *     // ... data to create a Label
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Label we want to update
     *   }
     * })
     */
    upsert<T extends LabelUpsertArgs>(args: SelectSubset<T, LabelUpsertArgs<ExtArgs>>): Prisma__LabelClient<$Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCountArgs} args - Arguments to filter Labels to count.
     * @example
     * // Count the number of Labels
     * const count = await prisma.label.count({
     *   where: {
     *     // ... the filter for the Labels we want to count
     *   }
     * })
    **/
    count<T extends LabelCountArgs>(
      args?: Subset<T, LabelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelAggregateArgs>(args: Subset<T, LabelAggregateArgs>): Prisma.PrismaPromise<GetLabelAggregateType<T>>

    /**
     * Group by Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelGroupByArgs['orderBy'] }
        : { orderBy?: LabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Label model
   */
  readonly fields: LabelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Label.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Label model
   */ 
  interface LabelFieldRefs {
    readonly id: FieldRef<"Label", 'String'>
    readonly labelId: FieldRef<"Label", 'String'>
    readonly name: FieldRef<"Label", 'String'>
    readonly color: FieldRef<"Label", 'String'>
    readonly predefinedId: FieldRef<"Label", 'String'>
    readonly createdAt: FieldRef<"Label", 'DateTime'>
    readonly updatedAt: FieldRef<"Label", 'DateTime'>
    readonly instanceId: FieldRef<"Label", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Label findUnique
   */
  export type LabelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findUniqueOrThrow
   */
  export type LabelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label findFirst
   */
  export type LabelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findFirstOrThrow
   */
  export type LabelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Label to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     */
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label findMany
   */
  export type LabelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter, which Labels to fetch.
     */
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     */
    orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labels.
     */
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     */
    skip?: number
    distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[]
  }

  /**
   * Label create
   */
  export type LabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to create a Label.
     */
    data: XOR<LabelCreateInput, LabelUncheckedCreateInput>
  }

  /**
   * Label createMany
   */
  export type LabelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labels.
     */
    data: LabelCreateManyInput | LabelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Label update
   */
  export type LabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The data needed to update a Label.
     */
    data: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
    /**
     * Choose, which Label to update.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label updateMany
   */
  export type LabelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labels.
     */
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to update.
     */
    limit?: number
  }

  /**
   * Label upsert
   */
  export type LabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * The filter to search for the Label to update in case it exists.
     */
    where: LabelWhereUniqueInput
    /**
     * In case the Label found by the `where` argument doesn't exist, create a new Label with this data.
     */
    create: XOR<LabelCreateInput, LabelUncheckedCreateInput>
    /**
     * In case the Label was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
  }

  /**
   * Label delete
   */
  export type LabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
    /**
     * Filter which Label to delete.
     */
    where: LabelWhereUniqueInput
  }

  /**
   * Label deleteMany
   */
  export type LabelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labels to delete
     */
    where?: LabelWhereInput
    /**
     * Limit how many Labels to delete.
     */
    limit?: number
  }

  /**
   * Label without action
   */
  export type LabelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Label
     */
    select?: LabelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Label
     */
    omit?: LabelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabelInclude<ExtArgs> | null
  }


  /**
   * Model Proxy
   */

  export type AggregateProxy = {
    _count: ProxyCountAggregateOutputType | null
    _min: ProxyMinAggregateOutputType | null
    _max: ProxyMaxAggregateOutputType | null
  }

  export type ProxyMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    host: string | null
    port: string | null
    protocol: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type ProxyMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    host: string | null
    port: string | null
    protocol: string | null
    username: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type ProxyCountAggregateOutputType = {
    id: number
    enabled: number
    host: number
    port: number
    protocol: number
    username: number
    password: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type ProxyMinAggregateInputType = {
    id?: true
    enabled?: true
    host?: true
    port?: true
    protocol?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type ProxyMaxAggregateInputType = {
    id?: true
    enabled?: true
    host?: true
    port?: true
    protocol?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type ProxyCountAggregateInputType = {
    id?: true
    enabled?: true
    host?: true
    port?: true
    protocol?: true
    username?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type ProxyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proxy to aggregate.
     */
    where?: ProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxies to fetch.
     */
    orderBy?: ProxyOrderByWithRelationInput | ProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proxies
    **/
    _count?: true | ProxyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxyMaxAggregateInputType
  }

  export type GetProxyAggregateType<T extends ProxyAggregateArgs> = {
        [P in keyof T & keyof AggregateProxy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxy[P]>
      : GetScalarType<T[P], AggregateProxy[P]>
  }




  export type ProxyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyWhereInput
    orderBy?: ProxyOrderByWithAggregationInput | ProxyOrderByWithAggregationInput[]
    by: ProxyScalarFieldEnum[] | ProxyScalarFieldEnum
    having?: ProxyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxyCountAggregateInputType | true
    _min?: ProxyMinAggregateInputType
    _max?: ProxyMaxAggregateInputType
  }

  export type ProxyGroupByOutputType = {
    id: string
    enabled: boolean
    host: string
    port: string
    protocol: string
    username: string
    password: string
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: ProxyCountAggregateOutputType | null
    _min: ProxyMinAggregateOutputType | null
    _max: ProxyMaxAggregateOutputType | null
  }

  type GetProxyGroupByPayload<T extends ProxyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxyGroupByOutputType[P]>
            : GetScalarType<T[P], ProxyGroupByOutputType[P]>
        }
      >
    >


  export type ProxySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    host?: boolean
    port?: boolean
    protocol?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxy"]>



  export type ProxySelectScalar = {
    id?: boolean
    enabled?: boolean
    host?: boolean
    port?: boolean
    protocol?: boolean
    username?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type ProxyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "host" | "port" | "protocol" | "username" | "password" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["proxy"]>
  export type ProxyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $ProxyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proxy"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      host: string
      port: string
      protocol: string
      username: string
      password: string
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["proxy"]>
    composites: {}
  }

  type ProxyGetPayload<S extends boolean | null | undefined | ProxyDefaultArgs> = $Result.GetResult<Prisma.$ProxyPayload, S>

  type ProxyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxyCountAggregateInputType | true
    }

  export interface ProxyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proxy'], meta: { name: 'Proxy' } }
    /**
     * Find zero or one Proxy that matches the filter.
     * @param {ProxyFindUniqueArgs} args - Arguments to find a Proxy
     * @example
     * // Get one Proxy
     * const proxy = await prisma.proxy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxyFindUniqueArgs>(args: SelectSubset<T, ProxyFindUniqueArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Proxy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxyFindUniqueOrThrowArgs} args - Arguments to find a Proxy
     * @example
     * // Get one Proxy
     * const proxy = await prisma.proxy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxyFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Proxy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyFindFirstArgs} args - Arguments to find a Proxy
     * @example
     * // Get one Proxy
     * const proxy = await prisma.proxy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxyFindFirstArgs>(args?: SelectSubset<T, ProxyFindFirstArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Proxy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyFindFirstOrThrowArgs} args - Arguments to find a Proxy
     * @example
     * // Get one Proxy
     * const proxy = await prisma.proxy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxyFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Proxies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proxies
     * const proxies = await prisma.proxy.findMany()
     * 
     * // Get first 10 Proxies
     * const proxies = await prisma.proxy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxyWithIdOnly = await prisma.proxy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxyFindManyArgs>(args?: SelectSubset<T, ProxyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Proxy.
     * @param {ProxyCreateArgs} args - Arguments to create a Proxy.
     * @example
     * // Create one Proxy
     * const Proxy = await prisma.proxy.create({
     *   data: {
     *     // ... data to create a Proxy
     *   }
     * })
     * 
     */
    create<T extends ProxyCreateArgs>(args: SelectSubset<T, ProxyCreateArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Proxies.
     * @param {ProxyCreateManyArgs} args - Arguments to create many Proxies.
     * @example
     * // Create many Proxies
     * const proxy = await prisma.proxy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxyCreateManyArgs>(args?: SelectSubset<T, ProxyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proxy.
     * @param {ProxyDeleteArgs} args - Arguments to delete one Proxy.
     * @example
     * // Delete one Proxy
     * const Proxy = await prisma.proxy.delete({
     *   where: {
     *     // ... filter to delete one Proxy
     *   }
     * })
     * 
     */
    delete<T extends ProxyDeleteArgs>(args: SelectSubset<T, ProxyDeleteArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Proxy.
     * @param {ProxyUpdateArgs} args - Arguments to update one Proxy.
     * @example
     * // Update one Proxy
     * const proxy = await prisma.proxy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxyUpdateArgs>(args: SelectSubset<T, ProxyUpdateArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Proxies.
     * @param {ProxyDeleteManyArgs} args - Arguments to filter Proxies to delete.
     * @example
     * // Delete a few Proxies
     * const { count } = await prisma.proxy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxyDeleteManyArgs>(args?: SelectSubset<T, ProxyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proxies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proxies
     * const proxy = await prisma.proxy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxyUpdateManyArgs>(args: SelectSubset<T, ProxyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proxy.
     * @param {ProxyUpsertArgs} args - Arguments to update or create a Proxy.
     * @example
     * // Update or create a Proxy
     * const proxy = await prisma.proxy.upsert({
     *   create: {
     *     // ... data to create a Proxy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proxy we want to update
     *   }
     * })
     */
    upsert<T extends ProxyUpsertArgs>(args: SelectSubset<T, ProxyUpsertArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Proxies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyCountArgs} args - Arguments to filter Proxies to count.
     * @example
     * // Count the number of Proxies
     * const count = await prisma.proxy.count({
     *   where: {
     *     // ... the filter for the Proxies we want to count
     *   }
     * })
    **/
    count<T extends ProxyCountArgs>(
      args?: Subset<T, ProxyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proxy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxyAggregateArgs>(args: Subset<T, ProxyAggregateArgs>): Prisma.PrismaPromise<GetProxyAggregateType<T>>

    /**
     * Group by Proxy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxyGroupByArgs['orderBy'] }
        : { orderBy?: ProxyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proxy model
   */
  readonly fields: ProxyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proxy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proxy model
   */ 
  interface ProxyFieldRefs {
    readonly id: FieldRef<"Proxy", 'String'>
    readonly enabled: FieldRef<"Proxy", 'Boolean'>
    readonly host: FieldRef<"Proxy", 'String'>
    readonly port: FieldRef<"Proxy", 'String'>
    readonly protocol: FieldRef<"Proxy", 'String'>
    readonly username: FieldRef<"Proxy", 'String'>
    readonly password: FieldRef<"Proxy", 'String'>
    readonly createdAt: FieldRef<"Proxy", 'DateTime'>
    readonly updatedAt: FieldRef<"Proxy", 'DateTime'>
    readonly instanceId: FieldRef<"Proxy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Proxy findUnique
   */
  export type ProxyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxy to fetch.
     */
    where: ProxyWhereUniqueInput
  }

  /**
   * Proxy findUniqueOrThrow
   */
  export type ProxyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxy to fetch.
     */
    where: ProxyWhereUniqueInput
  }

  /**
   * Proxy findFirst
   */
  export type ProxyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxy to fetch.
     */
    where?: ProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxies to fetch.
     */
    orderBy?: ProxyOrderByWithRelationInput | ProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proxies.
     */
    cursor?: ProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proxies.
     */
    distinct?: ProxyScalarFieldEnum | ProxyScalarFieldEnum[]
  }

  /**
   * Proxy findFirstOrThrow
   */
  export type ProxyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxy to fetch.
     */
    where?: ProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxies to fetch.
     */
    orderBy?: ProxyOrderByWithRelationInput | ProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proxies.
     */
    cursor?: ProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proxies.
     */
    distinct?: ProxyScalarFieldEnum | ProxyScalarFieldEnum[]
  }

  /**
   * Proxy findMany
   */
  export type ProxyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxies to fetch.
     */
    where?: ProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxies to fetch.
     */
    orderBy?: ProxyOrderByWithRelationInput | ProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proxies.
     */
    cursor?: ProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxies.
     */
    skip?: number
    distinct?: ProxyScalarFieldEnum | ProxyScalarFieldEnum[]
  }

  /**
   * Proxy create
   */
  export type ProxyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * The data needed to create a Proxy.
     */
    data: XOR<ProxyCreateInput, ProxyUncheckedCreateInput>
  }

  /**
   * Proxy createMany
   */
  export type ProxyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proxies.
     */
    data: ProxyCreateManyInput | ProxyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proxy update
   */
  export type ProxyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * The data needed to update a Proxy.
     */
    data: XOR<ProxyUpdateInput, ProxyUncheckedUpdateInput>
    /**
     * Choose, which Proxy to update.
     */
    where: ProxyWhereUniqueInput
  }

  /**
   * Proxy updateMany
   */
  export type ProxyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proxies.
     */
    data: XOR<ProxyUpdateManyMutationInput, ProxyUncheckedUpdateManyInput>
    /**
     * Filter which Proxies to update
     */
    where?: ProxyWhereInput
    /**
     * Limit how many Proxies to update.
     */
    limit?: number
  }

  /**
   * Proxy upsert
   */
  export type ProxyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * The filter to search for the Proxy to update in case it exists.
     */
    where: ProxyWhereUniqueInput
    /**
     * In case the Proxy found by the `where` argument doesn't exist, create a new Proxy with this data.
     */
    create: XOR<ProxyCreateInput, ProxyUncheckedCreateInput>
    /**
     * In case the Proxy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxyUpdateInput, ProxyUncheckedUpdateInput>
  }

  /**
   * Proxy delete
   */
  export type ProxyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter which Proxy to delete.
     */
    where: ProxyWhereUniqueInput
  }

  /**
   * Proxy deleteMany
   */
  export type ProxyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proxies to delete
     */
    where?: ProxyWhereInput
    /**
     * Limit how many Proxies to delete.
     */
    limit?: number
  }

  /**
   * Proxy without action
   */
  export type ProxyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    rejectCall: boolean | null
    msgCall: string | null
    groupsIgnore: boolean | null
    alwaysOnline: boolean | null
    readMessages: boolean | null
    readStatus: boolean | null
    syncFullHistory: boolean | null
    wavoipToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    rejectCall: boolean | null
    msgCall: string | null
    groupsIgnore: boolean | null
    alwaysOnline: boolean | null
    readMessages: boolean | null
    readStatus: boolean | null
    syncFullHistory: boolean | null
    wavoipToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    rejectCall: number
    msgCall: number
    groupsIgnore: number
    alwaysOnline: number
    readMessages: number
    readStatus: number
    syncFullHistory: number
    wavoipToken: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    rejectCall?: true
    msgCall?: true
    groupsIgnore?: true
    alwaysOnline?: true
    readMessages?: true
    readStatus?: true
    syncFullHistory?: true
    wavoipToken?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    rejectCall?: true
    msgCall?: true
    groupsIgnore?: true
    alwaysOnline?: true
    readMessages?: true
    readStatus?: true
    syncFullHistory?: true
    wavoipToken?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    rejectCall?: true
    msgCall?: true
    groupsIgnore?: true
    alwaysOnline?: true
    readMessages?: true
    readStatus?: true
    syncFullHistory?: true
    wavoipToken?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    rejectCall: boolean
    msgCall: string | null
    groupsIgnore: boolean
    alwaysOnline: boolean
    readMessages: boolean
    readStatus: boolean
    syncFullHistory: boolean
    wavoipToken: string | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rejectCall?: boolean
    msgCall?: boolean
    groupsIgnore?: boolean
    alwaysOnline?: boolean
    readMessages?: boolean
    readStatus?: boolean
    syncFullHistory?: boolean
    wavoipToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["setting"]>



  export type SettingSelectScalar = {
    id?: boolean
    rejectCall?: boolean
    msgCall?: boolean
    groupsIgnore?: boolean
    alwaysOnline?: boolean
    readMessages?: boolean
    readStatus?: boolean
    syncFullHistory?: boolean
    wavoipToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rejectCall" | "msgCall" | "groupsIgnore" | "alwaysOnline" | "readMessages" | "readStatus" | "syncFullHistory" | "wavoipToken" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["setting"]>
  export type SettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rejectCall: boolean
      msgCall: string | null
      groupsIgnore: boolean
      alwaysOnline: boolean
      readMessages: boolean
      readStatus: boolean
      syncFullHistory: boolean
      wavoipToken: string | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */ 
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly rejectCall: FieldRef<"Setting", 'Boolean'>
    readonly msgCall: FieldRef<"Setting", 'String'>
    readonly groupsIgnore: FieldRef<"Setting", 'Boolean'>
    readonly alwaysOnline: FieldRef<"Setting", 'Boolean'>
    readonly readMessages: FieldRef<"Setting", 'Boolean'>
    readonly readStatus: FieldRef<"Setting", 'Boolean'>
    readonly syncFullHistory: FieldRef<"Setting", 'Boolean'>
    readonly wavoipToken: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
    readonly instanceId: FieldRef<"Setting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingInclude<ExtArgs> | null
  }


  /**
   * Model Rabbitmq
   */

  export type AggregateRabbitmq = {
    _count: RabbitmqCountAggregateOutputType | null
    _min: RabbitmqMinAggregateOutputType | null
    _max: RabbitmqMaxAggregateOutputType | null
  }

  export type RabbitmqMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type RabbitmqMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type RabbitmqCountAggregateOutputType = {
    id: number
    enabled: number
    events: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type RabbitmqMinAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type RabbitmqMaxAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type RabbitmqCountAggregateInputType = {
    id?: true
    enabled?: true
    events?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type RabbitmqAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rabbitmq to aggregate.
     */
    where?: RabbitmqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rabbitmqs to fetch.
     */
    orderBy?: RabbitmqOrderByWithRelationInput | RabbitmqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RabbitmqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rabbitmqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rabbitmqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rabbitmqs
    **/
    _count?: true | RabbitmqCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RabbitmqMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RabbitmqMaxAggregateInputType
  }

  export type GetRabbitmqAggregateType<T extends RabbitmqAggregateArgs> = {
        [P in keyof T & keyof AggregateRabbitmq]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRabbitmq[P]>
      : GetScalarType<T[P], AggregateRabbitmq[P]>
  }




  export type RabbitmqGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RabbitmqWhereInput
    orderBy?: RabbitmqOrderByWithAggregationInput | RabbitmqOrderByWithAggregationInput[]
    by: RabbitmqScalarFieldEnum[] | RabbitmqScalarFieldEnum
    having?: RabbitmqScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RabbitmqCountAggregateInputType | true
    _min?: RabbitmqMinAggregateInputType
    _max?: RabbitmqMaxAggregateInputType
  }

  export type RabbitmqGroupByOutputType = {
    id: string
    enabled: boolean
    events: JsonValue
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: RabbitmqCountAggregateOutputType | null
    _min: RabbitmqMinAggregateOutputType | null
    _max: RabbitmqMaxAggregateOutputType | null
  }

  type GetRabbitmqGroupByPayload<T extends RabbitmqGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RabbitmqGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RabbitmqGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RabbitmqGroupByOutputType[P]>
            : GetScalarType<T[P], RabbitmqGroupByOutputType[P]>
        }
      >
    >


  export type RabbitmqSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rabbitmq"]>



  export type RabbitmqSelectScalar = {
    id?: boolean
    enabled?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type RabbitmqOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "events" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["rabbitmq"]>
  export type RabbitmqInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $RabbitmqPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rabbitmq"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      events: Prisma.JsonValue
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["rabbitmq"]>
    composites: {}
  }

  type RabbitmqGetPayload<S extends boolean | null | undefined | RabbitmqDefaultArgs> = $Result.GetResult<Prisma.$RabbitmqPayload, S>

  type RabbitmqCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RabbitmqFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RabbitmqCountAggregateInputType | true
    }

  export interface RabbitmqDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rabbitmq'], meta: { name: 'Rabbitmq' } }
    /**
     * Find zero or one Rabbitmq that matches the filter.
     * @param {RabbitmqFindUniqueArgs} args - Arguments to find a Rabbitmq
     * @example
     * // Get one Rabbitmq
     * const rabbitmq = await prisma.rabbitmq.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RabbitmqFindUniqueArgs>(args: SelectSubset<T, RabbitmqFindUniqueArgs<ExtArgs>>): Prisma__RabbitmqClient<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Rabbitmq that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RabbitmqFindUniqueOrThrowArgs} args - Arguments to find a Rabbitmq
     * @example
     * // Get one Rabbitmq
     * const rabbitmq = await prisma.rabbitmq.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RabbitmqFindUniqueOrThrowArgs>(args: SelectSubset<T, RabbitmqFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RabbitmqClient<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Rabbitmq that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RabbitmqFindFirstArgs} args - Arguments to find a Rabbitmq
     * @example
     * // Get one Rabbitmq
     * const rabbitmq = await prisma.rabbitmq.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RabbitmqFindFirstArgs>(args?: SelectSubset<T, RabbitmqFindFirstArgs<ExtArgs>>): Prisma__RabbitmqClient<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Rabbitmq that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RabbitmqFindFirstOrThrowArgs} args - Arguments to find a Rabbitmq
     * @example
     * // Get one Rabbitmq
     * const rabbitmq = await prisma.rabbitmq.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RabbitmqFindFirstOrThrowArgs>(args?: SelectSubset<T, RabbitmqFindFirstOrThrowArgs<ExtArgs>>): Prisma__RabbitmqClient<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Rabbitmqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RabbitmqFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rabbitmqs
     * const rabbitmqs = await prisma.rabbitmq.findMany()
     * 
     * // Get first 10 Rabbitmqs
     * const rabbitmqs = await prisma.rabbitmq.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rabbitmqWithIdOnly = await prisma.rabbitmq.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RabbitmqFindManyArgs>(args?: SelectSubset<T, RabbitmqFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Rabbitmq.
     * @param {RabbitmqCreateArgs} args - Arguments to create a Rabbitmq.
     * @example
     * // Create one Rabbitmq
     * const Rabbitmq = await prisma.rabbitmq.create({
     *   data: {
     *     // ... data to create a Rabbitmq
     *   }
     * })
     * 
     */
    create<T extends RabbitmqCreateArgs>(args: SelectSubset<T, RabbitmqCreateArgs<ExtArgs>>): Prisma__RabbitmqClient<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Rabbitmqs.
     * @param {RabbitmqCreateManyArgs} args - Arguments to create many Rabbitmqs.
     * @example
     * // Create many Rabbitmqs
     * const rabbitmq = await prisma.rabbitmq.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RabbitmqCreateManyArgs>(args?: SelectSubset<T, RabbitmqCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rabbitmq.
     * @param {RabbitmqDeleteArgs} args - Arguments to delete one Rabbitmq.
     * @example
     * // Delete one Rabbitmq
     * const Rabbitmq = await prisma.rabbitmq.delete({
     *   where: {
     *     // ... filter to delete one Rabbitmq
     *   }
     * })
     * 
     */
    delete<T extends RabbitmqDeleteArgs>(args: SelectSubset<T, RabbitmqDeleteArgs<ExtArgs>>): Prisma__RabbitmqClient<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Rabbitmq.
     * @param {RabbitmqUpdateArgs} args - Arguments to update one Rabbitmq.
     * @example
     * // Update one Rabbitmq
     * const rabbitmq = await prisma.rabbitmq.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RabbitmqUpdateArgs>(args: SelectSubset<T, RabbitmqUpdateArgs<ExtArgs>>): Prisma__RabbitmqClient<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Rabbitmqs.
     * @param {RabbitmqDeleteManyArgs} args - Arguments to filter Rabbitmqs to delete.
     * @example
     * // Delete a few Rabbitmqs
     * const { count } = await prisma.rabbitmq.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RabbitmqDeleteManyArgs>(args?: SelectSubset<T, RabbitmqDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rabbitmqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RabbitmqUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rabbitmqs
     * const rabbitmq = await prisma.rabbitmq.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RabbitmqUpdateManyArgs>(args: SelectSubset<T, RabbitmqUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rabbitmq.
     * @param {RabbitmqUpsertArgs} args - Arguments to update or create a Rabbitmq.
     * @example
     * // Update or create a Rabbitmq
     * const rabbitmq = await prisma.rabbitmq.upsert({
     *   create: {
     *     // ... data to create a Rabbitmq
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rabbitmq we want to update
     *   }
     * })
     */
    upsert<T extends RabbitmqUpsertArgs>(args: SelectSubset<T, RabbitmqUpsertArgs<ExtArgs>>): Prisma__RabbitmqClient<$Result.GetResult<Prisma.$RabbitmqPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Rabbitmqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RabbitmqCountArgs} args - Arguments to filter Rabbitmqs to count.
     * @example
     * // Count the number of Rabbitmqs
     * const count = await prisma.rabbitmq.count({
     *   where: {
     *     // ... the filter for the Rabbitmqs we want to count
     *   }
     * })
    **/
    count<T extends RabbitmqCountArgs>(
      args?: Subset<T, RabbitmqCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RabbitmqCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rabbitmq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RabbitmqAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RabbitmqAggregateArgs>(args: Subset<T, RabbitmqAggregateArgs>): Prisma.PrismaPromise<GetRabbitmqAggregateType<T>>

    /**
     * Group by Rabbitmq.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RabbitmqGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RabbitmqGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RabbitmqGroupByArgs['orderBy'] }
        : { orderBy?: RabbitmqGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RabbitmqGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRabbitmqGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rabbitmq model
   */
  readonly fields: RabbitmqFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rabbitmq.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RabbitmqClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rabbitmq model
   */ 
  interface RabbitmqFieldRefs {
    readonly id: FieldRef<"Rabbitmq", 'String'>
    readonly enabled: FieldRef<"Rabbitmq", 'Boolean'>
    readonly events: FieldRef<"Rabbitmq", 'Json'>
    readonly createdAt: FieldRef<"Rabbitmq", 'DateTime'>
    readonly updatedAt: FieldRef<"Rabbitmq", 'DateTime'>
    readonly instanceId: FieldRef<"Rabbitmq", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Rabbitmq findUnique
   */
  export type RabbitmqFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    /**
     * Filter, which Rabbitmq to fetch.
     */
    where: RabbitmqWhereUniqueInput
  }

  /**
   * Rabbitmq findUniqueOrThrow
   */
  export type RabbitmqFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    /**
     * Filter, which Rabbitmq to fetch.
     */
    where: RabbitmqWhereUniqueInput
  }

  /**
   * Rabbitmq findFirst
   */
  export type RabbitmqFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    /**
     * Filter, which Rabbitmq to fetch.
     */
    where?: RabbitmqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rabbitmqs to fetch.
     */
    orderBy?: RabbitmqOrderByWithRelationInput | RabbitmqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rabbitmqs.
     */
    cursor?: RabbitmqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rabbitmqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rabbitmqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rabbitmqs.
     */
    distinct?: RabbitmqScalarFieldEnum | RabbitmqScalarFieldEnum[]
  }

  /**
   * Rabbitmq findFirstOrThrow
   */
  export type RabbitmqFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    /**
     * Filter, which Rabbitmq to fetch.
     */
    where?: RabbitmqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rabbitmqs to fetch.
     */
    orderBy?: RabbitmqOrderByWithRelationInput | RabbitmqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rabbitmqs.
     */
    cursor?: RabbitmqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rabbitmqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rabbitmqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rabbitmqs.
     */
    distinct?: RabbitmqScalarFieldEnum | RabbitmqScalarFieldEnum[]
  }

  /**
   * Rabbitmq findMany
   */
  export type RabbitmqFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    /**
     * Filter, which Rabbitmqs to fetch.
     */
    where?: RabbitmqWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rabbitmqs to fetch.
     */
    orderBy?: RabbitmqOrderByWithRelationInput | RabbitmqOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rabbitmqs.
     */
    cursor?: RabbitmqWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rabbitmqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rabbitmqs.
     */
    skip?: number
    distinct?: RabbitmqScalarFieldEnum | RabbitmqScalarFieldEnum[]
  }

  /**
   * Rabbitmq create
   */
  export type RabbitmqCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    /**
     * The data needed to create a Rabbitmq.
     */
    data: XOR<RabbitmqCreateInput, RabbitmqUncheckedCreateInput>
  }

  /**
   * Rabbitmq createMany
   */
  export type RabbitmqCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rabbitmqs.
     */
    data: RabbitmqCreateManyInput | RabbitmqCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rabbitmq update
   */
  export type RabbitmqUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    /**
     * The data needed to update a Rabbitmq.
     */
    data: XOR<RabbitmqUpdateInput, RabbitmqUncheckedUpdateInput>
    /**
     * Choose, which Rabbitmq to update.
     */
    where: RabbitmqWhereUniqueInput
  }

  /**
   * Rabbitmq updateMany
   */
  export type RabbitmqUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rabbitmqs.
     */
    data: XOR<RabbitmqUpdateManyMutationInput, RabbitmqUncheckedUpdateManyInput>
    /**
     * Filter which Rabbitmqs to update
     */
    where?: RabbitmqWhereInput
    /**
     * Limit how many Rabbitmqs to update.
     */
    limit?: number
  }

  /**
   * Rabbitmq upsert
   */
  export type RabbitmqUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    /**
     * The filter to search for the Rabbitmq to update in case it exists.
     */
    where: RabbitmqWhereUniqueInput
    /**
     * In case the Rabbitmq found by the `where` argument doesn't exist, create a new Rabbitmq with this data.
     */
    create: XOR<RabbitmqCreateInput, RabbitmqUncheckedCreateInput>
    /**
     * In case the Rabbitmq was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RabbitmqUpdateInput, RabbitmqUncheckedUpdateInput>
  }

  /**
   * Rabbitmq delete
   */
  export type RabbitmqDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
    /**
     * Filter which Rabbitmq to delete.
     */
    where: RabbitmqWhereUniqueInput
  }

  /**
   * Rabbitmq deleteMany
   */
  export type RabbitmqDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rabbitmqs to delete
     */
    where?: RabbitmqWhereInput
    /**
     * Limit how many Rabbitmqs to delete.
     */
    limit?: number
  }

  /**
   * Rabbitmq without action
   */
  export type RabbitmqDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rabbitmq
     */
    select?: RabbitmqSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Rabbitmq
     */
    omit?: RabbitmqOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RabbitmqInclude<ExtArgs> | null
  }


  /**
   * Model Sqs
   */

  export type AggregateSqs = {
    _count: SqsCountAggregateOutputType | null
    _min: SqsMinAggregateOutputType | null
    _max: SqsMaxAggregateOutputType | null
  }

  export type SqsMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type SqsMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type SqsCountAggregateOutputType = {
    id: number
    enabled: number
    events: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type SqsMinAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type SqsMaxAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type SqsCountAggregateInputType = {
    id?: true
    enabled?: true
    events?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type SqsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sqs to aggregate.
     */
    where?: SqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sqs to fetch.
     */
    orderBy?: SqsOrderByWithRelationInput | SqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sqs
    **/
    _count?: true | SqsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SqsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SqsMaxAggregateInputType
  }

  export type GetSqsAggregateType<T extends SqsAggregateArgs> = {
        [P in keyof T & keyof AggregateSqs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSqs[P]>
      : GetScalarType<T[P], AggregateSqs[P]>
  }




  export type SqsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SqsWhereInput
    orderBy?: SqsOrderByWithAggregationInput | SqsOrderByWithAggregationInput[]
    by: SqsScalarFieldEnum[] | SqsScalarFieldEnum
    having?: SqsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SqsCountAggregateInputType | true
    _min?: SqsMinAggregateInputType
    _max?: SqsMaxAggregateInputType
  }

  export type SqsGroupByOutputType = {
    id: string
    enabled: boolean
    events: JsonValue
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: SqsCountAggregateOutputType | null
    _min: SqsMinAggregateOutputType | null
    _max: SqsMaxAggregateOutputType | null
  }

  type GetSqsGroupByPayload<T extends SqsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SqsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SqsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SqsGroupByOutputType[P]>
            : GetScalarType<T[P], SqsGroupByOutputType[P]>
        }
      >
    >


  export type SqsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sqs"]>



  export type SqsSelectScalar = {
    id?: boolean
    enabled?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type SqsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "events" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["sqs"]>
  export type SqsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $SqsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sqs"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      events: Prisma.JsonValue
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["sqs"]>
    composites: {}
  }

  type SqsGetPayload<S extends boolean | null | undefined | SqsDefaultArgs> = $Result.GetResult<Prisma.$SqsPayload, S>

  type SqsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SqsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SqsCountAggregateInputType | true
    }

  export interface SqsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sqs'], meta: { name: 'Sqs' } }
    /**
     * Find zero or one Sqs that matches the filter.
     * @param {SqsFindUniqueArgs} args - Arguments to find a Sqs
     * @example
     * // Get one Sqs
     * const sqs = await prisma.sqs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SqsFindUniqueArgs>(args: SelectSubset<T, SqsFindUniqueArgs<ExtArgs>>): Prisma__SqsClient<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Sqs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SqsFindUniqueOrThrowArgs} args - Arguments to find a Sqs
     * @example
     * // Get one Sqs
     * const sqs = await prisma.sqs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SqsFindUniqueOrThrowArgs>(args: SelectSubset<T, SqsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SqsClient<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Sqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SqsFindFirstArgs} args - Arguments to find a Sqs
     * @example
     * // Get one Sqs
     * const sqs = await prisma.sqs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SqsFindFirstArgs>(args?: SelectSubset<T, SqsFindFirstArgs<ExtArgs>>): Prisma__SqsClient<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Sqs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SqsFindFirstOrThrowArgs} args - Arguments to find a Sqs
     * @example
     * // Get one Sqs
     * const sqs = await prisma.sqs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SqsFindFirstOrThrowArgs>(args?: SelectSubset<T, SqsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SqsClient<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SqsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sqs
     * const sqs = await prisma.sqs.findMany()
     * 
     * // Get first 10 Sqs
     * const sqs = await prisma.sqs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sqsWithIdOnly = await prisma.sqs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SqsFindManyArgs>(args?: SelectSubset<T, SqsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Sqs.
     * @param {SqsCreateArgs} args - Arguments to create a Sqs.
     * @example
     * // Create one Sqs
     * const Sqs = await prisma.sqs.create({
     *   data: {
     *     // ... data to create a Sqs
     *   }
     * })
     * 
     */
    create<T extends SqsCreateArgs>(args: SelectSubset<T, SqsCreateArgs<ExtArgs>>): Prisma__SqsClient<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sqs.
     * @param {SqsCreateManyArgs} args - Arguments to create many Sqs.
     * @example
     * // Create many Sqs
     * const sqs = await prisma.sqs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SqsCreateManyArgs>(args?: SelectSubset<T, SqsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sqs.
     * @param {SqsDeleteArgs} args - Arguments to delete one Sqs.
     * @example
     * // Delete one Sqs
     * const Sqs = await prisma.sqs.delete({
     *   where: {
     *     // ... filter to delete one Sqs
     *   }
     * })
     * 
     */
    delete<T extends SqsDeleteArgs>(args: SelectSubset<T, SqsDeleteArgs<ExtArgs>>): Prisma__SqsClient<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Sqs.
     * @param {SqsUpdateArgs} args - Arguments to update one Sqs.
     * @example
     * // Update one Sqs
     * const sqs = await prisma.sqs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SqsUpdateArgs>(args: SelectSubset<T, SqsUpdateArgs<ExtArgs>>): Prisma__SqsClient<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sqs.
     * @param {SqsDeleteManyArgs} args - Arguments to filter Sqs to delete.
     * @example
     * // Delete a few Sqs
     * const { count } = await prisma.sqs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SqsDeleteManyArgs>(args?: SelectSubset<T, SqsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SqsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sqs
     * const sqs = await prisma.sqs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SqsUpdateManyArgs>(args: SelectSubset<T, SqsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sqs.
     * @param {SqsUpsertArgs} args - Arguments to update or create a Sqs.
     * @example
     * // Update or create a Sqs
     * const sqs = await prisma.sqs.upsert({
     *   create: {
     *     // ... data to create a Sqs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sqs we want to update
     *   }
     * })
     */
    upsert<T extends SqsUpsertArgs>(args: SelectSubset<T, SqsUpsertArgs<ExtArgs>>): Prisma__SqsClient<$Result.GetResult<Prisma.$SqsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SqsCountArgs} args - Arguments to filter Sqs to count.
     * @example
     * // Count the number of Sqs
     * const count = await prisma.sqs.count({
     *   where: {
     *     // ... the filter for the Sqs we want to count
     *   }
     * })
    **/
    count<T extends SqsCountArgs>(
      args?: Subset<T, SqsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SqsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SqsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SqsAggregateArgs>(args: Subset<T, SqsAggregateArgs>): Prisma.PrismaPromise<GetSqsAggregateType<T>>

    /**
     * Group by Sqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SqsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SqsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SqsGroupByArgs['orderBy'] }
        : { orderBy?: SqsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SqsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSqsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sqs model
   */
  readonly fields: SqsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sqs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SqsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sqs model
   */ 
  interface SqsFieldRefs {
    readonly id: FieldRef<"Sqs", 'String'>
    readonly enabled: FieldRef<"Sqs", 'Boolean'>
    readonly events: FieldRef<"Sqs", 'Json'>
    readonly createdAt: FieldRef<"Sqs", 'DateTime'>
    readonly updatedAt: FieldRef<"Sqs", 'DateTime'>
    readonly instanceId: FieldRef<"Sqs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sqs findUnique
   */
  export type SqsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    /**
     * Filter, which Sqs to fetch.
     */
    where: SqsWhereUniqueInput
  }

  /**
   * Sqs findUniqueOrThrow
   */
  export type SqsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    /**
     * Filter, which Sqs to fetch.
     */
    where: SqsWhereUniqueInput
  }

  /**
   * Sqs findFirst
   */
  export type SqsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    /**
     * Filter, which Sqs to fetch.
     */
    where?: SqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sqs to fetch.
     */
    orderBy?: SqsOrderByWithRelationInput | SqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sqs.
     */
    cursor?: SqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sqs.
     */
    distinct?: SqsScalarFieldEnum | SqsScalarFieldEnum[]
  }

  /**
   * Sqs findFirstOrThrow
   */
  export type SqsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    /**
     * Filter, which Sqs to fetch.
     */
    where?: SqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sqs to fetch.
     */
    orderBy?: SqsOrderByWithRelationInput | SqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sqs.
     */
    cursor?: SqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sqs.
     */
    distinct?: SqsScalarFieldEnum | SqsScalarFieldEnum[]
  }

  /**
   * Sqs findMany
   */
  export type SqsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    /**
     * Filter, which Sqs to fetch.
     */
    where?: SqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sqs to fetch.
     */
    orderBy?: SqsOrderByWithRelationInput | SqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sqs.
     */
    cursor?: SqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sqs.
     */
    skip?: number
    distinct?: SqsScalarFieldEnum | SqsScalarFieldEnum[]
  }

  /**
   * Sqs create
   */
  export type SqsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    /**
     * The data needed to create a Sqs.
     */
    data: XOR<SqsCreateInput, SqsUncheckedCreateInput>
  }

  /**
   * Sqs createMany
   */
  export type SqsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sqs.
     */
    data: SqsCreateManyInput | SqsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sqs update
   */
  export type SqsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    /**
     * The data needed to update a Sqs.
     */
    data: XOR<SqsUpdateInput, SqsUncheckedUpdateInput>
    /**
     * Choose, which Sqs to update.
     */
    where: SqsWhereUniqueInput
  }

  /**
   * Sqs updateMany
   */
  export type SqsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sqs.
     */
    data: XOR<SqsUpdateManyMutationInput, SqsUncheckedUpdateManyInput>
    /**
     * Filter which Sqs to update
     */
    where?: SqsWhereInput
    /**
     * Limit how many Sqs to update.
     */
    limit?: number
  }

  /**
   * Sqs upsert
   */
  export type SqsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    /**
     * The filter to search for the Sqs to update in case it exists.
     */
    where: SqsWhereUniqueInput
    /**
     * In case the Sqs found by the `where` argument doesn't exist, create a new Sqs with this data.
     */
    create: XOR<SqsCreateInput, SqsUncheckedCreateInput>
    /**
     * In case the Sqs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SqsUpdateInput, SqsUncheckedUpdateInput>
  }

  /**
   * Sqs delete
   */
  export type SqsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
    /**
     * Filter which Sqs to delete.
     */
    where: SqsWhereUniqueInput
  }

  /**
   * Sqs deleteMany
   */
  export type SqsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sqs to delete
     */
    where?: SqsWhereInput
    /**
     * Limit how many Sqs to delete.
     */
    limit?: number
  }

  /**
   * Sqs without action
   */
  export type SqsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sqs
     */
    select?: SqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sqs
     */
    omit?: SqsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SqsInclude<ExtArgs> | null
  }


  /**
   * Model Websocket
   */

  export type AggregateWebsocket = {
    _count: WebsocketCountAggregateOutputType | null
    _min: WebsocketMinAggregateOutputType | null
    _max: WebsocketMaxAggregateOutputType | null
  }

  export type WebsocketMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type WebsocketMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type WebsocketCountAggregateOutputType = {
    id: number
    enabled: number
    events: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type WebsocketMinAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type WebsocketMaxAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type WebsocketCountAggregateInputType = {
    id?: true
    enabled?: true
    events?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type WebsocketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Websocket to aggregate.
     */
    where?: WebsocketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websockets to fetch.
     */
    orderBy?: WebsocketOrderByWithRelationInput | WebsocketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebsocketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websockets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websockets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Websockets
    **/
    _count?: true | WebsocketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebsocketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebsocketMaxAggregateInputType
  }

  export type GetWebsocketAggregateType<T extends WebsocketAggregateArgs> = {
        [P in keyof T & keyof AggregateWebsocket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebsocket[P]>
      : GetScalarType<T[P], AggregateWebsocket[P]>
  }




  export type WebsocketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebsocketWhereInput
    orderBy?: WebsocketOrderByWithAggregationInput | WebsocketOrderByWithAggregationInput[]
    by: WebsocketScalarFieldEnum[] | WebsocketScalarFieldEnum
    having?: WebsocketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebsocketCountAggregateInputType | true
    _min?: WebsocketMinAggregateInputType
    _max?: WebsocketMaxAggregateInputType
  }

  export type WebsocketGroupByOutputType = {
    id: string
    enabled: boolean
    events: JsonValue
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: WebsocketCountAggregateOutputType | null
    _min: WebsocketMinAggregateOutputType | null
    _max: WebsocketMaxAggregateOutputType | null
  }

  type GetWebsocketGroupByPayload<T extends WebsocketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebsocketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebsocketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebsocketGroupByOutputType[P]>
            : GetScalarType<T[P], WebsocketGroupByOutputType[P]>
        }
      >
    >


  export type WebsocketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["websocket"]>



  export type WebsocketSelectScalar = {
    id?: boolean
    enabled?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type WebsocketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "events" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["websocket"]>
  export type WebsocketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $WebsocketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Websocket"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      events: Prisma.JsonValue
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["websocket"]>
    composites: {}
  }

  type WebsocketGetPayload<S extends boolean | null | undefined | WebsocketDefaultArgs> = $Result.GetResult<Prisma.$WebsocketPayload, S>

  type WebsocketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebsocketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebsocketCountAggregateInputType | true
    }

  export interface WebsocketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Websocket'], meta: { name: 'Websocket' } }
    /**
     * Find zero or one Websocket that matches the filter.
     * @param {WebsocketFindUniqueArgs} args - Arguments to find a Websocket
     * @example
     * // Get one Websocket
     * const websocket = await prisma.websocket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebsocketFindUniqueArgs>(args: SelectSubset<T, WebsocketFindUniqueArgs<ExtArgs>>): Prisma__WebsocketClient<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Websocket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebsocketFindUniqueOrThrowArgs} args - Arguments to find a Websocket
     * @example
     * // Get one Websocket
     * const websocket = await prisma.websocket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebsocketFindUniqueOrThrowArgs>(args: SelectSubset<T, WebsocketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebsocketClient<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Websocket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsocketFindFirstArgs} args - Arguments to find a Websocket
     * @example
     * // Get one Websocket
     * const websocket = await prisma.websocket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebsocketFindFirstArgs>(args?: SelectSubset<T, WebsocketFindFirstArgs<ExtArgs>>): Prisma__WebsocketClient<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Websocket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsocketFindFirstOrThrowArgs} args - Arguments to find a Websocket
     * @example
     * // Get one Websocket
     * const websocket = await prisma.websocket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebsocketFindFirstOrThrowArgs>(args?: SelectSubset<T, WebsocketFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebsocketClient<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Websockets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsocketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Websockets
     * const websockets = await prisma.websocket.findMany()
     * 
     * // Get first 10 Websockets
     * const websockets = await prisma.websocket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const websocketWithIdOnly = await prisma.websocket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebsocketFindManyArgs>(args?: SelectSubset<T, WebsocketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Websocket.
     * @param {WebsocketCreateArgs} args - Arguments to create a Websocket.
     * @example
     * // Create one Websocket
     * const Websocket = await prisma.websocket.create({
     *   data: {
     *     // ... data to create a Websocket
     *   }
     * })
     * 
     */
    create<T extends WebsocketCreateArgs>(args: SelectSubset<T, WebsocketCreateArgs<ExtArgs>>): Prisma__WebsocketClient<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Websockets.
     * @param {WebsocketCreateManyArgs} args - Arguments to create many Websockets.
     * @example
     * // Create many Websockets
     * const websocket = await prisma.websocket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebsocketCreateManyArgs>(args?: SelectSubset<T, WebsocketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Websocket.
     * @param {WebsocketDeleteArgs} args - Arguments to delete one Websocket.
     * @example
     * // Delete one Websocket
     * const Websocket = await prisma.websocket.delete({
     *   where: {
     *     // ... filter to delete one Websocket
     *   }
     * })
     * 
     */
    delete<T extends WebsocketDeleteArgs>(args: SelectSubset<T, WebsocketDeleteArgs<ExtArgs>>): Prisma__WebsocketClient<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Websocket.
     * @param {WebsocketUpdateArgs} args - Arguments to update one Websocket.
     * @example
     * // Update one Websocket
     * const websocket = await prisma.websocket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebsocketUpdateArgs>(args: SelectSubset<T, WebsocketUpdateArgs<ExtArgs>>): Prisma__WebsocketClient<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Websockets.
     * @param {WebsocketDeleteManyArgs} args - Arguments to filter Websockets to delete.
     * @example
     * // Delete a few Websockets
     * const { count } = await prisma.websocket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebsocketDeleteManyArgs>(args?: SelectSubset<T, WebsocketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Websockets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsocketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Websockets
     * const websocket = await prisma.websocket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebsocketUpdateManyArgs>(args: SelectSubset<T, WebsocketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Websocket.
     * @param {WebsocketUpsertArgs} args - Arguments to update or create a Websocket.
     * @example
     * // Update or create a Websocket
     * const websocket = await prisma.websocket.upsert({
     *   create: {
     *     // ... data to create a Websocket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Websocket we want to update
     *   }
     * })
     */
    upsert<T extends WebsocketUpsertArgs>(args: SelectSubset<T, WebsocketUpsertArgs<ExtArgs>>): Prisma__WebsocketClient<$Result.GetResult<Prisma.$WebsocketPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Websockets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsocketCountArgs} args - Arguments to filter Websockets to count.
     * @example
     * // Count the number of Websockets
     * const count = await prisma.websocket.count({
     *   where: {
     *     // ... the filter for the Websockets we want to count
     *   }
     * })
    **/
    count<T extends WebsocketCountArgs>(
      args?: Subset<T, WebsocketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebsocketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Websocket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsocketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebsocketAggregateArgs>(args: Subset<T, WebsocketAggregateArgs>): Prisma.PrismaPromise<GetWebsocketAggregateType<T>>

    /**
     * Group by Websocket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebsocketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebsocketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebsocketGroupByArgs['orderBy'] }
        : { orderBy?: WebsocketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebsocketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebsocketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Websocket model
   */
  readonly fields: WebsocketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Websocket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebsocketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Websocket model
   */ 
  interface WebsocketFieldRefs {
    readonly id: FieldRef<"Websocket", 'String'>
    readonly enabled: FieldRef<"Websocket", 'Boolean'>
    readonly events: FieldRef<"Websocket", 'Json'>
    readonly createdAt: FieldRef<"Websocket", 'DateTime'>
    readonly updatedAt: FieldRef<"Websocket", 'DateTime'>
    readonly instanceId: FieldRef<"Websocket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Websocket findUnique
   */
  export type WebsocketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    /**
     * Filter, which Websocket to fetch.
     */
    where: WebsocketWhereUniqueInput
  }

  /**
   * Websocket findUniqueOrThrow
   */
  export type WebsocketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    /**
     * Filter, which Websocket to fetch.
     */
    where: WebsocketWhereUniqueInput
  }

  /**
   * Websocket findFirst
   */
  export type WebsocketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    /**
     * Filter, which Websocket to fetch.
     */
    where?: WebsocketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websockets to fetch.
     */
    orderBy?: WebsocketOrderByWithRelationInput | WebsocketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Websockets.
     */
    cursor?: WebsocketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websockets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websockets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Websockets.
     */
    distinct?: WebsocketScalarFieldEnum | WebsocketScalarFieldEnum[]
  }

  /**
   * Websocket findFirstOrThrow
   */
  export type WebsocketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    /**
     * Filter, which Websocket to fetch.
     */
    where?: WebsocketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websockets to fetch.
     */
    orderBy?: WebsocketOrderByWithRelationInput | WebsocketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Websockets.
     */
    cursor?: WebsocketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websockets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websockets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Websockets.
     */
    distinct?: WebsocketScalarFieldEnum | WebsocketScalarFieldEnum[]
  }

  /**
   * Websocket findMany
   */
  export type WebsocketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    /**
     * Filter, which Websockets to fetch.
     */
    where?: WebsocketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Websockets to fetch.
     */
    orderBy?: WebsocketOrderByWithRelationInput | WebsocketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Websockets.
     */
    cursor?: WebsocketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Websockets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Websockets.
     */
    skip?: number
    distinct?: WebsocketScalarFieldEnum | WebsocketScalarFieldEnum[]
  }

  /**
   * Websocket create
   */
  export type WebsocketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    /**
     * The data needed to create a Websocket.
     */
    data: XOR<WebsocketCreateInput, WebsocketUncheckedCreateInput>
  }

  /**
   * Websocket createMany
   */
  export type WebsocketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Websockets.
     */
    data: WebsocketCreateManyInput | WebsocketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Websocket update
   */
  export type WebsocketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    /**
     * The data needed to update a Websocket.
     */
    data: XOR<WebsocketUpdateInput, WebsocketUncheckedUpdateInput>
    /**
     * Choose, which Websocket to update.
     */
    where: WebsocketWhereUniqueInput
  }

  /**
   * Websocket updateMany
   */
  export type WebsocketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Websockets.
     */
    data: XOR<WebsocketUpdateManyMutationInput, WebsocketUncheckedUpdateManyInput>
    /**
     * Filter which Websockets to update
     */
    where?: WebsocketWhereInput
    /**
     * Limit how many Websockets to update.
     */
    limit?: number
  }

  /**
   * Websocket upsert
   */
  export type WebsocketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    /**
     * The filter to search for the Websocket to update in case it exists.
     */
    where: WebsocketWhereUniqueInput
    /**
     * In case the Websocket found by the `where` argument doesn't exist, create a new Websocket with this data.
     */
    create: XOR<WebsocketCreateInput, WebsocketUncheckedCreateInput>
    /**
     * In case the Websocket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebsocketUpdateInput, WebsocketUncheckedUpdateInput>
  }

  /**
   * Websocket delete
   */
  export type WebsocketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
    /**
     * Filter which Websocket to delete.
     */
    where: WebsocketWhereUniqueInput
  }

  /**
   * Websocket deleteMany
   */
  export type WebsocketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Websockets to delete
     */
    where?: WebsocketWhereInput
    /**
     * Limit how many Websockets to delete.
     */
    limit?: number
  }

  /**
   * Websocket without action
   */
  export type WebsocketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Websocket
     */
    select?: WebsocketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Websocket
     */
    omit?: WebsocketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebsocketInclude<ExtArgs> | null
  }


  /**
   * Model Pusher
   */

  export type AggregatePusher = {
    _count: PusherCountAggregateOutputType | null
    _min: PusherMinAggregateOutputType | null
    _max: PusherMaxAggregateOutputType | null
  }

  export type PusherMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    appId: string | null
    key: string | null
    secret: string | null
    cluster: string | null
    useTLS: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type PusherMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    appId: string | null
    key: string | null
    secret: string | null
    cluster: string | null
    useTLS: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type PusherCountAggregateOutputType = {
    id: number
    enabled: number
    appId: number
    key: number
    secret: number
    cluster: number
    useTLS: number
    events: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type PusherMinAggregateInputType = {
    id?: true
    enabled?: true
    appId?: true
    key?: true
    secret?: true
    cluster?: true
    useTLS?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type PusherMaxAggregateInputType = {
    id?: true
    enabled?: true
    appId?: true
    key?: true
    secret?: true
    cluster?: true
    useTLS?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type PusherCountAggregateInputType = {
    id?: true
    enabled?: true
    appId?: true
    key?: true
    secret?: true
    cluster?: true
    useTLS?: true
    events?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type PusherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pusher to aggregate.
     */
    where?: PusherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pushers to fetch.
     */
    orderBy?: PusherOrderByWithRelationInput | PusherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PusherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pushers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pushers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pushers
    **/
    _count?: true | PusherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PusherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PusherMaxAggregateInputType
  }

  export type GetPusherAggregateType<T extends PusherAggregateArgs> = {
        [P in keyof T & keyof AggregatePusher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePusher[P]>
      : GetScalarType<T[P], AggregatePusher[P]>
  }




  export type PusherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PusherWhereInput
    orderBy?: PusherOrderByWithAggregationInput | PusherOrderByWithAggregationInput[]
    by: PusherScalarFieldEnum[] | PusherScalarFieldEnum
    having?: PusherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PusherCountAggregateInputType | true
    _min?: PusherMinAggregateInputType
    _max?: PusherMaxAggregateInputType
  }

  export type PusherGroupByOutputType = {
    id: string
    enabled: boolean
    appId: string
    key: string
    secret: string
    cluster: string
    useTLS: boolean
    events: JsonValue
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: PusherCountAggregateOutputType | null
    _min: PusherMinAggregateOutputType | null
    _max: PusherMaxAggregateOutputType | null
  }

  type GetPusherGroupByPayload<T extends PusherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PusherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PusherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PusherGroupByOutputType[P]>
            : GetScalarType<T[P], PusherGroupByOutputType[P]>
        }
      >
    >


  export type PusherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    appId?: boolean
    key?: boolean
    secret?: boolean
    cluster?: boolean
    useTLS?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pusher"]>



  export type PusherSelectScalar = {
    id?: boolean
    enabled?: boolean
    appId?: boolean
    key?: boolean
    secret?: boolean
    cluster?: boolean
    useTLS?: boolean
    events?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type PusherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "appId" | "key" | "secret" | "cluster" | "useTLS" | "events" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["pusher"]>
  export type PusherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $PusherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pusher"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      appId: string
      key: string
      secret: string
      cluster: string
      useTLS: boolean
      events: Prisma.JsonValue
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["pusher"]>
    composites: {}
  }

  type PusherGetPayload<S extends boolean | null | undefined | PusherDefaultArgs> = $Result.GetResult<Prisma.$PusherPayload, S>

  type PusherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PusherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PusherCountAggregateInputType | true
    }

  export interface PusherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pusher'], meta: { name: 'Pusher' } }
    /**
     * Find zero or one Pusher that matches the filter.
     * @param {PusherFindUniqueArgs} args - Arguments to find a Pusher
     * @example
     * // Get one Pusher
     * const pusher = await prisma.pusher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PusherFindUniqueArgs>(args: SelectSubset<T, PusherFindUniqueArgs<ExtArgs>>): Prisma__PusherClient<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Pusher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PusherFindUniqueOrThrowArgs} args - Arguments to find a Pusher
     * @example
     * // Get one Pusher
     * const pusher = await prisma.pusher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PusherFindUniqueOrThrowArgs>(args: SelectSubset<T, PusherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PusherClient<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Pusher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PusherFindFirstArgs} args - Arguments to find a Pusher
     * @example
     * // Get one Pusher
     * const pusher = await prisma.pusher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PusherFindFirstArgs>(args?: SelectSubset<T, PusherFindFirstArgs<ExtArgs>>): Prisma__PusherClient<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Pusher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PusherFindFirstOrThrowArgs} args - Arguments to find a Pusher
     * @example
     * // Get one Pusher
     * const pusher = await prisma.pusher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PusherFindFirstOrThrowArgs>(args?: SelectSubset<T, PusherFindFirstOrThrowArgs<ExtArgs>>): Prisma__PusherClient<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pushers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PusherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pushers
     * const pushers = await prisma.pusher.findMany()
     * 
     * // Get first 10 Pushers
     * const pushers = await prisma.pusher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pusherWithIdOnly = await prisma.pusher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PusherFindManyArgs>(args?: SelectSubset<T, PusherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Pusher.
     * @param {PusherCreateArgs} args - Arguments to create a Pusher.
     * @example
     * // Create one Pusher
     * const Pusher = await prisma.pusher.create({
     *   data: {
     *     // ... data to create a Pusher
     *   }
     * })
     * 
     */
    create<T extends PusherCreateArgs>(args: SelectSubset<T, PusherCreateArgs<ExtArgs>>): Prisma__PusherClient<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pushers.
     * @param {PusherCreateManyArgs} args - Arguments to create many Pushers.
     * @example
     * // Create many Pushers
     * const pusher = await prisma.pusher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PusherCreateManyArgs>(args?: SelectSubset<T, PusherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pusher.
     * @param {PusherDeleteArgs} args - Arguments to delete one Pusher.
     * @example
     * // Delete one Pusher
     * const Pusher = await prisma.pusher.delete({
     *   where: {
     *     // ... filter to delete one Pusher
     *   }
     * })
     * 
     */
    delete<T extends PusherDeleteArgs>(args: SelectSubset<T, PusherDeleteArgs<ExtArgs>>): Prisma__PusherClient<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Pusher.
     * @param {PusherUpdateArgs} args - Arguments to update one Pusher.
     * @example
     * // Update one Pusher
     * const pusher = await prisma.pusher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PusherUpdateArgs>(args: SelectSubset<T, PusherUpdateArgs<ExtArgs>>): Prisma__PusherClient<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pushers.
     * @param {PusherDeleteManyArgs} args - Arguments to filter Pushers to delete.
     * @example
     * // Delete a few Pushers
     * const { count } = await prisma.pusher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PusherDeleteManyArgs>(args?: SelectSubset<T, PusherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pushers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PusherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pushers
     * const pusher = await prisma.pusher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PusherUpdateManyArgs>(args: SelectSubset<T, PusherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pusher.
     * @param {PusherUpsertArgs} args - Arguments to update or create a Pusher.
     * @example
     * // Update or create a Pusher
     * const pusher = await prisma.pusher.upsert({
     *   create: {
     *     // ... data to create a Pusher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pusher we want to update
     *   }
     * })
     */
    upsert<T extends PusherUpsertArgs>(args: SelectSubset<T, PusherUpsertArgs<ExtArgs>>): Prisma__PusherClient<$Result.GetResult<Prisma.$PusherPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pushers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PusherCountArgs} args - Arguments to filter Pushers to count.
     * @example
     * // Count the number of Pushers
     * const count = await prisma.pusher.count({
     *   where: {
     *     // ... the filter for the Pushers we want to count
     *   }
     * })
    **/
    count<T extends PusherCountArgs>(
      args?: Subset<T, PusherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PusherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pusher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PusherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PusherAggregateArgs>(args: Subset<T, PusherAggregateArgs>): Prisma.PrismaPromise<GetPusherAggregateType<T>>

    /**
     * Group by Pusher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PusherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PusherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PusherGroupByArgs['orderBy'] }
        : { orderBy?: PusherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PusherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPusherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pusher model
   */
  readonly fields: PusherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pusher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PusherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pusher model
   */ 
  interface PusherFieldRefs {
    readonly id: FieldRef<"Pusher", 'String'>
    readonly enabled: FieldRef<"Pusher", 'Boolean'>
    readonly appId: FieldRef<"Pusher", 'String'>
    readonly key: FieldRef<"Pusher", 'String'>
    readonly secret: FieldRef<"Pusher", 'String'>
    readonly cluster: FieldRef<"Pusher", 'String'>
    readonly useTLS: FieldRef<"Pusher", 'Boolean'>
    readonly events: FieldRef<"Pusher", 'Json'>
    readonly createdAt: FieldRef<"Pusher", 'DateTime'>
    readonly updatedAt: FieldRef<"Pusher", 'DateTime'>
    readonly instanceId: FieldRef<"Pusher", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pusher findUnique
   */
  export type PusherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    /**
     * Filter, which Pusher to fetch.
     */
    where: PusherWhereUniqueInput
  }

  /**
   * Pusher findUniqueOrThrow
   */
  export type PusherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    /**
     * Filter, which Pusher to fetch.
     */
    where: PusherWhereUniqueInput
  }

  /**
   * Pusher findFirst
   */
  export type PusherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    /**
     * Filter, which Pusher to fetch.
     */
    where?: PusherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pushers to fetch.
     */
    orderBy?: PusherOrderByWithRelationInput | PusherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pushers.
     */
    cursor?: PusherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pushers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pushers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pushers.
     */
    distinct?: PusherScalarFieldEnum | PusherScalarFieldEnum[]
  }

  /**
   * Pusher findFirstOrThrow
   */
  export type PusherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    /**
     * Filter, which Pusher to fetch.
     */
    where?: PusherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pushers to fetch.
     */
    orderBy?: PusherOrderByWithRelationInput | PusherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pushers.
     */
    cursor?: PusherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pushers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pushers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pushers.
     */
    distinct?: PusherScalarFieldEnum | PusherScalarFieldEnum[]
  }

  /**
   * Pusher findMany
   */
  export type PusherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    /**
     * Filter, which Pushers to fetch.
     */
    where?: PusherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pushers to fetch.
     */
    orderBy?: PusherOrderByWithRelationInput | PusherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pushers.
     */
    cursor?: PusherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pushers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pushers.
     */
    skip?: number
    distinct?: PusherScalarFieldEnum | PusherScalarFieldEnum[]
  }

  /**
   * Pusher create
   */
  export type PusherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    /**
     * The data needed to create a Pusher.
     */
    data: XOR<PusherCreateInput, PusherUncheckedCreateInput>
  }

  /**
   * Pusher createMany
   */
  export type PusherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pushers.
     */
    data: PusherCreateManyInput | PusherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pusher update
   */
  export type PusherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    /**
     * The data needed to update a Pusher.
     */
    data: XOR<PusherUpdateInput, PusherUncheckedUpdateInput>
    /**
     * Choose, which Pusher to update.
     */
    where: PusherWhereUniqueInput
  }

  /**
   * Pusher updateMany
   */
  export type PusherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pushers.
     */
    data: XOR<PusherUpdateManyMutationInput, PusherUncheckedUpdateManyInput>
    /**
     * Filter which Pushers to update
     */
    where?: PusherWhereInput
    /**
     * Limit how many Pushers to update.
     */
    limit?: number
  }

  /**
   * Pusher upsert
   */
  export type PusherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    /**
     * The filter to search for the Pusher to update in case it exists.
     */
    where: PusherWhereUniqueInput
    /**
     * In case the Pusher found by the `where` argument doesn't exist, create a new Pusher with this data.
     */
    create: XOR<PusherCreateInput, PusherUncheckedCreateInput>
    /**
     * In case the Pusher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PusherUpdateInput, PusherUncheckedUpdateInput>
  }

  /**
   * Pusher delete
   */
  export type PusherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
    /**
     * Filter which Pusher to delete.
     */
    where: PusherWhereUniqueInput
  }

  /**
   * Pusher deleteMany
   */
  export type PusherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pushers to delete
     */
    where?: PusherWhereInput
    /**
     * Limit how many Pushers to delete.
     */
    limit?: number
  }

  /**
   * Pusher without action
   */
  export type PusherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pusher
     */
    select?: PusherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pusher
     */
    omit?: PusherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PusherInclude<ExtArgs> | null
  }


  /**
   * Model Typebot
   */

  export type AggregateTypebot = {
    _count: TypebotCountAggregateOutputType | null
    _avg: TypebotAvgAggregateOutputType | null
    _sum: TypebotSumAggregateOutputType | null
    _min: TypebotMinAggregateOutputType | null
    _max: TypebotMaxAggregateOutputType | null
  }

  export type TypebotAvgAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
  }

  export type TypebotSumAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
  }

  export type TypebotMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    url: string | null
    typebot: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    instanceId: string | null
  }

  export type TypebotMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    url: string | null
    typebot: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    instanceId: string | null
  }

  export type TypebotCountAggregateOutputType = {
    id: number
    enabled: number
    description: number
    url: number
    typebot: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    createdAt: number
    updatedAt: number
    ignoreJids: number
    triggerType: number
    triggerOperator: number
    triggerValue: number
    instanceId: number
    _all: number
  }


  export type TypebotAvgAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
  }

  export type TypebotSumAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
  }

  export type TypebotMinAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    url?: true
    typebot?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    createdAt?: true
    updatedAt?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    instanceId?: true
  }

  export type TypebotMaxAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    url?: true
    typebot?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    createdAt?: true
    updatedAt?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    instanceId?: true
  }

  export type TypebotCountAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    url?: true
    typebot?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    createdAt?: true
    updatedAt?: true
    ignoreJids?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    instanceId?: true
    _all?: true
  }

  export type TypebotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Typebot to aggregate.
     */
    where?: TypebotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Typebots to fetch.
     */
    orderBy?: TypebotOrderByWithRelationInput | TypebotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypebotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Typebots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Typebots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Typebots
    **/
    _count?: true | TypebotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypebotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypebotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypebotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypebotMaxAggregateInputType
  }

  export type GetTypebotAggregateType<T extends TypebotAggregateArgs> = {
        [P in keyof T & keyof AggregateTypebot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypebot[P]>
      : GetScalarType<T[P], AggregateTypebot[P]>
  }




  export type TypebotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypebotWhereInput
    orderBy?: TypebotOrderByWithAggregationInput | TypebotOrderByWithAggregationInput[]
    by: TypebotScalarFieldEnum[] | TypebotScalarFieldEnum
    having?: TypebotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypebotCountAggregateInputType | true
    _avg?: TypebotAvgAggregateInputType
    _sum?: TypebotSumAggregateInputType
    _min?: TypebotMinAggregateInputType
    _max?: TypebotMaxAggregateInputType
  }

  export type TypebotGroupByOutputType = {
    id: string
    enabled: boolean
    description: string | null
    url: string
    typebot: string
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    ignoreJids: JsonValue | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    instanceId: string
    _count: TypebotCountAggregateOutputType | null
    _avg: TypebotAvgAggregateOutputType | null
    _sum: TypebotSumAggregateOutputType | null
    _min: TypebotMinAggregateOutputType | null
    _max: TypebotMaxAggregateOutputType | null
  }

  type GetTypebotGroupByPayload<T extends TypebotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypebotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypebotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypebotGroupByOutputType[P]>
            : GetScalarType<T[P], TypebotGroupByOutputType[P]>
        }
      >
    >


  export type TypebotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    description?: boolean
    url?: boolean
    typebot?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ignoreJids?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    TypebotSetting?: boolean | Typebot$TypebotSettingArgs<ExtArgs>
    _count?: boolean | TypebotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typebot"]>



  export type TypebotSelectScalar = {
    id?: boolean
    enabled?: boolean
    description?: boolean
    url?: boolean
    typebot?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ignoreJids?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    instanceId?: boolean
  }

  export type TypebotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "description" | "url" | "typebot" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "createdAt" | "updatedAt" | "ignoreJids" | "triggerType" | "triggerOperator" | "triggerValue" | "instanceId", ExtArgs["result"]["typebot"]>
  export type TypebotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    TypebotSetting?: boolean | Typebot$TypebotSettingArgs<ExtArgs>
    _count?: boolean | TypebotCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TypebotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Typebot"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
      TypebotSetting: Prisma.$TypebotSettingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      description: string | null
      url: string
      typebot: string
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      createdAt: Date | null
      updatedAt: Date | null
      ignoreJids: Prisma.JsonValue | null
      triggerType: $Enums.TriggerType | null
      triggerOperator: $Enums.TriggerOperator | null
      triggerValue: string | null
      instanceId: string
    }, ExtArgs["result"]["typebot"]>
    composites: {}
  }

  type TypebotGetPayload<S extends boolean | null | undefined | TypebotDefaultArgs> = $Result.GetResult<Prisma.$TypebotPayload, S>

  type TypebotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TypebotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypebotCountAggregateInputType | true
    }

  export interface TypebotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Typebot'], meta: { name: 'Typebot' } }
    /**
     * Find zero or one Typebot that matches the filter.
     * @param {TypebotFindUniqueArgs} args - Arguments to find a Typebot
     * @example
     * // Get one Typebot
     * const typebot = await prisma.typebot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypebotFindUniqueArgs>(args: SelectSubset<T, TypebotFindUniqueArgs<ExtArgs>>): Prisma__TypebotClient<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Typebot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TypebotFindUniqueOrThrowArgs} args - Arguments to find a Typebot
     * @example
     * // Get one Typebot
     * const typebot = await prisma.typebot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypebotFindUniqueOrThrowArgs>(args: SelectSubset<T, TypebotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypebotClient<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Typebot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotFindFirstArgs} args - Arguments to find a Typebot
     * @example
     * // Get one Typebot
     * const typebot = await prisma.typebot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypebotFindFirstArgs>(args?: SelectSubset<T, TypebotFindFirstArgs<ExtArgs>>): Prisma__TypebotClient<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Typebot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotFindFirstOrThrowArgs} args - Arguments to find a Typebot
     * @example
     * // Get one Typebot
     * const typebot = await prisma.typebot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypebotFindFirstOrThrowArgs>(args?: SelectSubset<T, TypebotFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypebotClient<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Typebots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Typebots
     * const typebots = await prisma.typebot.findMany()
     * 
     * // Get first 10 Typebots
     * const typebots = await prisma.typebot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typebotWithIdOnly = await prisma.typebot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TypebotFindManyArgs>(args?: SelectSubset<T, TypebotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Typebot.
     * @param {TypebotCreateArgs} args - Arguments to create a Typebot.
     * @example
     * // Create one Typebot
     * const Typebot = await prisma.typebot.create({
     *   data: {
     *     // ... data to create a Typebot
     *   }
     * })
     * 
     */
    create<T extends TypebotCreateArgs>(args: SelectSubset<T, TypebotCreateArgs<ExtArgs>>): Prisma__TypebotClient<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Typebots.
     * @param {TypebotCreateManyArgs} args - Arguments to create many Typebots.
     * @example
     * // Create many Typebots
     * const typebot = await prisma.typebot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypebotCreateManyArgs>(args?: SelectSubset<T, TypebotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Typebot.
     * @param {TypebotDeleteArgs} args - Arguments to delete one Typebot.
     * @example
     * // Delete one Typebot
     * const Typebot = await prisma.typebot.delete({
     *   where: {
     *     // ... filter to delete one Typebot
     *   }
     * })
     * 
     */
    delete<T extends TypebotDeleteArgs>(args: SelectSubset<T, TypebotDeleteArgs<ExtArgs>>): Prisma__TypebotClient<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Typebot.
     * @param {TypebotUpdateArgs} args - Arguments to update one Typebot.
     * @example
     * // Update one Typebot
     * const typebot = await prisma.typebot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypebotUpdateArgs>(args: SelectSubset<T, TypebotUpdateArgs<ExtArgs>>): Prisma__TypebotClient<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Typebots.
     * @param {TypebotDeleteManyArgs} args - Arguments to filter Typebots to delete.
     * @example
     * // Delete a few Typebots
     * const { count } = await prisma.typebot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypebotDeleteManyArgs>(args?: SelectSubset<T, TypebotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Typebots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Typebots
     * const typebot = await prisma.typebot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypebotUpdateManyArgs>(args: SelectSubset<T, TypebotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Typebot.
     * @param {TypebotUpsertArgs} args - Arguments to update or create a Typebot.
     * @example
     * // Update or create a Typebot
     * const typebot = await prisma.typebot.upsert({
     *   create: {
     *     // ... data to create a Typebot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Typebot we want to update
     *   }
     * })
     */
    upsert<T extends TypebotUpsertArgs>(args: SelectSubset<T, TypebotUpsertArgs<ExtArgs>>): Prisma__TypebotClient<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Typebots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotCountArgs} args - Arguments to filter Typebots to count.
     * @example
     * // Count the number of Typebots
     * const count = await prisma.typebot.count({
     *   where: {
     *     // ... the filter for the Typebots we want to count
     *   }
     * })
    **/
    count<T extends TypebotCountArgs>(
      args?: Subset<T, TypebotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypebotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Typebot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypebotAggregateArgs>(args: Subset<T, TypebotAggregateArgs>): Prisma.PrismaPromise<GetTypebotAggregateType<T>>

    /**
     * Group by Typebot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypebotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypebotGroupByArgs['orderBy'] }
        : { orderBy?: TypebotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypebotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypebotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Typebot model
   */
  readonly fields: TypebotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Typebot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypebotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TypebotSetting<T extends Typebot$TypebotSettingArgs<ExtArgs> = {}>(args?: Subset<T, Typebot$TypebotSettingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Typebot model
   */ 
  interface TypebotFieldRefs {
    readonly id: FieldRef<"Typebot", 'String'>
    readonly enabled: FieldRef<"Typebot", 'Boolean'>
    readonly description: FieldRef<"Typebot", 'String'>
    readonly url: FieldRef<"Typebot", 'String'>
    readonly typebot: FieldRef<"Typebot", 'String'>
    readonly expire: FieldRef<"Typebot", 'Int'>
    readonly keywordFinish: FieldRef<"Typebot", 'String'>
    readonly delayMessage: FieldRef<"Typebot", 'Int'>
    readonly unknownMessage: FieldRef<"Typebot", 'String'>
    readonly listeningFromMe: FieldRef<"Typebot", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"Typebot", 'Boolean'>
    readonly keepOpen: FieldRef<"Typebot", 'Boolean'>
    readonly debounceTime: FieldRef<"Typebot", 'Int'>
    readonly createdAt: FieldRef<"Typebot", 'DateTime'>
    readonly updatedAt: FieldRef<"Typebot", 'DateTime'>
    readonly ignoreJids: FieldRef<"Typebot", 'Json'>
    readonly triggerType: FieldRef<"Typebot", 'TriggerType'>
    readonly triggerOperator: FieldRef<"Typebot", 'TriggerOperator'>
    readonly triggerValue: FieldRef<"Typebot", 'String'>
    readonly instanceId: FieldRef<"Typebot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Typebot findUnique
   */
  export type TypebotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    /**
     * Filter, which Typebot to fetch.
     */
    where: TypebotWhereUniqueInput
  }

  /**
   * Typebot findUniqueOrThrow
   */
  export type TypebotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    /**
     * Filter, which Typebot to fetch.
     */
    where: TypebotWhereUniqueInput
  }

  /**
   * Typebot findFirst
   */
  export type TypebotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    /**
     * Filter, which Typebot to fetch.
     */
    where?: TypebotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Typebots to fetch.
     */
    orderBy?: TypebotOrderByWithRelationInput | TypebotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Typebots.
     */
    cursor?: TypebotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Typebots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Typebots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Typebots.
     */
    distinct?: TypebotScalarFieldEnum | TypebotScalarFieldEnum[]
  }

  /**
   * Typebot findFirstOrThrow
   */
  export type TypebotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    /**
     * Filter, which Typebot to fetch.
     */
    where?: TypebotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Typebots to fetch.
     */
    orderBy?: TypebotOrderByWithRelationInput | TypebotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Typebots.
     */
    cursor?: TypebotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Typebots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Typebots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Typebots.
     */
    distinct?: TypebotScalarFieldEnum | TypebotScalarFieldEnum[]
  }

  /**
   * Typebot findMany
   */
  export type TypebotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    /**
     * Filter, which Typebots to fetch.
     */
    where?: TypebotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Typebots to fetch.
     */
    orderBy?: TypebotOrderByWithRelationInput | TypebotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Typebots.
     */
    cursor?: TypebotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Typebots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Typebots.
     */
    skip?: number
    distinct?: TypebotScalarFieldEnum | TypebotScalarFieldEnum[]
  }

  /**
   * Typebot create
   */
  export type TypebotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    /**
     * The data needed to create a Typebot.
     */
    data: XOR<TypebotCreateInput, TypebotUncheckedCreateInput>
  }

  /**
   * Typebot createMany
   */
  export type TypebotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Typebots.
     */
    data: TypebotCreateManyInput | TypebotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Typebot update
   */
  export type TypebotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    /**
     * The data needed to update a Typebot.
     */
    data: XOR<TypebotUpdateInput, TypebotUncheckedUpdateInput>
    /**
     * Choose, which Typebot to update.
     */
    where: TypebotWhereUniqueInput
  }

  /**
   * Typebot updateMany
   */
  export type TypebotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Typebots.
     */
    data: XOR<TypebotUpdateManyMutationInput, TypebotUncheckedUpdateManyInput>
    /**
     * Filter which Typebots to update
     */
    where?: TypebotWhereInput
    /**
     * Limit how many Typebots to update.
     */
    limit?: number
  }

  /**
   * Typebot upsert
   */
  export type TypebotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    /**
     * The filter to search for the Typebot to update in case it exists.
     */
    where: TypebotWhereUniqueInput
    /**
     * In case the Typebot found by the `where` argument doesn't exist, create a new Typebot with this data.
     */
    create: XOR<TypebotCreateInput, TypebotUncheckedCreateInput>
    /**
     * In case the Typebot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypebotUpdateInput, TypebotUncheckedUpdateInput>
  }

  /**
   * Typebot delete
   */
  export type TypebotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    /**
     * Filter which Typebot to delete.
     */
    where: TypebotWhereUniqueInput
  }

  /**
   * Typebot deleteMany
   */
  export type TypebotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Typebots to delete
     */
    where?: TypebotWhereInput
    /**
     * Limit how many Typebots to delete.
     */
    limit?: number
  }

  /**
   * Typebot.TypebotSetting
   */
  export type Typebot$TypebotSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    where?: TypebotSettingWhereInput
    orderBy?: TypebotSettingOrderByWithRelationInput | TypebotSettingOrderByWithRelationInput[]
    cursor?: TypebotSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TypebotSettingScalarFieldEnum | TypebotSettingScalarFieldEnum[]
  }

  /**
   * Typebot without action
   */
  export type TypebotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
  }


  /**
   * Model TypebotSetting
   */

  export type AggregateTypebotSetting = {
    _count: TypebotSettingCountAggregateOutputType | null
    _avg: TypebotSettingAvgAggregateOutputType | null
    _sum: TypebotSettingSumAggregateOutputType | null
    _min: TypebotSettingMinAggregateOutputType | null
    _max: TypebotSettingMaxAggregateOutputType | null
  }

  export type TypebotSettingAvgAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
  }

  export type TypebotSettingSumAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
  }

  export type TypebotSettingMinAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    typebotIdFallback: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type TypebotSettingMaxAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    typebotIdFallback: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type TypebotSettingCountAggregateOutputType = {
    id: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    typebotIdFallback: number
    ignoreJids: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type TypebotSettingAvgAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
  }

  export type TypebotSettingSumAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
  }

  export type TypebotSettingMinAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    typebotIdFallback?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type TypebotSettingMaxAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    typebotIdFallback?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type TypebotSettingCountAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    typebotIdFallback?: true
    ignoreJids?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type TypebotSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypebotSetting to aggregate.
     */
    where?: TypebotSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypebotSettings to fetch.
     */
    orderBy?: TypebotSettingOrderByWithRelationInput | TypebotSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypebotSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypebotSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypebotSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypebotSettings
    **/
    _count?: true | TypebotSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypebotSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypebotSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypebotSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypebotSettingMaxAggregateInputType
  }

  export type GetTypebotSettingAggregateType<T extends TypebotSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateTypebotSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypebotSetting[P]>
      : GetScalarType<T[P], AggregateTypebotSetting[P]>
  }




  export type TypebotSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypebotSettingWhereInput
    orderBy?: TypebotSettingOrderByWithAggregationInput | TypebotSettingOrderByWithAggregationInput[]
    by: TypebotSettingScalarFieldEnum[] | TypebotSettingScalarFieldEnum
    having?: TypebotSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypebotSettingCountAggregateInputType | true
    _avg?: TypebotSettingAvgAggregateInputType
    _sum?: TypebotSettingSumAggregateInputType
    _min?: TypebotSettingMinAggregateInputType
    _max?: TypebotSettingMaxAggregateInputType
  }

  export type TypebotSettingGroupByOutputType = {
    id: string
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    typebotIdFallback: string | null
    ignoreJids: JsonValue | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: TypebotSettingCountAggregateOutputType | null
    _avg: TypebotSettingAvgAggregateOutputType | null
    _sum: TypebotSettingSumAggregateOutputType | null
    _min: TypebotSettingMinAggregateOutputType | null
    _max: TypebotSettingMaxAggregateOutputType | null
  }

  type GetTypebotSettingGroupByPayload<T extends TypebotSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypebotSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypebotSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypebotSettingGroupByOutputType[P]>
            : GetScalarType<T[P], TypebotSettingGroupByOutputType[P]>
        }
      >
    >


  export type TypebotSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    typebotIdFallback?: boolean
    ignoreJids?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Fallback?: boolean | TypebotSetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typebotSetting"]>



  export type TypebotSettingSelectScalar = {
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    typebotIdFallback?: boolean
    ignoreJids?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type TypebotSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "typebotIdFallback" | "ignoreJids" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["typebotSetting"]>
  export type TypebotSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Fallback?: boolean | TypebotSetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $TypebotSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TypebotSetting"
    objects: {
      Fallback: Prisma.$TypebotPayload<ExtArgs> | null
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      typebotIdFallback: string | null
      ignoreJids: Prisma.JsonValue | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["typebotSetting"]>
    composites: {}
  }

  type TypebotSettingGetPayload<S extends boolean | null | undefined | TypebotSettingDefaultArgs> = $Result.GetResult<Prisma.$TypebotSettingPayload, S>

  type TypebotSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TypebotSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypebotSettingCountAggregateInputType | true
    }

  export interface TypebotSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypebotSetting'], meta: { name: 'TypebotSetting' } }
    /**
     * Find zero or one TypebotSetting that matches the filter.
     * @param {TypebotSettingFindUniqueArgs} args - Arguments to find a TypebotSetting
     * @example
     * // Get one TypebotSetting
     * const typebotSetting = await prisma.typebotSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypebotSettingFindUniqueArgs>(args: SelectSubset<T, TypebotSettingFindUniqueArgs<ExtArgs>>): Prisma__TypebotSettingClient<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TypebotSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TypebotSettingFindUniqueOrThrowArgs} args - Arguments to find a TypebotSetting
     * @example
     * // Get one TypebotSetting
     * const typebotSetting = await prisma.typebotSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypebotSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, TypebotSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypebotSettingClient<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TypebotSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotSettingFindFirstArgs} args - Arguments to find a TypebotSetting
     * @example
     * // Get one TypebotSetting
     * const typebotSetting = await prisma.typebotSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypebotSettingFindFirstArgs>(args?: SelectSubset<T, TypebotSettingFindFirstArgs<ExtArgs>>): Prisma__TypebotSettingClient<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TypebotSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotSettingFindFirstOrThrowArgs} args - Arguments to find a TypebotSetting
     * @example
     * // Get one TypebotSetting
     * const typebotSetting = await prisma.typebotSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypebotSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, TypebotSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypebotSettingClient<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TypebotSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypebotSettings
     * const typebotSettings = await prisma.typebotSetting.findMany()
     * 
     * // Get first 10 TypebotSettings
     * const typebotSettings = await prisma.typebotSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typebotSettingWithIdOnly = await prisma.typebotSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TypebotSettingFindManyArgs>(args?: SelectSubset<T, TypebotSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TypebotSetting.
     * @param {TypebotSettingCreateArgs} args - Arguments to create a TypebotSetting.
     * @example
     * // Create one TypebotSetting
     * const TypebotSetting = await prisma.typebotSetting.create({
     *   data: {
     *     // ... data to create a TypebotSetting
     *   }
     * })
     * 
     */
    create<T extends TypebotSettingCreateArgs>(args: SelectSubset<T, TypebotSettingCreateArgs<ExtArgs>>): Prisma__TypebotSettingClient<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TypebotSettings.
     * @param {TypebotSettingCreateManyArgs} args - Arguments to create many TypebotSettings.
     * @example
     * // Create many TypebotSettings
     * const typebotSetting = await prisma.typebotSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypebotSettingCreateManyArgs>(args?: SelectSubset<T, TypebotSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypebotSetting.
     * @param {TypebotSettingDeleteArgs} args - Arguments to delete one TypebotSetting.
     * @example
     * // Delete one TypebotSetting
     * const TypebotSetting = await prisma.typebotSetting.delete({
     *   where: {
     *     // ... filter to delete one TypebotSetting
     *   }
     * })
     * 
     */
    delete<T extends TypebotSettingDeleteArgs>(args: SelectSubset<T, TypebotSettingDeleteArgs<ExtArgs>>): Prisma__TypebotSettingClient<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TypebotSetting.
     * @param {TypebotSettingUpdateArgs} args - Arguments to update one TypebotSetting.
     * @example
     * // Update one TypebotSetting
     * const typebotSetting = await prisma.typebotSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypebotSettingUpdateArgs>(args: SelectSubset<T, TypebotSettingUpdateArgs<ExtArgs>>): Prisma__TypebotSettingClient<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TypebotSettings.
     * @param {TypebotSettingDeleteManyArgs} args - Arguments to filter TypebotSettings to delete.
     * @example
     * // Delete a few TypebotSettings
     * const { count } = await prisma.typebotSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypebotSettingDeleteManyArgs>(args?: SelectSubset<T, TypebotSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypebotSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypebotSettings
     * const typebotSetting = await prisma.typebotSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypebotSettingUpdateManyArgs>(args: SelectSubset<T, TypebotSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypebotSetting.
     * @param {TypebotSettingUpsertArgs} args - Arguments to update or create a TypebotSetting.
     * @example
     * // Update or create a TypebotSetting
     * const typebotSetting = await prisma.typebotSetting.upsert({
     *   create: {
     *     // ... data to create a TypebotSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypebotSetting we want to update
     *   }
     * })
     */
    upsert<T extends TypebotSettingUpsertArgs>(args: SelectSubset<T, TypebotSettingUpsertArgs<ExtArgs>>): Prisma__TypebotSettingClient<$Result.GetResult<Prisma.$TypebotSettingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TypebotSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotSettingCountArgs} args - Arguments to filter TypebotSettings to count.
     * @example
     * // Count the number of TypebotSettings
     * const count = await prisma.typebotSetting.count({
     *   where: {
     *     // ... the filter for the TypebotSettings we want to count
     *   }
     * })
    **/
    count<T extends TypebotSettingCountArgs>(
      args?: Subset<T, TypebotSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypebotSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypebotSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypebotSettingAggregateArgs>(args: Subset<T, TypebotSettingAggregateArgs>): Prisma.PrismaPromise<GetTypebotSettingAggregateType<T>>

    /**
     * Group by TypebotSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypebotSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypebotSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypebotSettingGroupByArgs['orderBy'] }
        : { orderBy?: TypebotSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypebotSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypebotSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TypebotSetting model
   */
  readonly fields: TypebotSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TypebotSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypebotSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Fallback<T extends TypebotSetting$FallbackArgs<ExtArgs> = {}>(args?: Subset<T, TypebotSetting$FallbackArgs<ExtArgs>>): Prisma__TypebotClient<$Result.GetResult<Prisma.$TypebotPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TypebotSetting model
   */ 
  interface TypebotSettingFieldRefs {
    readonly id: FieldRef<"TypebotSetting", 'String'>
    readonly expire: FieldRef<"TypebotSetting", 'Int'>
    readonly keywordFinish: FieldRef<"TypebotSetting", 'String'>
    readonly delayMessage: FieldRef<"TypebotSetting", 'Int'>
    readonly unknownMessage: FieldRef<"TypebotSetting", 'String'>
    readonly listeningFromMe: FieldRef<"TypebotSetting", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"TypebotSetting", 'Boolean'>
    readonly keepOpen: FieldRef<"TypebotSetting", 'Boolean'>
    readonly debounceTime: FieldRef<"TypebotSetting", 'Int'>
    readonly typebotIdFallback: FieldRef<"TypebotSetting", 'String'>
    readonly ignoreJids: FieldRef<"TypebotSetting", 'Json'>
    readonly createdAt: FieldRef<"TypebotSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"TypebotSetting", 'DateTime'>
    readonly instanceId: FieldRef<"TypebotSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TypebotSetting findUnique
   */
  export type TypebotSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    /**
     * Filter, which TypebotSetting to fetch.
     */
    where: TypebotSettingWhereUniqueInput
  }

  /**
   * TypebotSetting findUniqueOrThrow
   */
  export type TypebotSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    /**
     * Filter, which TypebotSetting to fetch.
     */
    where: TypebotSettingWhereUniqueInput
  }

  /**
   * TypebotSetting findFirst
   */
  export type TypebotSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    /**
     * Filter, which TypebotSetting to fetch.
     */
    where?: TypebotSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypebotSettings to fetch.
     */
    orderBy?: TypebotSettingOrderByWithRelationInput | TypebotSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypebotSettings.
     */
    cursor?: TypebotSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypebotSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypebotSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypebotSettings.
     */
    distinct?: TypebotSettingScalarFieldEnum | TypebotSettingScalarFieldEnum[]
  }

  /**
   * TypebotSetting findFirstOrThrow
   */
  export type TypebotSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    /**
     * Filter, which TypebotSetting to fetch.
     */
    where?: TypebotSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypebotSettings to fetch.
     */
    orderBy?: TypebotSettingOrderByWithRelationInput | TypebotSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypebotSettings.
     */
    cursor?: TypebotSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypebotSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypebotSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypebotSettings.
     */
    distinct?: TypebotSettingScalarFieldEnum | TypebotSettingScalarFieldEnum[]
  }

  /**
   * TypebotSetting findMany
   */
  export type TypebotSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    /**
     * Filter, which TypebotSettings to fetch.
     */
    where?: TypebotSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypebotSettings to fetch.
     */
    orderBy?: TypebotSettingOrderByWithRelationInput | TypebotSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypebotSettings.
     */
    cursor?: TypebotSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypebotSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypebotSettings.
     */
    skip?: number
    distinct?: TypebotSettingScalarFieldEnum | TypebotSettingScalarFieldEnum[]
  }

  /**
   * TypebotSetting create
   */
  export type TypebotSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a TypebotSetting.
     */
    data: XOR<TypebotSettingCreateInput, TypebotSettingUncheckedCreateInput>
  }

  /**
   * TypebotSetting createMany
   */
  export type TypebotSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypebotSettings.
     */
    data: TypebotSettingCreateManyInput | TypebotSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TypebotSetting update
   */
  export type TypebotSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a TypebotSetting.
     */
    data: XOR<TypebotSettingUpdateInput, TypebotSettingUncheckedUpdateInput>
    /**
     * Choose, which TypebotSetting to update.
     */
    where: TypebotSettingWhereUniqueInput
  }

  /**
   * TypebotSetting updateMany
   */
  export type TypebotSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypebotSettings.
     */
    data: XOR<TypebotSettingUpdateManyMutationInput, TypebotSettingUncheckedUpdateManyInput>
    /**
     * Filter which TypebotSettings to update
     */
    where?: TypebotSettingWhereInput
    /**
     * Limit how many TypebotSettings to update.
     */
    limit?: number
  }

  /**
   * TypebotSetting upsert
   */
  export type TypebotSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the TypebotSetting to update in case it exists.
     */
    where: TypebotSettingWhereUniqueInput
    /**
     * In case the TypebotSetting found by the `where` argument doesn't exist, create a new TypebotSetting with this data.
     */
    create: XOR<TypebotSettingCreateInput, TypebotSettingUncheckedCreateInput>
    /**
     * In case the TypebotSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypebotSettingUpdateInput, TypebotSettingUncheckedUpdateInput>
  }

  /**
   * TypebotSetting delete
   */
  export type TypebotSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
    /**
     * Filter which TypebotSetting to delete.
     */
    where: TypebotSettingWhereUniqueInput
  }

  /**
   * TypebotSetting deleteMany
   */
  export type TypebotSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypebotSettings to delete
     */
    where?: TypebotSettingWhereInput
    /**
     * Limit how many TypebotSettings to delete.
     */
    limit?: number
  }

  /**
   * TypebotSetting.Fallback
   */
  export type TypebotSetting$FallbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Typebot
     */
    select?: TypebotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Typebot
     */
    omit?: TypebotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotInclude<ExtArgs> | null
    where?: TypebotWhereInput
  }

  /**
   * TypebotSetting without action
   */
  export type TypebotSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypebotSetting
     */
    select?: TypebotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypebotSetting
     */
    omit?: TypebotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypebotSettingInclude<ExtArgs> | null
  }


  /**
   * Model IntegrationSession
   */

  export type AggregateIntegrationSession = {
    _count: IntegrationSessionCountAggregateOutputType | null
    _min: IntegrationSessionMinAggregateOutputType | null
    _max: IntegrationSessionMaxAggregateOutputType | null
  }

  export type IntegrationSessionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    remoteJid: string | null
    pushName: string | null
    status: $Enums.SessionStatus | null
    awaitUser: boolean | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
    botId: string | null
  }

  export type IntegrationSessionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    remoteJid: string | null
    pushName: string | null
    status: $Enums.SessionStatus | null
    awaitUser: boolean | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
    botId: string | null
  }

  export type IntegrationSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    remoteJid: number
    pushName: number
    status: number
    awaitUser: number
    context: number
    type: number
    createdAt: number
    updatedAt: number
    instanceId: number
    parameters: number
    botId: number
    _all: number
  }


  export type IntegrationSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    remoteJid?: true
    pushName?: true
    status?: true
    awaitUser?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    botId?: true
  }

  export type IntegrationSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    remoteJid?: true
    pushName?: true
    status?: true
    awaitUser?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    botId?: true
  }

  export type IntegrationSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    remoteJid?: true
    pushName?: true
    status?: true
    awaitUser?: true
    context?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    parameters?: true
    botId?: true
    _all?: true
  }

  export type IntegrationSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationSession to aggregate.
     */
    where?: IntegrationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationSessions to fetch.
     */
    orderBy?: IntegrationSessionOrderByWithRelationInput | IntegrationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntegrationSessions
    **/
    _count?: true | IntegrationSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationSessionMaxAggregateInputType
  }

  export type GetIntegrationSessionAggregateType<T extends IntegrationSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegrationSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegrationSession[P]>
      : GetScalarType<T[P], AggregateIntegrationSession[P]>
  }




  export type IntegrationSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationSessionWhereInput
    orderBy?: IntegrationSessionOrderByWithAggregationInput | IntegrationSessionOrderByWithAggregationInput[]
    by: IntegrationSessionScalarFieldEnum[] | IntegrationSessionScalarFieldEnum
    having?: IntegrationSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationSessionCountAggregateInputType | true
    _min?: IntegrationSessionMinAggregateInputType
    _max?: IntegrationSessionMaxAggregateInputType
  }

  export type IntegrationSessionGroupByOutputType = {
    id: string
    sessionId: string
    remoteJid: string
    pushName: string | null
    status: $Enums.SessionStatus
    awaitUser: boolean
    context: JsonValue | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    parameters: JsonValue | null
    botId: string | null
    _count: IntegrationSessionCountAggregateOutputType | null
    _min: IntegrationSessionMinAggregateOutputType | null
    _max: IntegrationSessionMaxAggregateOutputType | null
  }

  type GetIntegrationSessionGroupByPayload<T extends IntegrationSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationSessionGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationSessionGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    remoteJid?: boolean
    pushName?: boolean
    status?: boolean
    awaitUser?: boolean
    context?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    parameters?: boolean
    botId?: boolean
    Message?: boolean | IntegrationSession$MessageArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    _count?: boolean | IntegrationSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrationSession"]>



  export type IntegrationSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    remoteJid?: boolean
    pushName?: boolean
    status?: boolean
    awaitUser?: boolean
    context?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    parameters?: boolean
    botId?: boolean
  }

  export type IntegrationSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "remoteJid" | "pushName" | "status" | "awaitUser" | "context" | "type" | "createdAt" | "updatedAt" | "instanceId" | "parameters" | "botId", ExtArgs["result"]["integrationSession"]>
  export type IntegrationSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Message?: boolean | IntegrationSession$MessageArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    _count?: boolean | IntegrationSessionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $IntegrationSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntegrationSession"
    objects: {
      Message: Prisma.$MessagePayload<ExtArgs>[]
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      remoteJid: string
      pushName: string | null
      status: $Enums.SessionStatus
      awaitUser: boolean
      context: Prisma.JsonValue | null
      type: string | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
      parameters: Prisma.JsonValue | null
      botId: string | null
    }, ExtArgs["result"]["integrationSession"]>
    composites: {}
  }

  type IntegrationSessionGetPayload<S extends boolean | null | undefined | IntegrationSessionDefaultArgs> = $Result.GetResult<Prisma.$IntegrationSessionPayload, S>

  type IntegrationSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationSessionCountAggregateInputType | true
    }

  export interface IntegrationSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntegrationSession'], meta: { name: 'IntegrationSession' } }
    /**
     * Find zero or one IntegrationSession that matches the filter.
     * @param {IntegrationSessionFindUniqueArgs} args - Arguments to find a IntegrationSession
     * @example
     * // Get one IntegrationSession
     * const integrationSession = await prisma.integrationSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationSessionFindUniqueArgs>(args: SelectSubset<T, IntegrationSessionFindUniqueArgs<ExtArgs>>): Prisma__IntegrationSessionClient<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one IntegrationSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationSessionFindUniqueOrThrowArgs} args - Arguments to find a IntegrationSession
     * @example
     * // Get one IntegrationSession
     * const integrationSession = await prisma.integrationSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationSessionClient<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first IntegrationSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSessionFindFirstArgs} args - Arguments to find a IntegrationSession
     * @example
     * // Get one IntegrationSession
     * const integrationSession = await prisma.integrationSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationSessionFindFirstArgs>(args?: SelectSubset<T, IntegrationSessionFindFirstArgs<ExtArgs>>): Prisma__IntegrationSessionClient<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first IntegrationSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSessionFindFirstOrThrowArgs} args - Arguments to find a IntegrationSession
     * @example
     * // Get one IntegrationSession
     * const integrationSession = await prisma.integrationSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationSessionClient<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more IntegrationSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntegrationSessions
     * const integrationSessions = await prisma.integrationSession.findMany()
     * 
     * // Get first 10 IntegrationSessions
     * const integrationSessions = await prisma.integrationSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationSessionWithIdOnly = await prisma.integrationSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationSessionFindManyArgs>(args?: SelectSubset<T, IntegrationSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a IntegrationSession.
     * @param {IntegrationSessionCreateArgs} args - Arguments to create a IntegrationSession.
     * @example
     * // Create one IntegrationSession
     * const IntegrationSession = await prisma.integrationSession.create({
     *   data: {
     *     // ... data to create a IntegrationSession
     *   }
     * })
     * 
     */
    create<T extends IntegrationSessionCreateArgs>(args: SelectSubset<T, IntegrationSessionCreateArgs<ExtArgs>>): Prisma__IntegrationSessionClient<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many IntegrationSessions.
     * @param {IntegrationSessionCreateManyArgs} args - Arguments to create many IntegrationSessions.
     * @example
     * // Create many IntegrationSessions
     * const integrationSession = await prisma.integrationSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationSessionCreateManyArgs>(args?: SelectSubset<T, IntegrationSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IntegrationSession.
     * @param {IntegrationSessionDeleteArgs} args - Arguments to delete one IntegrationSession.
     * @example
     * // Delete one IntegrationSession
     * const IntegrationSession = await prisma.integrationSession.delete({
     *   where: {
     *     // ... filter to delete one IntegrationSession
     *   }
     * })
     * 
     */
    delete<T extends IntegrationSessionDeleteArgs>(args: SelectSubset<T, IntegrationSessionDeleteArgs<ExtArgs>>): Prisma__IntegrationSessionClient<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one IntegrationSession.
     * @param {IntegrationSessionUpdateArgs} args - Arguments to update one IntegrationSession.
     * @example
     * // Update one IntegrationSession
     * const integrationSession = await prisma.integrationSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationSessionUpdateArgs>(args: SelectSubset<T, IntegrationSessionUpdateArgs<ExtArgs>>): Prisma__IntegrationSessionClient<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more IntegrationSessions.
     * @param {IntegrationSessionDeleteManyArgs} args - Arguments to filter IntegrationSessions to delete.
     * @example
     * // Delete a few IntegrationSessions
     * const { count } = await prisma.integrationSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationSessionDeleteManyArgs>(args?: SelectSubset<T, IntegrationSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntegrationSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntegrationSessions
     * const integrationSession = await prisma.integrationSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationSessionUpdateManyArgs>(args: SelectSubset<T, IntegrationSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IntegrationSession.
     * @param {IntegrationSessionUpsertArgs} args - Arguments to update or create a IntegrationSession.
     * @example
     * // Update or create a IntegrationSession
     * const integrationSession = await prisma.integrationSession.upsert({
     *   create: {
     *     // ... data to create a IntegrationSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntegrationSession we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationSessionUpsertArgs>(args: SelectSubset<T, IntegrationSessionUpsertArgs<ExtArgs>>): Prisma__IntegrationSessionClient<$Result.GetResult<Prisma.$IntegrationSessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of IntegrationSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSessionCountArgs} args - Arguments to filter IntegrationSessions to count.
     * @example
     * // Count the number of IntegrationSessions
     * const count = await prisma.integrationSession.count({
     *   where: {
     *     // ... the filter for the IntegrationSessions we want to count
     *   }
     * })
    **/
    count<T extends IntegrationSessionCountArgs>(
      args?: Subset<T, IntegrationSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntegrationSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationSessionAggregateArgs>(args: Subset<T, IntegrationSessionAggregateArgs>): Prisma.PrismaPromise<GetIntegrationSessionAggregateType<T>>

    /**
     * Group by IntegrationSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationSessionGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntegrationSession model
   */
  readonly fields: IntegrationSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntegrationSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Message<T extends IntegrationSession$MessageArgs<ExtArgs> = {}>(args?: Subset<T, IntegrationSession$MessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntegrationSession model
   */ 
  interface IntegrationSessionFieldRefs {
    readonly id: FieldRef<"IntegrationSession", 'String'>
    readonly sessionId: FieldRef<"IntegrationSession", 'String'>
    readonly remoteJid: FieldRef<"IntegrationSession", 'String'>
    readonly pushName: FieldRef<"IntegrationSession", 'String'>
    readonly status: FieldRef<"IntegrationSession", 'SessionStatus'>
    readonly awaitUser: FieldRef<"IntegrationSession", 'Boolean'>
    readonly context: FieldRef<"IntegrationSession", 'Json'>
    readonly type: FieldRef<"IntegrationSession", 'String'>
    readonly createdAt: FieldRef<"IntegrationSession", 'DateTime'>
    readonly updatedAt: FieldRef<"IntegrationSession", 'DateTime'>
    readonly instanceId: FieldRef<"IntegrationSession", 'String'>
    readonly parameters: FieldRef<"IntegrationSession", 'Json'>
    readonly botId: FieldRef<"IntegrationSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IntegrationSession findUnique
   */
  export type IntegrationSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSession to fetch.
     */
    where: IntegrationSessionWhereUniqueInput
  }

  /**
   * IntegrationSession findUniqueOrThrow
   */
  export type IntegrationSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSession to fetch.
     */
    where: IntegrationSessionWhereUniqueInput
  }

  /**
   * IntegrationSession findFirst
   */
  export type IntegrationSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSession to fetch.
     */
    where?: IntegrationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationSessions to fetch.
     */
    orderBy?: IntegrationSessionOrderByWithRelationInput | IntegrationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationSessions.
     */
    cursor?: IntegrationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationSessions.
     */
    distinct?: IntegrationSessionScalarFieldEnum | IntegrationSessionScalarFieldEnum[]
  }

  /**
   * IntegrationSession findFirstOrThrow
   */
  export type IntegrationSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSession to fetch.
     */
    where?: IntegrationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationSessions to fetch.
     */
    orderBy?: IntegrationSessionOrderByWithRelationInput | IntegrationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntegrationSessions.
     */
    cursor?: IntegrationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntegrationSessions.
     */
    distinct?: IntegrationSessionScalarFieldEnum | IntegrationSessionScalarFieldEnum[]
  }

  /**
   * IntegrationSession findMany
   */
  export type IntegrationSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    /**
     * Filter, which IntegrationSessions to fetch.
     */
    where?: IntegrationSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntegrationSessions to fetch.
     */
    orderBy?: IntegrationSessionOrderByWithRelationInput | IntegrationSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntegrationSessions.
     */
    cursor?: IntegrationSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntegrationSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntegrationSessions.
     */
    skip?: number
    distinct?: IntegrationSessionScalarFieldEnum | IntegrationSessionScalarFieldEnum[]
  }

  /**
   * IntegrationSession create
   */
  export type IntegrationSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a IntegrationSession.
     */
    data: XOR<IntegrationSessionCreateInput, IntegrationSessionUncheckedCreateInput>
  }

  /**
   * IntegrationSession createMany
   */
  export type IntegrationSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntegrationSessions.
     */
    data: IntegrationSessionCreateManyInput | IntegrationSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntegrationSession update
   */
  export type IntegrationSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a IntegrationSession.
     */
    data: XOR<IntegrationSessionUpdateInput, IntegrationSessionUncheckedUpdateInput>
    /**
     * Choose, which IntegrationSession to update.
     */
    where: IntegrationSessionWhereUniqueInput
  }

  /**
   * IntegrationSession updateMany
   */
  export type IntegrationSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntegrationSessions.
     */
    data: XOR<IntegrationSessionUpdateManyMutationInput, IntegrationSessionUncheckedUpdateManyInput>
    /**
     * Filter which IntegrationSessions to update
     */
    where?: IntegrationSessionWhereInput
    /**
     * Limit how many IntegrationSessions to update.
     */
    limit?: number
  }

  /**
   * IntegrationSession upsert
   */
  export type IntegrationSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the IntegrationSession to update in case it exists.
     */
    where: IntegrationSessionWhereUniqueInput
    /**
     * In case the IntegrationSession found by the `where` argument doesn't exist, create a new IntegrationSession with this data.
     */
    create: XOR<IntegrationSessionCreateInput, IntegrationSessionUncheckedCreateInput>
    /**
     * In case the IntegrationSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationSessionUpdateInput, IntegrationSessionUncheckedUpdateInput>
  }

  /**
   * IntegrationSession delete
   */
  export type IntegrationSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
    /**
     * Filter which IntegrationSession to delete.
     */
    where: IntegrationSessionWhereUniqueInput
  }

  /**
   * IntegrationSession deleteMany
   */
  export type IntegrationSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntegrationSessions to delete
     */
    where?: IntegrationSessionWhereInput
    /**
     * Limit how many IntegrationSessions to delete.
     */
    limit?: number
  }

  /**
   * IntegrationSession.Message
   */
  export type IntegrationSession$MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * IntegrationSession without action
   */
  export type IntegrationSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegrationSession
     */
    select?: IntegrationSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntegrationSession
     */
    omit?: IntegrationSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationSessionInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    type: string | null
    mimetype: string | null
    createdAt: Date | null
    messageId: string | null
    instanceId: string | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    type: string | null
    mimetype: string | null
    createdAt: Date | null
    messageId: string | null
    instanceId: string | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    fileName: number
    type: number
    mimetype: number
    createdAt: number
    messageId: number
    instanceId: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    fileName?: true
    type?: true
    mimetype?: true
    createdAt?: true
    messageId?: true
    instanceId?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    fileName?: true
    type?: true
    mimetype?: true
    createdAt?: true
    messageId?: true
    instanceId?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    fileName?: true
    type?: true
    mimetype?: true
    createdAt?: true
    messageId?: true
    instanceId?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    fileName: string
    type: string
    mimetype: string
    createdAt: Date | null
    messageId: string
    instanceId: string
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    type?: boolean
    mimetype?: boolean
    createdAt?: boolean
    messageId?: boolean
    instanceId?: boolean
    Message?: boolean | MessageDefaultArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>



  export type MediaSelectScalar = {
    id?: boolean
    fileName?: boolean
    type?: boolean
    mimetype?: boolean
    createdAt?: boolean
    messageId?: boolean
    instanceId?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileName" | "type" | "mimetype" | "createdAt" | "messageId" | "instanceId", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Message?: boolean | MessageDefaultArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      Message: Prisma.$MessagePayload<ExtArgs>
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      type: string
      mimetype: string
      createdAt: Date | null
      messageId: string
      instanceId: string
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly fileName: FieldRef<"Media", 'String'>
    readonly type: FieldRef<"Media", 'String'>
    readonly mimetype: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly messageId: FieldRef<"Media", 'String'>
    readonly instanceId: FieldRef<"Media", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model OpenaiCreds
   */

  export type AggregateOpenaiCreds = {
    _count: OpenaiCredsCountAggregateOutputType | null
    _min: OpenaiCredsMinAggregateOutputType | null
    _max: OpenaiCredsMaxAggregateOutputType | null
  }

  export type OpenaiCredsMinAggregateOutputType = {
    id: string | null
    name: string | null
    apiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type OpenaiCredsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    apiKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type OpenaiCredsCountAggregateOutputType = {
    id: number
    name: number
    apiKey: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type OpenaiCredsMinAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type OpenaiCredsMaxAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type OpenaiCredsCountAggregateInputType = {
    id?: true
    name?: true
    apiKey?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type OpenaiCredsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenaiCreds to aggregate.
     */
    where?: OpenaiCredsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiCreds to fetch.
     */
    orderBy?: OpenaiCredsOrderByWithRelationInput | OpenaiCredsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenaiCredsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiCreds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiCreds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenaiCreds
    **/
    _count?: true | OpenaiCredsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenaiCredsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenaiCredsMaxAggregateInputType
  }

  export type GetOpenaiCredsAggregateType<T extends OpenaiCredsAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenaiCreds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenaiCreds[P]>
      : GetScalarType<T[P], AggregateOpenaiCreds[P]>
  }




  export type OpenaiCredsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenaiCredsWhereInput
    orderBy?: OpenaiCredsOrderByWithAggregationInput | OpenaiCredsOrderByWithAggregationInput[]
    by: OpenaiCredsScalarFieldEnum[] | OpenaiCredsScalarFieldEnum
    having?: OpenaiCredsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenaiCredsCountAggregateInputType | true
    _min?: OpenaiCredsMinAggregateInputType
    _max?: OpenaiCredsMaxAggregateInputType
  }

  export type OpenaiCredsGroupByOutputType = {
    id: string
    name: string | null
    apiKey: string | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: OpenaiCredsCountAggregateOutputType | null
    _min: OpenaiCredsMinAggregateOutputType | null
    _max: OpenaiCredsMaxAggregateOutputType | null
  }

  type GetOpenaiCredsGroupByPayload<T extends OpenaiCredsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenaiCredsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenaiCredsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenaiCredsGroupByOutputType[P]>
            : GetScalarType<T[P], OpenaiCredsGroupByOutputType[P]>
        }
      >
    >


  export type OpenaiCredsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    OpenaiAssistant?: boolean | OpenaiCreds$OpenaiAssistantArgs<ExtArgs>
    OpenaiSetting?: boolean | OpenaiCreds$OpenaiSettingArgs<ExtArgs>
    _count?: boolean | OpenaiCredsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openaiCreds"]>



  export type OpenaiCredsSelectScalar = {
    id?: boolean
    name?: boolean
    apiKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type OpenaiCredsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "apiKey" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["openaiCreds"]>
  export type OpenaiCredsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    OpenaiAssistant?: boolean | OpenaiCreds$OpenaiAssistantArgs<ExtArgs>
    OpenaiSetting?: boolean | OpenaiCreds$OpenaiSettingArgs<ExtArgs>
    _count?: boolean | OpenaiCredsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OpenaiCredsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenaiCreds"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
      OpenaiAssistant: Prisma.$OpenaiBotPayload<ExtArgs>[]
      OpenaiSetting: Prisma.$OpenaiSettingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      apiKey: string | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["openaiCreds"]>
    composites: {}
  }

  type OpenaiCredsGetPayload<S extends boolean | null | undefined | OpenaiCredsDefaultArgs> = $Result.GetResult<Prisma.$OpenaiCredsPayload, S>

  type OpenaiCredsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpenaiCredsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpenaiCredsCountAggregateInputType | true
    }

  export interface OpenaiCredsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenaiCreds'], meta: { name: 'OpenaiCreds' } }
    /**
     * Find zero or one OpenaiCreds that matches the filter.
     * @param {OpenaiCredsFindUniqueArgs} args - Arguments to find a OpenaiCreds
     * @example
     * // Get one OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenaiCredsFindUniqueArgs>(args: SelectSubset<T, OpenaiCredsFindUniqueArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OpenaiCreds that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpenaiCredsFindUniqueOrThrowArgs} args - Arguments to find a OpenaiCreds
     * @example
     * // Get one OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenaiCredsFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenaiCredsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OpenaiCreds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiCredsFindFirstArgs} args - Arguments to find a OpenaiCreds
     * @example
     * // Get one OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenaiCredsFindFirstArgs>(args?: SelectSubset<T, OpenaiCredsFindFirstArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OpenaiCreds that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiCredsFindFirstOrThrowArgs} args - Arguments to find a OpenaiCreds
     * @example
     * // Get one OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenaiCredsFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenaiCredsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OpenaiCreds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiCredsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.findMany()
     * 
     * // Get first 10 OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openaiCredsWithIdOnly = await prisma.openaiCreds.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpenaiCredsFindManyArgs>(args?: SelectSubset<T, OpenaiCredsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OpenaiCreds.
     * @param {OpenaiCredsCreateArgs} args - Arguments to create a OpenaiCreds.
     * @example
     * // Create one OpenaiCreds
     * const OpenaiCreds = await prisma.openaiCreds.create({
     *   data: {
     *     // ... data to create a OpenaiCreds
     *   }
     * })
     * 
     */
    create<T extends OpenaiCredsCreateArgs>(args: SelectSubset<T, OpenaiCredsCreateArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OpenaiCreds.
     * @param {OpenaiCredsCreateManyArgs} args - Arguments to create many OpenaiCreds.
     * @example
     * // Create many OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenaiCredsCreateManyArgs>(args?: SelectSubset<T, OpenaiCredsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OpenaiCreds.
     * @param {OpenaiCredsDeleteArgs} args - Arguments to delete one OpenaiCreds.
     * @example
     * // Delete one OpenaiCreds
     * const OpenaiCreds = await prisma.openaiCreds.delete({
     *   where: {
     *     // ... filter to delete one OpenaiCreds
     *   }
     * })
     * 
     */
    delete<T extends OpenaiCredsDeleteArgs>(args: SelectSubset<T, OpenaiCredsDeleteArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OpenaiCreds.
     * @param {OpenaiCredsUpdateArgs} args - Arguments to update one OpenaiCreds.
     * @example
     * // Update one OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenaiCredsUpdateArgs>(args: SelectSubset<T, OpenaiCredsUpdateArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OpenaiCreds.
     * @param {OpenaiCredsDeleteManyArgs} args - Arguments to filter OpenaiCreds to delete.
     * @example
     * // Delete a few OpenaiCreds
     * const { count } = await prisma.openaiCreds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenaiCredsDeleteManyArgs>(args?: SelectSubset<T, OpenaiCredsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenaiCreds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiCredsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenaiCredsUpdateManyArgs>(args: SelectSubset<T, OpenaiCredsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OpenaiCreds.
     * @param {OpenaiCredsUpsertArgs} args - Arguments to update or create a OpenaiCreds.
     * @example
     * // Update or create a OpenaiCreds
     * const openaiCreds = await prisma.openaiCreds.upsert({
     *   create: {
     *     // ... data to create a OpenaiCreds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenaiCreds we want to update
     *   }
     * })
     */
    upsert<T extends OpenaiCredsUpsertArgs>(args: SelectSubset<T, OpenaiCredsUpsertArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OpenaiCreds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiCredsCountArgs} args - Arguments to filter OpenaiCreds to count.
     * @example
     * // Count the number of OpenaiCreds
     * const count = await prisma.openaiCreds.count({
     *   where: {
     *     // ... the filter for the OpenaiCreds we want to count
     *   }
     * })
    **/
    count<T extends OpenaiCredsCountArgs>(
      args?: Subset<T, OpenaiCredsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenaiCredsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenaiCreds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiCredsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenaiCredsAggregateArgs>(args: Subset<T, OpenaiCredsAggregateArgs>): Prisma.PrismaPromise<GetOpenaiCredsAggregateType<T>>

    /**
     * Group by OpenaiCreds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiCredsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenaiCredsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenaiCredsGroupByArgs['orderBy'] }
        : { orderBy?: OpenaiCredsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenaiCredsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenaiCredsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenaiCreds model
   */
  readonly fields: OpenaiCredsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenaiCreds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenaiCredsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    OpenaiAssistant<T extends OpenaiCreds$OpenaiAssistantArgs<ExtArgs> = {}>(args?: Subset<T, OpenaiCreds$OpenaiAssistantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    OpenaiSetting<T extends OpenaiCreds$OpenaiSettingArgs<ExtArgs> = {}>(args?: Subset<T, OpenaiCreds$OpenaiSettingArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenaiCreds model
   */ 
  interface OpenaiCredsFieldRefs {
    readonly id: FieldRef<"OpenaiCreds", 'String'>
    readonly name: FieldRef<"OpenaiCreds", 'String'>
    readonly apiKey: FieldRef<"OpenaiCreds", 'String'>
    readonly createdAt: FieldRef<"OpenaiCreds", 'DateTime'>
    readonly updatedAt: FieldRef<"OpenaiCreds", 'DateTime'>
    readonly instanceId: FieldRef<"OpenaiCreds", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OpenaiCreds findUnique
   */
  export type OpenaiCredsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiCreds to fetch.
     */
    where: OpenaiCredsWhereUniqueInput
  }

  /**
   * OpenaiCreds findUniqueOrThrow
   */
  export type OpenaiCredsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiCreds to fetch.
     */
    where: OpenaiCredsWhereUniqueInput
  }

  /**
   * OpenaiCreds findFirst
   */
  export type OpenaiCredsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiCreds to fetch.
     */
    where?: OpenaiCredsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiCreds to fetch.
     */
    orderBy?: OpenaiCredsOrderByWithRelationInput | OpenaiCredsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenaiCreds.
     */
    cursor?: OpenaiCredsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiCreds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiCreds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenaiCreds.
     */
    distinct?: OpenaiCredsScalarFieldEnum | OpenaiCredsScalarFieldEnum[]
  }

  /**
   * OpenaiCreds findFirstOrThrow
   */
  export type OpenaiCredsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiCreds to fetch.
     */
    where?: OpenaiCredsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiCreds to fetch.
     */
    orderBy?: OpenaiCredsOrderByWithRelationInput | OpenaiCredsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenaiCreds.
     */
    cursor?: OpenaiCredsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiCreds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiCreds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenaiCreds.
     */
    distinct?: OpenaiCredsScalarFieldEnum | OpenaiCredsScalarFieldEnum[]
  }

  /**
   * OpenaiCreds findMany
   */
  export type OpenaiCredsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiCreds to fetch.
     */
    where?: OpenaiCredsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiCreds to fetch.
     */
    orderBy?: OpenaiCredsOrderByWithRelationInput | OpenaiCredsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenaiCreds.
     */
    cursor?: OpenaiCredsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiCreds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiCreds.
     */
    skip?: number
    distinct?: OpenaiCredsScalarFieldEnum | OpenaiCredsScalarFieldEnum[]
  }

  /**
   * OpenaiCreds create
   */
  export type OpenaiCredsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    /**
     * The data needed to create a OpenaiCreds.
     */
    data: XOR<OpenaiCredsCreateInput, OpenaiCredsUncheckedCreateInput>
  }

  /**
   * OpenaiCreds createMany
   */
  export type OpenaiCredsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenaiCreds.
     */
    data: OpenaiCredsCreateManyInput | OpenaiCredsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenaiCreds update
   */
  export type OpenaiCredsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    /**
     * The data needed to update a OpenaiCreds.
     */
    data: XOR<OpenaiCredsUpdateInput, OpenaiCredsUncheckedUpdateInput>
    /**
     * Choose, which OpenaiCreds to update.
     */
    where: OpenaiCredsWhereUniqueInput
  }

  /**
   * OpenaiCreds updateMany
   */
  export type OpenaiCredsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenaiCreds.
     */
    data: XOR<OpenaiCredsUpdateManyMutationInput, OpenaiCredsUncheckedUpdateManyInput>
    /**
     * Filter which OpenaiCreds to update
     */
    where?: OpenaiCredsWhereInput
    /**
     * Limit how many OpenaiCreds to update.
     */
    limit?: number
  }

  /**
   * OpenaiCreds upsert
   */
  export type OpenaiCredsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    /**
     * The filter to search for the OpenaiCreds to update in case it exists.
     */
    where: OpenaiCredsWhereUniqueInput
    /**
     * In case the OpenaiCreds found by the `where` argument doesn't exist, create a new OpenaiCreds with this data.
     */
    create: XOR<OpenaiCredsCreateInput, OpenaiCredsUncheckedCreateInput>
    /**
     * In case the OpenaiCreds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenaiCredsUpdateInput, OpenaiCredsUncheckedUpdateInput>
  }

  /**
   * OpenaiCreds delete
   */
  export type OpenaiCredsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    /**
     * Filter which OpenaiCreds to delete.
     */
    where: OpenaiCredsWhereUniqueInput
  }

  /**
   * OpenaiCreds deleteMany
   */
  export type OpenaiCredsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenaiCreds to delete
     */
    where?: OpenaiCredsWhereInput
    /**
     * Limit how many OpenaiCreds to delete.
     */
    limit?: number
  }

  /**
   * OpenaiCreds.OpenaiAssistant
   */
  export type OpenaiCreds$OpenaiAssistantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    where?: OpenaiBotWhereInput
    orderBy?: OpenaiBotOrderByWithRelationInput | OpenaiBotOrderByWithRelationInput[]
    cursor?: OpenaiBotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpenaiBotScalarFieldEnum | OpenaiBotScalarFieldEnum[]
  }

  /**
   * OpenaiCreds.OpenaiSetting
   */
  export type OpenaiCreds$OpenaiSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    where?: OpenaiSettingWhereInput
  }

  /**
   * OpenaiCreds without action
   */
  export type OpenaiCredsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
  }


  /**
   * Model OpenaiBot
   */

  export type AggregateOpenaiBot = {
    _count: OpenaiBotCountAggregateOutputType | null
    _avg: OpenaiBotAvgAggregateOutputType | null
    _sum: OpenaiBotSumAggregateOutputType | null
    _min: OpenaiBotMinAggregateOutputType | null
    _max: OpenaiBotMaxAggregateOutputType | null
  }

  export type OpenaiBotAvgAggregateOutputType = {
    maxTokens: number | null
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type OpenaiBotSumAggregateOutputType = {
    maxTokens: number | null
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type OpenaiBotMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    botType: $Enums.OpenaiBotType | null
    assistantId: string | null
    functionUrl: string | null
    model: string | null
    maxTokens: number | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    openaiCredsId: string | null
    instanceId: string | null
  }

  export type OpenaiBotMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    botType: $Enums.OpenaiBotType | null
    assistantId: string | null
    functionUrl: string | null
    model: string | null
    maxTokens: number | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    openaiCredsId: string | null
    instanceId: string | null
  }

  export type OpenaiBotCountAggregateOutputType = {
    id: number
    enabled: number
    description: number
    botType: number
    assistantId: number
    functionUrl: number
    model: number
    systemMessages: number
    assistantMessages: number
    userMessages: number
    maxTokens: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    ignoreJids: number
    splitMessages: number
    timePerChar: number
    triggerType: number
    triggerOperator: number
    triggerValue: number
    createdAt: number
    updatedAt: number
    openaiCredsId: number
    instanceId: number
    _all: number
  }


  export type OpenaiBotAvgAggregateInputType = {
    maxTokens?: true
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type OpenaiBotSumAggregateInputType = {
    maxTokens?: true
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type OpenaiBotMinAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    botType?: true
    assistantId?: true
    functionUrl?: true
    model?: true
    maxTokens?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    openaiCredsId?: true
    instanceId?: true
  }

  export type OpenaiBotMaxAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    botType?: true
    assistantId?: true
    functionUrl?: true
    model?: true
    maxTokens?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    openaiCredsId?: true
    instanceId?: true
  }

  export type OpenaiBotCountAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    botType?: true
    assistantId?: true
    functionUrl?: true
    model?: true
    systemMessages?: true
    assistantMessages?: true
    userMessages?: true
    maxTokens?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    ignoreJids?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    openaiCredsId?: true
    instanceId?: true
    _all?: true
  }

  export type OpenaiBotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenaiBot to aggregate.
     */
    where?: OpenaiBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiBots to fetch.
     */
    orderBy?: OpenaiBotOrderByWithRelationInput | OpenaiBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenaiBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenaiBots
    **/
    _count?: true | OpenaiBotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpenaiBotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpenaiBotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenaiBotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenaiBotMaxAggregateInputType
  }

  export type GetOpenaiBotAggregateType<T extends OpenaiBotAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenaiBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenaiBot[P]>
      : GetScalarType<T[P], AggregateOpenaiBot[P]>
  }




  export type OpenaiBotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenaiBotWhereInput
    orderBy?: OpenaiBotOrderByWithAggregationInput | OpenaiBotOrderByWithAggregationInput[]
    by: OpenaiBotScalarFieldEnum[] | OpenaiBotScalarFieldEnum
    having?: OpenaiBotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenaiBotCountAggregateInputType | true
    _avg?: OpenaiBotAvgAggregateInputType
    _sum?: OpenaiBotSumAggregateInputType
    _min?: OpenaiBotMinAggregateInputType
    _max?: OpenaiBotMaxAggregateInputType
  }

  export type OpenaiBotGroupByOutputType = {
    id: string
    enabled: boolean
    description: string | null
    botType: $Enums.OpenaiBotType
    assistantId: string | null
    functionUrl: string | null
    model: string | null
    systemMessages: JsonValue | null
    assistantMessages: JsonValue | null
    userMessages: JsonValue | null
    maxTokens: number | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    ignoreJids: JsonValue | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date
    openaiCredsId: string
    instanceId: string
    _count: OpenaiBotCountAggregateOutputType | null
    _avg: OpenaiBotAvgAggregateOutputType | null
    _sum: OpenaiBotSumAggregateOutputType | null
    _min: OpenaiBotMinAggregateOutputType | null
    _max: OpenaiBotMaxAggregateOutputType | null
  }

  type GetOpenaiBotGroupByPayload<T extends OpenaiBotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenaiBotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenaiBotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenaiBotGroupByOutputType[P]>
            : GetScalarType<T[P], OpenaiBotGroupByOutputType[P]>
        }
      >
    >


  export type OpenaiBotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    description?: boolean
    botType?: boolean
    assistantId?: boolean
    functionUrl?: boolean
    model?: boolean
    systemMessages?: boolean
    assistantMessages?: boolean
    userMessages?: boolean
    maxTokens?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    openaiCredsId?: boolean
    instanceId?: boolean
    OpenaiCreds?: boolean | OpenaiCredsDefaultArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    OpenaiSetting?: boolean | OpenaiBot$OpenaiSettingArgs<ExtArgs>
    _count?: boolean | OpenaiBotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openaiBot"]>



  export type OpenaiBotSelectScalar = {
    id?: boolean
    enabled?: boolean
    description?: boolean
    botType?: boolean
    assistantId?: boolean
    functionUrl?: boolean
    model?: boolean
    systemMessages?: boolean
    assistantMessages?: boolean
    userMessages?: boolean
    maxTokens?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    openaiCredsId?: boolean
    instanceId?: boolean
  }

  export type OpenaiBotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "description" | "botType" | "assistantId" | "functionUrl" | "model" | "systemMessages" | "assistantMessages" | "userMessages" | "maxTokens" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "ignoreJids" | "splitMessages" | "timePerChar" | "triggerType" | "triggerOperator" | "triggerValue" | "createdAt" | "updatedAt" | "openaiCredsId" | "instanceId", ExtArgs["result"]["openaiBot"]>
  export type OpenaiBotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OpenaiCreds?: boolean | OpenaiCredsDefaultArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    OpenaiSetting?: boolean | OpenaiBot$OpenaiSettingArgs<ExtArgs>
    _count?: boolean | OpenaiBotCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OpenaiBotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenaiBot"
    objects: {
      OpenaiCreds: Prisma.$OpenaiCredsPayload<ExtArgs>
      Instance: Prisma.$InstancePayload<ExtArgs>
      OpenaiSetting: Prisma.$OpenaiSettingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      description: string | null
      botType: $Enums.OpenaiBotType
      assistantId: string | null
      functionUrl: string | null
      model: string | null
      systemMessages: Prisma.JsonValue | null
      assistantMessages: Prisma.JsonValue | null
      userMessages: Prisma.JsonValue | null
      maxTokens: number | null
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      ignoreJids: Prisma.JsonValue | null
      splitMessages: boolean | null
      timePerChar: number | null
      triggerType: $Enums.TriggerType | null
      triggerOperator: $Enums.TriggerOperator | null
      triggerValue: string | null
      createdAt: Date | null
      updatedAt: Date
      openaiCredsId: string
      instanceId: string
    }, ExtArgs["result"]["openaiBot"]>
    composites: {}
  }

  type OpenaiBotGetPayload<S extends boolean | null | undefined | OpenaiBotDefaultArgs> = $Result.GetResult<Prisma.$OpenaiBotPayload, S>

  type OpenaiBotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpenaiBotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpenaiBotCountAggregateInputType | true
    }

  export interface OpenaiBotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenaiBot'], meta: { name: 'OpenaiBot' } }
    /**
     * Find zero or one OpenaiBot that matches the filter.
     * @param {OpenaiBotFindUniqueArgs} args - Arguments to find a OpenaiBot
     * @example
     * // Get one OpenaiBot
     * const openaiBot = await prisma.openaiBot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenaiBotFindUniqueArgs>(args: SelectSubset<T, OpenaiBotFindUniqueArgs<ExtArgs>>): Prisma__OpenaiBotClient<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OpenaiBot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpenaiBotFindUniqueOrThrowArgs} args - Arguments to find a OpenaiBot
     * @example
     * // Get one OpenaiBot
     * const openaiBot = await prisma.openaiBot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenaiBotFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenaiBotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenaiBotClient<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OpenaiBot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiBotFindFirstArgs} args - Arguments to find a OpenaiBot
     * @example
     * // Get one OpenaiBot
     * const openaiBot = await prisma.openaiBot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenaiBotFindFirstArgs>(args?: SelectSubset<T, OpenaiBotFindFirstArgs<ExtArgs>>): Prisma__OpenaiBotClient<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OpenaiBot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiBotFindFirstOrThrowArgs} args - Arguments to find a OpenaiBot
     * @example
     * // Get one OpenaiBot
     * const openaiBot = await prisma.openaiBot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenaiBotFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenaiBotFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenaiBotClient<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OpenaiBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiBotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenaiBots
     * const openaiBots = await prisma.openaiBot.findMany()
     * 
     * // Get first 10 OpenaiBots
     * const openaiBots = await prisma.openaiBot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openaiBotWithIdOnly = await prisma.openaiBot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpenaiBotFindManyArgs>(args?: SelectSubset<T, OpenaiBotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OpenaiBot.
     * @param {OpenaiBotCreateArgs} args - Arguments to create a OpenaiBot.
     * @example
     * // Create one OpenaiBot
     * const OpenaiBot = await prisma.openaiBot.create({
     *   data: {
     *     // ... data to create a OpenaiBot
     *   }
     * })
     * 
     */
    create<T extends OpenaiBotCreateArgs>(args: SelectSubset<T, OpenaiBotCreateArgs<ExtArgs>>): Prisma__OpenaiBotClient<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OpenaiBots.
     * @param {OpenaiBotCreateManyArgs} args - Arguments to create many OpenaiBots.
     * @example
     * // Create many OpenaiBots
     * const openaiBot = await prisma.openaiBot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenaiBotCreateManyArgs>(args?: SelectSubset<T, OpenaiBotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OpenaiBot.
     * @param {OpenaiBotDeleteArgs} args - Arguments to delete one OpenaiBot.
     * @example
     * // Delete one OpenaiBot
     * const OpenaiBot = await prisma.openaiBot.delete({
     *   where: {
     *     // ... filter to delete one OpenaiBot
     *   }
     * })
     * 
     */
    delete<T extends OpenaiBotDeleteArgs>(args: SelectSubset<T, OpenaiBotDeleteArgs<ExtArgs>>): Prisma__OpenaiBotClient<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OpenaiBot.
     * @param {OpenaiBotUpdateArgs} args - Arguments to update one OpenaiBot.
     * @example
     * // Update one OpenaiBot
     * const openaiBot = await prisma.openaiBot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenaiBotUpdateArgs>(args: SelectSubset<T, OpenaiBotUpdateArgs<ExtArgs>>): Prisma__OpenaiBotClient<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OpenaiBots.
     * @param {OpenaiBotDeleteManyArgs} args - Arguments to filter OpenaiBots to delete.
     * @example
     * // Delete a few OpenaiBots
     * const { count } = await prisma.openaiBot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenaiBotDeleteManyArgs>(args?: SelectSubset<T, OpenaiBotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenaiBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiBotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenaiBots
     * const openaiBot = await prisma.openaiBot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenaiBotUpdateManyArgs>(args: SelectSubset<T, OpenaiBotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OpenaiBot.
     * @param {OpenaiBotUpsertArgs} args - Arguments to update or create a OpenaiBot.
     * @example
     * // Update or create a OpenaiBot
     * const openaiBot = await prisma.openaiBot.upsert({
     *   create: {
     *     // ... data to create a OpenaiBot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenaiBot we want to update
     *   }
     * })
     */
    upsert<T extends OpenaiBotUpsertArgs>(args: SelectSubset<T, OpenaiBotUpsertArgs<ExtArgs>>): Prisma__OpenaiBotClient<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OpenaiBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiBotCountArgs} args - Arguments to filter OpenaiBots to count.
     * @example
     * // Count the number of OpenaiBots
     * const count = await prisma.openaiBot.count({
     *   where: {
     *     // ... the filter for the OpenaiBots we want to count
     *   }
     * })
    **/
    count<T extends OpenaiBotCountArgs>(
      args?: Subset<T, OpenaiBotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenaiBotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenaiBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiBotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenaiBotAggregateArgs>(args: Subset<T, OpenaiBotAggregateArgs>): Prisma.PrismaPromise<GetOpenaiBotAggregateType<T>>

    /**
     * Group by OpenaiBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiBotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenaiBotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenaiBotGroupByArgs['orderBy'] }
        : { orderBy?: OpenaiBotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenaiBotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenaiBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenaiBot model
   */
  readonly fields: OpenaiBotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenaiBot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenaiBotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OpenaiCreds<T extends OpenaiCredsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpenaiCredsDefaultArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    OpenaiSetting<T extends OpenaiBot$OpenaiSettingArgs<ExtArgs> = {}>(args?: Subset<T, OpenaiBot$OpenaiSettingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenaiBot model
   */ 
  interface OpenaiBotFieldRefs {
    readonly id: FieldRef<"OpenaiBot", 'String'>
    readonly enabled: FieldRef<"OpenaiBot", 'Boolean'>
    readonly description: FieldRef<"OpenaiBot", 'String'>
    readonly botType: FieldRef<"OpenaiBot", 'OpenaiBotType'>
    readonly assistantId: FieldRef<"OpenaiBot", 'String'>
    readonly functionUrl: FieldRef<"OpenaiBot", 'String'>
    readonly model: FieldRef<"OpenaiBot", 'String'>
    readonly systemMessages: FieldRef<"OpenaiBot", 'Json'>
    readonly assistantMessages: FieldRef<"OpenaiBot", 'Json'>
    readonly userMessages: FieldRef<"OpenaiBot", 'Json'>
    readonly maxTokens: FieldRef<"OpenaiBot", 'Int'>
    readonly expire: FieldRef<"OpenaiBot", 'Int'>
    readonly keywordFinish: FieldRef<"OpenaiBot", 'String'>
    readonly delayMessage: FieldRef<"OpenaiBot", 'Int'>
    readonly unknownMessage: FieldRef<"OpenaiBot", 'String'>
    readonly listeningFromMe: FieldRef<"OpenaiBot", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"OpenaiBot", 'Boolean'>
    readonly keepOpen: FieldRef<"OpenaiBot", 'Boolean'>
    readonly debounceTime: FieldRef<"OpenaiBot", 'Int'>
    readonly ignoreJids: FieldRef<"OpenaiBot", 'Json'>
    readonly splitMessages: FieldRef<"OpenaiBot", 'Boolean'>
    readonly timePerChar: FieldRef<"OpenaiBot", 'Int'>
    readonly triggerType: FieldRef<"OpenaiBot", 'TriggerType'>
    readonly triggerOperator: FieldRef<"OpenaiBot", 'TriggerOperator'>
    readonly triggerValue: FieldRef<"OpenaiBot", 'String'>
    readonly createdAt: FieldRef<"OpenaiBot", 'DateTime'>
    readonly updatedAt: FieldRef<"OpenaiBot", 'DateTime'>
    readonly openaiCredsId: FieldRef<"OpenaiBot", 'String'>
    readonly instanceId: FieldRef<"OpenaiBot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OpenaiBot findUnique
   */
  export type OpenaiBotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiBot to fetch.
     */
    where: OpenaiBotWhereUniqueInput
  }

  /**
   * OpenaiBot findUniqueOrThrow
   */
  export type OpenaiBotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiBot to fetch.
     */
    where: OpenaiBotWhereUniqueInput
  }

  /**
   * OpenaiBot findFirst
   */
  export type OpenaiBotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiBot to fetch.
     */
    where?: OpenaiBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiBots to fetch.
     */
    orderBy?: OpenaiBotOrderByWithRelationInput | OpenaiBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenaiBots.
     */
    cursor?: OpenaiBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenaiBots.
     */
    distinct?: OpenaiBotScalarFieldEnum | OpenaiBotScalarFieldEnum[]
  }

  /**
   * OpenaiBot findFirstOrThrow
   */
  export type OpenaiBotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiBot to fetch.
     */
    where?: OpenaiBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiBots to fetch.
     */
    orderBy?: OpenaiBotOrderByWithRelationInput | OpenaiBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenaiBots.
     */
    cursor?: OpenaiBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenaiBots.
     */
    distinct?: OpenaiBotScalarFieldEnum | OpenaiBotScalarFieldEnum[]
  }

  /**
   * OpenaiBot findMany
   */
  export type OpenaiBotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiBots to fetch.
     */
    where?: OpenaiBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiBots to fetch.
     */
    orderBy?: OpenaiBotOrderByWithRelationInput | OpenaiBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenaiBots.
     */
    cursor?: OpenaiBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiBots.
     */
    skip?: number
    distinct?: OpenaiBotScalarFieldEnum | OpenaiBotScalarFieldEnum[]
  }

  /**
   * OpenaiBot create
   */
  export type OpenaiBotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    /**
     * The data needed to create a OpenaiBot.
     */
    data: XOR<OpenaiBotCreateInput, OpenaiBotUncheckedCreateInput>
  }

  /**
   * OpenaiBot createMany
   */
  export type OpenaiBotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenaiBots.
     */
    data: OpenaiBotCreateManyInput | OpenaiBotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenaiBot update
   */
  export type OpenaiBotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    /**
     * The data needed to update a OpenaiBot.
     */
    data: XOR<OpenaiBotUpdateInput, OpenaiBotUncheckedUpdateInput>
    /**
     * Choose, which OpenaiBot to update.
     */
    where: OpenaiBotWhereUniqueInput
  }

  /**
   * OpenaiBot updateMany
   */
  export type OpenaiBotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenaiBots.
     */
    data: XOR<OpenaiBotUpdateManyMutationInput, OpenaiBotUncheckedUpdateManyInput>
    /**
     * Filter which OpenaiBots to update
     */
    where?: OpenaiBotWhereInput
    /**
     * Limit how many OpenaiBots to update.
     */
    limit?: number
  }

  /**
   * OpenaiBot upsert
   */
  export type OpenaiBotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    /**
     * The filter to search for the OpenaiBot to update in case it exists.
     */
    where: OpenaiBotWhereUniqueInput
    /**
     * In case the OpenaiBot found by the `where` argument doesn't exist, create a new OpenaiBot with this data.
     */
    create: XOR<OpenaiBotCreateInput, OpenaiBotUncheckedCreateInput>
    /**
     * In case the OpenaiBot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenaiBotUpdateInput, OpenaiBotUncheckedUpdateInput>
  }

  /**
   * OpenaiBot delete
   */
  export type OpenaiBotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    /**
     * Filter which OpenaiBot to delete.
     */
    where: OpenaiBotWhereUniqueInput
  }

  /**
   * OpenaiBot deleteMany
   */
  export type OpenaiBotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenaiBots to delete
     */
    where?: OpenaiBotWhereInput
    /**
     * Limit how many OpenaiBots to delete.
     */
    limit?: number
  }

  /**
   * OpenaiBot.OpenaiSetting
   */
  export type OpenaiBot$OpenaiSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    where?: OpenaiSettingWhereInput
    orderBy?: OpenaiSettingOrderByWithRelationInput | OpenaiSettingOrderByWithRelationInput[]
    cursor?: OpenaiSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpenaiSettingScalarFieldEnum | OpenaiSettingScalarFieldEnum[]
  }

  /**
   * OpenaiBot without action
   */
  export type OpenaiBotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
  }


  /**
   * Model OpenaiSetting
   */

  export type AggregateOpenaiSetting = {
    _count: OpenaiSettingCountAggregateOutputType | null
    _avg: OpenaiSettingAvgAggregateOutputType | null
    _sum: OpenaiSettingSumAggregateOutputType | null
    _min: OpenaiSettingMinAggregateOutputType | null
    _max: OpenaiSettingMaxAggregateOutputType | null
  }

  export type OpenaiSettingAvgAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type OpenaiSettingSumAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type OpenaiSettingMinAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    speechToText: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    openaiCredsId: string | null
    openaiIdFallback: string | null
    instanceId: string | null
  }

  export type OpenaiSettingMaxAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    speechToText: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    openaiCredsId: string | null
    openaiIdFallback: string | null
    instanceId: string | null
  }

  export type OpenaiSettingCountAggregateOutputType = {
    id: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    ignoreJids: number
    splitMessages: number
    timePerChar: number
    speechToText: number
    createdAt: number
    updatedAt: number
    openaiCredsId: number
    openaiIdFallback: number
    instanceId: number
    _all: number
  }


  export type OpenaiSettingAvgAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type OpenaiSettingSumAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type OpenaiSettingMinAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    speechToText?: true
    createdAt?: true
    updatedAt?: true
    openaiCredsId?: true
    openaiIdFallback?: true
    instanceId?: true
  }

  export type OpenaiSettingMaxAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    speechToText?: true
    createdAt?: true
    updatedAt?: true
    openaiCredsId?: true
    openaiIdFallback?: true
    instanceId?: true
  }

  export type OpenaiSettingCountAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    ignoreJids?: true
    splitMessages?: true
    timePerChar?: true
    speechToText?: true
    createdAt?: true
    updatedAt?: true
    openaiCredsId?: true
    openaiIdFallback?: true
    instanceId?: true
    _all?: true
  }

  export type OpenaiSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenaiSetting to aggregate.
     */
    where?: OpenaiSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiSettings to fetch.
     */
    orderBy?: OpenaiSettingOrderByWithRelationInput | OpenaiSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpenaiSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpenaiSettings
    **/
    _count?: true | OpenaiSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpenaiSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpenaiSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpenaiSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpenaiSettingMaxAggregateInputType
  }

  export type GetOpenaiSettingAggregateType<T extends OpenaiSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateOpenaiSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpenaiSetting[P]>
      : GetScalarType<T[P], AggregateOpenaiSetting[P]>
  }




  export type OpenaiSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpenaiSettingWhereInput
    orderBy?: OpenaiSettingOrderByWithAggregationInput | OpenaiSettingOrderByWithAggregationInput[]
    by: OpenaiSettingScalarFieldEnum[] | OpenaiSettingScalarFieldEnum
    having?: OpenaiSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpenaiSettingCountAggregateInputType | true
    _avg?: OpenaiSettingAvgAggregateInputType
    _sum?: OpenaiSettingSumAggregateInputType
    _min?: OpenaiSettingMinAggregateInputType
    _max?: OpenaiSettingMaxAggregateInputType
  }

  export type OpenaiSettingGroupByOutputType = {
    id: string
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    ignoreJids: JsonValue | null
    splitMessages: boolean | null
    timePerChar: number | null
    speechToText: boolean | null
    createdAt: Date | null
    updatedAt: Date
    openaiCredsId: string
    openaiIdFallback: string | null
    instanceId: string
    _count: OpenaiSettingCountAggregateOutputType | null
    _avg: OpenaiSettingAvgAggregateOutputType | null
    _sum: OpenaiSettingSumAggregateOutputType | null
    _min: OpenaiSettingMinAggregateOutputType | null
    _max: OpenaiSettingMaxAggregateOutputType | null
  }

  type GetOpenaiSettingGroupByPayload<T extends OpenaiSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpenaiSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpenaiSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpenaiSettingGroupByOutputType[P]>
            : GetScalarType<T[P], OpenaiSettingGroupByOutputType[P]>
        }
      >
    >


  export type OpenaiSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    speechToText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    openaiCredsId?: boolean
    openaiIdFallback?: boolean
    instanceId?: boolean
    OpenaiCreds?: boolean | OpenaiSetting$OpenaiCredsArgs<ExtArgs>
    Fallback?: boolean | OpenaiSetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["openaiSetting"]>



  export type OpenaiSettingSelectScalar = {
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    speechToText?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    openaiCredsId?: boolean
    openaiIdFallback?: boolean
    instanceId?: boolean
  }

  export type OpenaiSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "ignoreJids" | "splitMessages" | "timePerChar" | "speechToText" | "createdAt" | "updatedAt" | "openaiCredsId" | "openaiIdFallback" | "instanceId", ExtArgs["result"]["openaiSetting"]>
  export type OpenaiSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OpenaiCreds?: boolean | OpenaiSetting$OpenaiCredsArgs<ExtArgs>
    Fallback?: boolean | OpenaiSetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $OpenaiSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpenaiSetting"
    objects: {
      OpenaiCreds: Prisma.$OpenaiCredsPayload<ExtArgs> | null
      Fallback: Prisma.$OpenaiBotPayload<ExtArgs> | null
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      ignoreJids: Prisma.JsonValue | null
      splitMessages: boolean | null
      timePerChar: number | null
      speechToText: boolean | null
      createdAt: Date | null
      updatedAt: Date
      openaiCredsId: string
      openaiIdFallback: string | null
      instanceId: string
    }, ExtArgs["result"]["openaiSetting"]>
    composites: {}
  }

  type OpenaiSettingGetPayload<S extends boolean | null | undefined | OpenaiSettingDefaultArgs> = $Result.GetResult<Prisma.$OpenaiSettingPayload, S>

  type OpenaiSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpenaiSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpenaiSettingCountAggregateInputType | true
    }

  export interface OpenaiSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpenaiSetting'], meta: { name: 'OpenaiSetting' } }
    /**
     * Find zero or one OpenaiSetting that matches the filter.
     * @param {OpenaiSettingFindUniqueArgs} args - Arguments to find a OpenaiSetting
     * @example
     * // Get one OpenaiSetting
     * const openaiSetting = await prisma.openaiSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpenaiSettingFindUniqueArgs>(args: SelectSubset<T, OpenaiSettingFindUniqueArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OpenaiSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpenaiSettingFindUniqueOrThrowArgs} args - Arguments to find a OpenaiSetting
     * @example
     * // Get one OpenaiSetting
     * const openaiSetting = await prisma.openaiSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpenaiSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, OpenaiSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OpenaiSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiSettingFindFirstArgs} args - Arguments to find a OpenaiSetting
     * @example
     * // Get one OpenaiSetting
     * const openaiSetting = await prisma.openaiSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpenaiSettingFindFirstArgs>(args?: SelectSubset<T, OpenaiSettingFindFirstArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OpenaiSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiSettingFindFirstOrThrowArgs} args - Arguments to find a OpenaiSetting
     * @example
     * // Get one OpenaiSetting
     * const openaiSetting = await prisma.openaiSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpenaiSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, OpenaiSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OpenaiSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpenaiSettings
     * const openaiSettings = await prisma.openaiSetting.findMany()
     * 
     * // Get first 10 OpenaiSettings
     * const openaiSettings = await prisma.openaiSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const openaiSettingWithIdOnly = await prisma.openaiSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpenaiSettingFindManyArgs>(args?: SelectSubset<T, OpenaiSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OpenaiSetting.
     * @param {OpenaiSettingCreateArgs} args - Arguments to create a OpenaiSetting.
     * @example
     * // Create one OpenaiSetting
     * const OpenaiSetting = await prisma.openaiSetting.create({
     *   data: {
     *     // ... data to create a OpenaiSetting
     *   }
     * })
     * 
     */
    create<T extends OpenaiSettingCreateArgs>(args: SelectSubset<T, OpenaiSettingCreateArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OpenaiSettings.
     * @param {OpenaiSettingCreateManyArgs} args - Arguments to create many OpenaiSettings.
     * @example
     * // Create many OpenaiSettings
     * const openaiSetting = await prisma.openaiSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpenaiSettingCreateManyArgs>(args?: SelectSubset<T, OpenaiSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OpenaiSetting.
     * @param {OpenaiSettingDeleteArgs} args - Arguments to delete one OpenaiSetting.
     * @example
     * // Delete one OpenaiSetting
     * const OpenaiSetting = await prisma.openaiSetting.delete({
     *   where: {
     *     // ... filter to delete one OpenaiSetting
     *   }
     * })
     * 
     */
    delete<T extends OpenaiSettingDeleteArgs>(args: SelectSubset<T, OpenaiSettingDeleteArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OpenaiSetting.
     * @param {OpenaiSettingUpdateArgs} args - Arguments to update one OpenaiSetting.
     * @example
     * // Update one OpenaiSetting
     * const openaiSetting = await prisma.openaiSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpenaiSettingUpdateArgs>(args: SelectSubset<T, OpenaiSettingUpdateArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OpenaiSettings.
     * @param {OpenaiSettingDeleteManyArgs} args - Arguments to filter OpenaiSettings to delete.
     * @example
     * // Delete a few OpenaiSettings
     * const { count } = await prisma.openaiSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpenaiSettingDeleteManyArgs>(args?: SelectSubset<T, OpenaiSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpenaiSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpenaiSettings
     * const openaiSetting = await prisma.openaiSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpenaiSettingUpdateManyArgs>(args: SelectSubset<T, OpenaiSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OpenaiSetting.
     * @param {OpenaiSettingUpsertArgs} args - Arguments to update or create a OpenaiSetting.
     * @example
     * // Update or create a OpenaiSetting
     * const openaiSetting = await prisma.openaiSetting.upsert({
     *   create: {
     *     // ... data to create a OpenaiSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpenaiSetting we want to update
     *   }
     * })
     */
    upsert<T extends OpenaiSettingUpsertArgs>(args: SelectSubset<T, OpenaiSettingUpsertArgs<ExtArgs>>): Prisma__OpenaiSettingClient<$Result.GetResult<Prisma.$OpenaiSettingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OpenaiSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiSettingCountArgs} args - Arguments to filter OpenaiSettings to count.
     * @example
     * // Count the number of OpenaiSettings
     * const count = await prisma.openaiSetting.count({
     *   where: {
     *     // ... the filter for the OpenaiSettings we want to count
     *   }
     * })
    **/
    count<T extends OpenaiSettingCountArgs>(
      args?: Subset<T, OpenaiSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpenaiSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpenaiSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpenaiSettingAggregateArgs>(args: Subset<T, OpenaiSettingAggregateArgs>): Prisma.PrismaPromise<GetOpenaiSettingAggregateType<T>>

    /**
     * Group by OpenaiSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpenaiSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpenaiSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpenaiSettingGroupByArgs['orderBy'] }
        : { orderBy?: OpenaiSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpenaiSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpenaiSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpenaiSetting model
   */
  readonly fields: OpenaiSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpenaiSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpenaiSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OpenaiCreds<T extends OpenaiSetting$OpenaiCredsArgs<ExtArgs> = {}>(args?: Subset<T, OpenaiSetting$OpenaiCredsArgs<ExtArgs>>): Prisma__OpenaiCredsClient<$Result.GetResult<Prisma.$OpenaiCredsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Fallback<T extends OpenaiSetting$FallbackArgs<ExtArgs> = {}>(args?: Subset<T, OpenaiSetting$FallbackArgs<ExtArgs>>): Prisma__OpenaiBotClient<$Result.GetResult<Prisma.$OpenaiBotPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpenaiSetting model
   */ 
  interface OpenaiSettingFieldRefs {
    readonly id: FieldRef<"OpenaiSetting", 'String'>
    readonly expire: FieldRef<"OpenaiSetting", 'Int'>
    readonly keywordFinish: FieldRef<"OpenaiSetting", 'String'>
    readonly delayMessage: FieldRef<"OpenaiSetting", 'Int'>
    readonly unknownMessage: FieldRef<"OpenaiSetting", 'String'>
    readonly listeningFromMe: FieldRef<"OpenaiSetting", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"OpenaiSetting", 'Boolean'>
    readonly keepOpen: FieldRef<"OpenaiSetting", 'Boolean'>
    readonly debounceTime: FieldRef<"OpenaiSetting", 'Int'>
    readonly ignoreJids: FieldRef<"OpenaiSetting", 'Json'>
    readonly splitMessages: FieldRef<"OpenaiSetting", 'Boolean'>
    readonly timePerChar: FieldRef<"OpenaiSetting", 'Int'>
    readonly speechToText: FieldRef<"OpenaiSetting", 'Boolean'>
    readonly createdAt: FieldRef<"OpenaiSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"OpenaiSetting", 'DateTime'>
    readonly openaiCredsId: FieldRef<"OpenaiSetting", 'String'>
    readonly openaiIdFallback: FieldRef<"OpenaiSetting", 'String'>
    readonly instanceId: FieldRef<"OpenaiSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OpenaiSetting findUnique
   */
  export type OpenaiSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiSetting to fetch.
     */
    where: OpenaiSettingWhereUniqueInput
  }

  /**
   * OpenaiSetting findUniqueOrThrow
   */
  export type OpenaiSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiSetting to fetch.
     */
    where: OpenaiSettingWhereUniqueInput
  }

  /**
   * OpenaiSetting findFirst
   */
  export type OpenaiSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiSetting to fetch.
     */
    where?: OpenaiSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiSettings to fetch.
     */
    orderBy?: OpenaiSettingOrderByWithRelationInput | OpenaiSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenaiSettings.
     */
    cursor?: OpenaiSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenaiSettings.
     */
    distinct?: OpenaiSettingScalarFieldEnum | OpenaiSettingScalarFieldEnum[]
  }

  /**
   * OpenaiSetting findFirstOrThrow
   */
  export type OpenaiSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiSetting to fetch.
     */
    where?: OpenaiSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiSettings to fetch.
     */
    orderBy?: OpenaiSettingOrderByWithRelationInput | OpenaiSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpenaiSettings.
     */
    cursor?: OpenaiSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpenaiSettings.
     */
    distinct?: OpenaiSettingScalarFieldEnum | OpenaiSettingScalarFieldEnum[]
  }

  /**
   * OpenaiSetting findMany
   */
  export type OpenaiSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    /**
     * Filter, which OpenaiSettings to fetch.
     */
    where?: OpenaiSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpenaiSettings to fetch.
     */
    orderBy?: OpenaiSettingOrderByWithRelationInput | OpenaiSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpenaiSettings.
     */
    cursor?: OpenaiSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpenaiSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpenaiSettings.
     */
    skip?: number
    distinct?: OpenaiSettingScalarFieldEnum | OpenaiSettingScalarFieldEnum[]
  }

  /**
   * OpenaiSetting create
   */
  export type OpenaiSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a OpenaiSetting.
     */
    data: XOR<OpenaiSettingCreateInput, OpenaiSettingUncheckedCreateInput>
  }

  /**
   * OpenaiSetting createMany
   */
  export type OpenaiSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpenaiSettings.
     */
    data: OpenaiSettingCreateManyInput | OpenaiSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpenaiSetting update
   */
  export type OpenaiSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a OpenaiSetting.
     */
    data: XOR<OpenaiSettingUpdateInput, OpenaiSettingUncheckedUpdateInput>
    /**
     * Choose, which OpenaiSetting to update.
     */
    where: OpenaiSettingWhereUniqueInput
  }

  /**
   * OpenaiSetting updateMany
   */
  export type OpenaiSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpenaiSettings.
     */
    data: XOR<OpenaiSettingUpdateManyMutationInput, OpenaiSettingUncheckedUpdateManyInput>
    /**
     * Filter which OpenaiSettings to update
     */
    where?: OpenaiSettingWhereInput
    /**
     * Limit how many OpenaiSettings to update.
     */
    limit?: number
  }

  /**
   * OpenaiSetting upsert
   */
  export type OpenaiSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the OpenaiSetting to update in case it exists.
     */
    where: OpenaiSettingWhereUniqueInput
    /**
     * In case the OpenaiSetting found by the `where` argument doesn't exist, create a new OpenaiSetting with this data.
     */
    create: XOR<OpenaiSettingCreateInput, OpenaiSettingUncheckedCreateInput>
    /**
     * In case the OpenaiSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpenaiSettingUpdateInput, OpenaiSettingUncheckedUpdateInput>
  }

  /**
   * OpenaiSetting delete
   */
  export type OpenaiSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
    /**
     * Filter which OpenaiSetting to delete.
     */
    where: OpenaiSettingWhereUniqueInput
  }

  /**
   * OpenaiSetting deleteMany
   */
  export type OpenaiSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpenaiSettings to delete
     */
    where?: OpenaiSettingWhereInput
    /**
     * Limit how many OpenaiSettings to delete.
     */
    limit?: number
  }

  /**
   * OpenaiSetting.OpenaiCreds
   */
  export type OpenaiSetting$OpenaiCredsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiCreds
     */
    select?: OpenaiCredsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiCreds
     */
    omit?: OpenaiCredsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiCredsInclude<ExtArgs> | null
    where?: OpenaiCredsWhereInput
  }

  /**
   * OpenaiSetting.Fallback
   */
  export type OpenaiSetting$FallbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiBot
     */
    select?: OpenaiBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiBot
     */
    omit?: OpenaiBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiBotInclude<ExtArgs> | null
    where?: OpenaiBotWhereInput
  }

  /**
   * OpenaiSetting without action
   */
  export type OpenaiSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpenaiSetting
     */
    select?: OpenaiSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpenaiSetting
     */
    omit?: OpenaiSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpenaiSettingInclude<ExtArgs> | null
  }


  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    name: string | null
    webhookUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    name: string | null
    webhookUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    templateId: number
    name: number
    template: number
    webhookUrl: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type TemplateMinAggregateInputType = {
    id?: true
    templateId?: true
    name?: true
    webhookUrl?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    templateId?: true
    name?: true
    webhookUrl?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    templateId?: true
    name?: true
    template?: true
    webhookUrl?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: string
    templateId: string
    name: string
    template: JsonValue
    webhookUrl: string | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    name?: boolean
    template?: boolean
    webhookUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>



  export type TemplateSelectScalar = {
    id?: boolean
    templateId?: boolean
    name?: boolean
    template?: boolean
    webhookUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type TemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "templateId" | "name" | "template" | "webhookUrl" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["template"]>
  export type TemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      templateId: string
      name: string
      template: Prisma.JsonValue
      webhookUrl: string | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["template"]>
    composites: {}
  }

  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFindUniqueArgs>(args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Template that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFindFirstArgs>(args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFindManyArgs>(args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
     */
    create<T extends TemplateCreateArgs>(args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Templates.
     * @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCreateManyArgs>(args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
     */
    delete<T extends TemplateDeleteArgs>(args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateUpdateArgs>(args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDeleteManyArgs>(args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateUpdateManyArgs>(args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
     */
    upsert<T extends TemplateUpsertArgs>(args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Template model
   */ 
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'String'>
    readonly templateId: FieldRef<"Template", 'String'>
    readonly name: FieldRef<"Template", 'String'>
    readonly template: FieldRef<"Template", 'Json'>
    readonly webhookUrl: FieldRef<"Template", 'String'>
    readonly createdAt: FieldRef<"Template", 'DateTime'>
    readonly updatedAt: FieldRef<"Template", 'DateTime'>
    readonly instanceId: FieldRef<"Template", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }

  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
  }

  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }

  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to delete.
     */
    limit?: number
  }

  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
  }


  /**
   * Model Dify
   */

  export type AggregateDify = {
    _count: DifyCountAggregateOutputType | null
    _avg: DifyAvgAggregateOutputType | null
    _sum: DifySumAggregateOutputType | null
    _min: DifyMinAggregateOutputType | null
    _max: DifyMaxAggregateOutputType | null
  }

  export type DifyAvgAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type DifySumAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type DifyMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    botType: $Enums.DifyBotType | null
    apiUrl: string | null
    apiKey: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type DifyMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    botType: $Enums.DifyBotType | null
    apiUrl: string | null
    apiKey: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type DifyCountAggregateOutputType = {
    id: number
    enabled: number
    description: number
    botType: number
    apiUrl: number
    apiKey: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    ignoreJids: number
    splitMessages: number
    timePerChar: number
    triggerType: number
    triggerOperator: number
    triggerValue: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type DifyAvgAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type DifySumAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type DifyMinAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    botType?: true
    apiUrl?: true
    apiKey?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type DifyMaxAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    botType?: true
    apiUrl?: true
    apiKey?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type DifyCountAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    botType?: true
    apiUrl?: true
    apiKey?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    ignoreJids?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type DifyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dify to aggregate.
     */
    where?: DifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Difies to fetch.
     */
    orderBy?: DifyOrderByWithRelationInput | DifyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Difies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Difies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Difies
    **/
    _count?: true | DifyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DifyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DifySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DifyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DifyMaxAggregateInputType
  }

  export type GetDifyAggregateType<T extends DifyAggregateArgs> = {
        [P in keyof T & keyof AggregateDify]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDify[P]>
      : GetScalarType<T[P], AggregateDify[P]>
  }




  export type DifyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DifyWhereInput
    orderBy?: DifyOrderByWithAggregationInput | DifyOrderByWithAggregationInput[]
    by: DifyScalarFieldEnum[] | DifyScalarFieldEnum
    having?: DifyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DifyCountAggregateInputType | true
    _avg?: DifyAvgAggregateInputType
    _sum?: DifySumAggregateInputType
    _min?: DifyMinAggregateInputType
    _max?: DifyMaxAggregateInputType
  }

  export type DifyGroupByOutputType = {
    id: string
    enabled: boolean
    description: string | null
    botType: $Enums.DifyBotType
    apiUrl: string | null
    apiKey: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    ignoreJids: JsonValue | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: DifyCountAggregateOutputType | null
    _avg: DifyAvgAggregateOutputType | null
    _sum: DifySumAggregateOutputType | null
    _min: DifyMinAggregateOutputType | null
    _max: DifyMaxAggregateOutputType | null
  }

  type GetDifyGroupByPayload<T extends DifyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DifyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DifyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DifyGroupByOutputType[P]>
            : GetScalarType<T[P], DifyGroupByOutputType[P]>
        }
      >
    >


  export type DifySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    description?: boolean
    botType?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    DifySetting?: boolean | Dify$DifySettingArgs<ExtArgs>
    _count?: boolean | DifyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dify"]>



  export type DifySelectScalar = {
    id?: boolean
    enabled?: boolean
    description?: boolean
    botType?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type DifyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "description" | "botType" | "apiUrl" | "apiKey" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "ignoreJids" | "splitMessages" | "timePerChar" | "triggerType" | "triggerOperator" | "triggerValue" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["dify"]>
  export type DifyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    DifySetting?: boolean | Dify$DifySettingArgs<ExtArgs>
    _count?: boolean | DifyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DifyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dify"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
      DifySetting: Prisma.$DifySettingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      description: string | null
      botType: $Enums.DifyBotType
      apiUrl: string | null
      apiKey: string | null
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      ignoreJids: Prisma.JsonValue | null
      splitMessages: boolean | null
      timePerChar: number | null
      triggerType: $Enums.TriggerType | null
      triggerOperator: $Enums.TriggerOperator | null
      triggerValue: string | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["dify"]>
    composites: {}
  }

  type DifyGetPayload<S extends boolean | null | undefined | DifyDefaultArgs> = $Result.GetResult<Prisma.$DifyPayload, S>

  type DifyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DifyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DifyCountAggregateInputType | true
    }

  export interface DifyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dify'], meta: { name: 'Dify' } }
    /**
     * Find zero or one Dify that matches the filter.
     * @param {DifyFindUniqueArgs} args - Arguments to find a Dify
     * @example
     * // Get one Dify
     * const dify = await prisma.dify.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DifyFindUniqueArgs>(args: SelectSubset<T, DifyFindUniqueArgs<ExtArgs>>): Prisma__DifyClient<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Dify that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DifyFindUniqueOrThrowArgs} args - Arguments to find a Dify
     * @example
     * // Get one Dify
     * const dify = await prisma.dify.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DifyFindUniqueOrThrowArgs>(args: SelectSubset<T, DifyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DifyClient<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Dify that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifyFindFirstArgs} args - Arguments to find a Dify
     * @example
     * // Get one Dify
     * const dify = await prisma.dify.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DifyFindFirstArgs>(args?: SelectSubset<T, DifyFindFirstArgs<ExtArgs>>): Prisma__DifyClient<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Dify that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifyFindFirstOrThrowArgs} args - Arguments to find a Dify
     * @example
     * // Get one Dify
     * const dify = await prisma.dify.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DifyFindFirstOrThrowArgs>(args?: SelectSubset<T, DifyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DifyClient<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Difies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Difies
     * const difies = await prisma.dify.findMany()
     * 
     * // Get first 10 Difies
     * const difies = await prisma.dify.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const difyWithIdOnly = await prisma.dify.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DifyFindManyArgs>(args?: SelectSubset<T, DifyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Dify.
     * @param {DifyCreateArgs} args - Arguments to create a Dify.
     * @example
     * // Create one Dify
     * const Dify = await prisma.dify.create({
     *   data: {
     *     // ... data to create a Dify
     *   }
     * })
     * 
     */
    create<T extends DifyCreateArgs>(args: SelectSubset<T, DifyCreateArgs<ExtArgs>>): Prisma__DifyClient<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Difies.
     * @param {DifyCreateManyArgs} args - Arguments to create many Difies.
     * @example
     * // Create many Difies
     * const dify = await prisma.dify.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DifyCreateManyArgs>(args?: SelectSubset<T, DifyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dify.
     * @param {DifyDeleteArgs} args - Arguments to delete one Dify.
     * @example
     * // Delete one Dify
     * const Dify = await prisma.dify.delete({
     *   where: {
     *     // ... filter to delete one Dify
     *   }
     * })
     * 
     */
    delete<T extends DifyDeleteArgs>(args: SelectSubset<T, DifyDeleteArgs<ExtArgs>>): Prisma__DifyClient<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Dify.
     * @param {DifyUpdateArgs} args - Arguments to update one Dify.
     * @example
     * // Update one Dify
     * const dify = await prisma.dify.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DifyUpdateArgs>(args: SelectSubset<T, DifyUpdateArgs<ExtArgs>>): Prisma__DifyClient<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Difies.
     * @param {DifyDeleteManyArgs} args - Arguments to filter Difies to delete.
     * @example
     * // Delete a few Difies
     * const { count } = await prisma.dify.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DifyDeleteManyArgs>(args?: SelectSubset<T, DifyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Difies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Difies
     * const dify = await prisma.dify.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DifyUpdateManyArgs>(args: SelectSubset<T, DifyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dify.
     * @param {DifyUpsertArgs} args - Arguments to update or create a Dify.
     * @example
     * // Update or create a Dify
     * const dify = await prisma.dify.upsert({
     *   create: {
     *     // ... data to create a Dify
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dify we want to update
     *   }
     * })
     */
    upsert<T extends DifyUpsertArgs>(args: SelectSubset<T, DifyUpsertArgs<ExtArgs>>): Prisma__DifyClient<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Difies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifyCountArgs} args - Arguments to filter Difies to count.
     * @example
     * // Count the number of Difies
     * const count = await prisma.dify.count({
     *   where: {
     *     // ... the filter for the Difies we want to count
     *   }
     * })
    **/
    count<T extends DifyCountArgs>(
      args?: Subset<T, DifyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DifyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dify.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DifyAggregateArgs>(args: Subset<T, DifyAggregateArgs>): Prisma.PrismaPromise<GetDifyAggregateType<T>>

    /**
     * Group by Dify.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DifyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DifyGroupByArgs['orderBy'] }
        : { orderBy?: DifyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DifyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDifyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dify model
   */
  readonly fields: DifyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dify.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DifyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    DifySetting<T extends Dify$DifySettingArgs<ExtArgs> = {}>(args?: Subset<T, Dify$DifySettingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dify model
   */ 
  interface DifyFieldRefs {
    readonly id: FieldRef<"Dify", 'String'>
    readonly enabled: FieldRef<"Dify", 'Boolean'>
    readonly description: FieldRef<"Dify", 'String'>
    readonly botType: FieldRef<"Dify", 'DifyBotType'>
    readonly apiUrl: FieldRef<"Dify", 'String'>
    readonly apiKey: FieldRef<"Dify", 'String'>
    readonly expire: FieldRef<"Dify", 'Int'>
    readonly keywordFinish: FieldRef<"Dify", 'String'>
    readonly delayMessage: FieldRef<"Dify", 'Int'>
    readonly unknownMessage: FieldRef<"Dify", 'String'>
    readonly listeningFromMe: FieldRef<"Dify", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"Dify", 'Boolean'>
    readonly keepOpen: FieldRef<"Dify", 'Boolean'>
    readonly debounceTime: FieldRef<"Dify", 'Int'>
    readonly ignoreJids: FieldRef<"Dify", 'Json'>
    readonly splitMessages: FieldRef<"Dify", 'Boolean'>
    readonly timePerChar: FieldRef<"Dify", 'Int'>
    readonly triggerType: FieldRef<"Dify", 'TriggerType'>
    readonly triggerOperator: FieldRef<"Dify", 'TriggerOperator'>
    readonly triggerValue: FieldRef<"Dify", 'String'>
    readonly createdAt: FieldRef<"Dify", 'DateTime'>
    readonly updatedAt: FieldRef<"Dify", 'DateTime'>
    readonly instanceId: FieldRef<"Dify", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Dify findUnique
   */
  export type DifyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    /**
     * Filter, which Dify to fetch.
     */
    where: DifyWhereUniqueInput
  }

  /**
   * Dify findUniqueOrThrow
   */
  export type DifyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    /**
     * Filter, which Dify to fetch.
     */
    where: DifyWhereUniqueInput
  }

  /**
   * Dify findFirst
   */
  export type DifyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    /**
     * Filter, which Dify to fetch.
     */
    where?: DifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Difies to fetch.
     */
    orderBy?: DifyOrderByWithRelationInput | DifyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Difies.
     */
    cursor?: DifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Difies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Difies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Difies.
     */
    distinct?: DifyScalarFieldEnum | DifyScalarFieldEnum[]
  }

  /**
   * Dify findFirstOrThrow
   */
  export type DifyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    /**
     * Filter, which Dify to fetch.
     */
    where?: DifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Difies to fetch.
     */
    orderBy?: DifyOrderByWithRelationInput | DifyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Difies.
     */
    cursor?: DifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Difies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Difies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Difies.
     */
    distinct?: DifyScalarFieldEnum | DifyScalarFieldEnum[]
  }

  /**
   * Dify findMany
   */
  export type DifyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    /**
     * Filter, which Difies to fetch.
     */
    where?: DifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Difies to fetch.
     */
    orderBy?: DifyOrderByWithRelationInput | DifyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Difies.
     */
    cursor?: DifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Difies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Difies.
     */
    skip?: number
    distinct?: DifyScalarFieldEnum | DifyScalarFieldEnum[]
  }

  /**
   * Dify create
   */
  export type DifyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    /**
     * The data needed to create a Dify.
     */
    data: XOR<DifyCreateInput, DifyUncheckedCreateInput>
  }

  /**
   * Dify createMany
   */
  export type DifyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Difies.
     */
    data: DifyCreateManyInput | DifyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dify update
   */
  export type DifyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    /**
     * The data needed to update a Dify.
     */
    data: XOR<DifyUpdateInput, DifyUncheckedUpdateInput>
    /**
     * Choose, which Dify to update.
     */
    where: DifyWhereUniqueInput
  }

  /**
   * Dify updateMany
   */
  export type DifyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Difies.
     */
    data: XOR<DifyUpdateManyMutationInput, DifyUncheckedUpdateManyInput>
    /**
     * Filter which Difies to update
     */
    where?: DifyWhereInput
    /**
     * Limit how many Difies to update.
     */
    limit?: number
  }

  /**
   * Dify upsert
   */
  export type DifyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    /**
     * The filter to search for the Dify to update in case it exists.
     */
    where: DifyWhereUniqueInput
    /**
     * In case the Dify found by the `where` argument doesn't exist, create a new Dify with this data.
     */
    create: XOR<DifyCreateInput, DifyUncheckedCreateInput>
    /**
     * In case the Dify was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DifyUpdateInput, DifyUncheckedUpdateInput>
  }

  /**
   * Dify delete
   */
  export type DifyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    /**
     * Filter which Dify to delete.
     */
    where: DifyWhereUniqueInput
  }

  /**
   * Dify deleteMany
   */
  export type DifyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Difies to delete
     */
    where?: DifyWhereInput
    /**
     * Limit how many Difies to delete.
     */
    limit?: number
  }

  /**
   * Dify.DifySetting
   */
  export type Dify$DifySettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    where?: DifySettingWhereInput
    orderBy?: DifySettingOrderByWithRelationInput | DifySettingOrderByWithRelationInput[]
    cursor?: DifySettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DifySettingScalarFieldEnum | DifySettingScalarFieldEnum[]
  }

  /**
   * Dify without action
   */
  export type DifyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
  }


  /**
   * Model DifySetting
   */

  export type AggregateDifySetting = {
    _count: DifySettingCountAggregateOutputType | null
    _avg: DifySettingAvgAggregateOutputType | null
    _sum: DifySettingSumAggregateOutputType | null
    _min: DifySettingMinAggregateOutputType | null
    _max: DifySettingMaxAggregateOutputType | null
  }

  export type DifySettingAvgAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type DifySettingSumAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type DifySettingMinAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    createdAt: Date | null
    updatedAt: Date | null
    difyIdFallback: string | null
    instanceId: string | null
  }

  export type DifySettingMaxAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    createdAt: Date | null
    updatedAt: Date | null
    difyIdFallback: string | null
    instanceId: string | null
  }

  export type DifySettingCountAggregateOutputType = {
    id: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    ignoreJids: number
    splitMessages: number
    timePerChar: number
    createdAt: number
    updatedAt: number
    difyIdFallback: number
    instanceId: number
    _all: number
  }


  export type DifySettingAvgAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type DifySettingSumAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type DifySettingMinAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    createdAt?: true
    updatedAt?: true
    difyIdFallback?: true
    instanceId?: true
  }

  export type DifySettingMaxAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    createdAt?: true
    updatedAt?: true
    difyIdFallback?: true
    instanceId?: true
  }

  export type DifySettingCountAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    ignoreJids?: true
    splitMessages?: true
    timePerChar?: true
    createdAt?: true
    updatedAt?: true
    difyIdFallback?: true
    instanceId?: true
    _all?: true
  }

  export type DifySettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DifySetting to aggregate.
     */
    where?: DifySettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DifySettings to fetch.
     */
    orderBy?: DifySettingOrderByWithRelationInput | DifySettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DifySettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DifySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DifySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DifySettings
    **/
    _count?: true | DifySettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DifySettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DifySettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DifySettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DifySettingMaxAggregateInputType
  }

  export type GetDifySettingAggregateType<T extends DifySettingAggregateArgs> = {
        [P in keyof T & keyof AggregateDifySetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDifySetting[P]>
      : GetScalarType<T[P], AggregateDifySetting[P]>
  }




  export type DifySettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DifySettingWhereInput
    orderBy?: DifySettingOrderByWithAggregationInput | DifySettingOrderByWithAggregationInput[]
    by: DifySettingScalarFieldEnum[] | DifySettingScalarFieldEnum
    having?: DifySettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DifySettingCountAggregateInputType | true
    _avg?: DifySettingAvgAggregateInputType
    _sum?: DifySettingSumAggregateInputType
    _min?: DifySettingMinAggregateInputType
    _max?: DifySettingMaxAggregateInputType
  }

  export type DifySettingGroupByOutputType = {
    id: string
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    ignoreJids: JsonValue | null
    splitMessages: boolean | null
    timePerChar: number | null
    createdAt: Date | null
    updatedAt: Date
    difyIdFallback: string | null
    instanceId: string
    _count: DifySettingCountAggregateOutputType | null
    _avg: DifySettingAvgAggregateOutputType | null
    _sum: DifySettingSumAggregateOutputType | null
    _min: DifySettingMinAggregateOutputType | null
    _max: DifySettingMaxAggregateOutputType | null
  }

  type GetDifySettingGroupByPayload<T extends DifySettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DifySettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DifySettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DifySettingGroupByOutputType[P]>
            : GetScalarType<T[P], DifySettingGroupByOutputType[P]>
        }
      >
    >


  export type DifySettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    difyIdFallback?: boolean
    instanceId?: boolean
    Fallback?: boolean | DifySetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["difySetting"]>



  export type DifySettingSelectScalar = {
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    difyIdFallback?: boolean
    instanceId?: boolean
  }

  export type DifySettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "ignoreJids" | "splitMessages" | "timePerChar" | "createdAt" | "updatedAt" | "difyIdFallback" | "instanceId", ExtArgs["result"]["difySetting"]>
  export type DifySettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Fallback?: boolean | DifySetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $DifySettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DifySetting"
    objects: {
      Fallback: Prisma.$DifyPayload<ExtArgs> | null
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      ignoreJids: Prisma.JsonValue | null
      splitMessages: boolean | null
      timePerChar: number | null
      createdAt: Date | null
      updatedAt: Date
      difyIdFallback: string | null
      instanceId: string
    }, ExtArgs["result"]["difySetting"]>
    composites: {}
  }

  type DifySettingGetPayload<S extends boolean | null | undefined | DifySettingDefaultArgs> = $Result.GetResult<Prisma.$DifySettingPayload, S>

  type DifySettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DifySettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DifySettingCountAggregateInputType | true
    }

  export interface DifySettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DifySetting'], meta: { name: 'DifySetting' } }
    /**
     * Find zero or one DifySetting that matches the filter.
     * @param {DifySettingFindUniqueArgs} args - Arguments to find a DifySetting
     * @example
     * // Get one DifySetting
     * const difySetting = await prisma.difySetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DifySettingFindUniqueArgs>(args: SelectSubset<T, DifySettingFindUniqueArgs<ExtArgs>>): Prisma__DifySettingClient<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DifySetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DifySettingFindUniqueOrThrowArgs} args - Arguments to find a DifySetting
     * @example
     * // Get one DifySetting
     * const difySetting = await prisma.difySetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DifySettingFindUniqueOrThrowArgs>(args: SelectSubset<T, DifySettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DifySettingClient<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DifySetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifySettingFindFirstArgs} args - Arguments to find a DifySetting
     * @example
     * // Get one DifySetting
     * const difySetting = await prisma.difySetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DifySettingFindFirstArgs>(args?: SelectSubset<T, DifySettingFindFirstArgs<ExtArgs>>): Prisma__DifySettingClient<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DifySetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifySettingFindFirstOrThrowArgs} args - Arguments to find a DifySetting
     * @example
     * // Get one DifySetting
     * const difySetting = await prisma.difySetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DifySettingFindFirstOrThrowArgs>(args?: SelectSubset<T, DifySettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DifySettingClient<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DifySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifySettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DifySettings
     * const difySettings = await prisma.difySetting.findMany()
     * 
     * // Get first 10 DifySettings
     * const difySettings = await prisma.difySetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const difySettingWithIdOnly = await prisma.difySetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DifySettingFindManyArgs>(args?: SelectSubset<T, DifySettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DifySetting.
     * @param {DifySettingCreateArgs} args - Arguments to create a DifySetting.
     * @example
     * // Create one DifySetting
     * const DifySetting = await prisma.difySetting.create({
     *   data: {
     *     // ... data to create a DifySetting
     *   }
     * })
     * 
     */
    create<T extends DifySettingCreateArgs>(args: SelectSubset<T, DifySettingCreateArgs<ExtArgs>>): Prisma__DifySettingClient<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DifySettings.
     * @param {DifySettingCreateManyArgs} args - Arguments to create many DifySettings.
     * @example
     * // Create many DifySettings
     * const difySetting = await prisma.difySetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DifySettingCreateManyArgs>(args?: SelectSubset<T, DifySettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DifySetting.
     * @param {DifySettingDeleteArgs} args - Arguments to delete one DifySetting.
     * @example
     * // Delete one DifySetting
     * const DifySetting = await prisma.difySetting.delete({
     *   where: {
     *     // ... filter to delete one DifySetting
     *   }
     * })
     * 
     */
    delete<T extends DifySettingDeleteArgs>(args: SelectSubset<T, DifySettingDeleteArgs<ExtArgs>>): Prisma__DifySettingClient<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DifySetting.
     * @param {DifySettingUpdateArgs} args - Arguments to update one DifySetting.
     * @example
     * // Update one DifySetting
     * const difySetting = await prisma.difySetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DifySettingUpdateArgs>(args: SelectSubset<T, DifySettingUpdateArgs<ExtArgs>>): Prisma__DifySettingClient<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DifySettings.
     * @param {DifySettingDeleteManyArgs} args - Arguments to filter DifySettings to delete.
     * @example
     * // Delete a few DifySettings
     * const { count } = await prisma.difySetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DifySettingDeleteManyArgs>(args?: SelectSubset<T, DifySettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DifySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifySettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DifySettings
     * const difySetting = await prisma.difySetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DifySettingUpdateManyArgs>(args: SelectSubset<T, DifySettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DifySetting.
     * @param {DifySettingUpsertArgs} args - Arguments to update or create a DifySetting.
     * @example
     * // Update or create a DifySetting
     * const difySetting = await prisma.difySetting.upsert({
     *   create: {
     *     // ... data to create a DifySetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DifySetting we want to update
     *   }
     * })
     */
    upsert<T extends DifySettingUpsertArgs>(args: SelectSubset<T, DifySettingUpsertArgs<ExtArgs>>): Prisma__DifySettingClient<$Result.GetResult<Prisma.$DifySettingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DifySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifySettingCountArgs} args - Arguments to filter DifySettings to count.
     * @example
     * // Count the number of DifySettings
     * const count = await prisma.difySetting.count({
     *   where: {
     *     // ... the filter for the DifySettings we want to count
     *   }
     * })
    **/
    count<T extends DifySettingCountArgs>(
      args?: Subset<T, DifySettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DifySettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DifySetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifySettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DifySettingAggregateArgs>(args: Subset<T, DifySettingAggregateArgs>): Prisma.PrismaPromise<GetDifySettingAggregateType<T>>

    /**
     * Group by DifySetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DifySettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DifySettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DifySettingGroupByArgs['orderBy'] }
        : { orderBy?: DifySettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DifySettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDifySettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DifySetting model
   */
  readonly fields: DifySettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DifySetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DifySettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Fallback<T extends DifySetting$FallbackArgs<ExtArgs> = {}>(args?: Subset<T, DifySetting$FallbackArgs<ExtArgs>>): Prisma__DifyClient<$Result.GetResult<Prisma.$DifyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DifySetting model
   */ 
  interface DifySettingFieldRefs {
    readonly id: FieldRef<"DifySetting", 'String'>
    readonly expire: FieldRef<"DifySetting", 'Int'>
    readonly keywordFinish: FieldRef<"DifySetting", 'String'>
    readonly delayMessage: FieldRef<"DifySetting", 'Int'>
    readonly unknownMessage: FieldRef<"DifySetting", 'String'>
    readonly listeningFromMe: FieldRef<"DifySetting", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"DifySetting", 'Boolean'>
    readonly keepOpen: FieldRef<"DifySetting", 'Boolean'>
    readonly debounceTime: FieldRef<"DifySetting", 'Int'>
    readonly ignoreJids: FieldRef<"DifySetting", 'Json'>
    readonly splitMessages: FieldRef<"DifySetting", 'Boolean'>
    readonly timePerChar: FieldRef<"DifySetting", 'Int'>
    readonly createdAt: FieldRef<"DifySetting", 'DateTime'>
    readonly updatedAt: FieldRef<"DifySetting", 'DateTime'>
    readonly difyIdFallback: FieldRef<"DifySetting", 'String'>
    readonly instanceId: FieldRef<"DifySetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DifySetting findUnique
   */
  export type DifySettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    /**
     * Filter, which DifySetting to fetch.
     */
    where: DifySettingWhereUniqueInput
  }

  /**
   * DifySetting findUniqueOrThrow
   */
  export type DifySettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    /**
     * Filter, which DifySetting to fetch.
     */
    where: DifySettingWhereUniqueInput
  }

  /**
   * DifySetting findFirst
   */
  export type DifySettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    /**
     * Filter, which DifySetting to fetch.
     */
    where?: DifySettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DifySettings to fetch.
     */
    orderBy?: DifySettingOrderByWithRelationInput | DifySettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DifySettings.
     */
    cursor?: DifySettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DifySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DifySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DifySettings.
     */
    distinct?: DifySettingScalarFieldEnum | DifySettingScalarFieldEnum[]
  }

  /**
   * DifySetting findFirstOrThrow
   */
  export type DifySettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    /**
     * Filter, which DifySetting to fetch.
     */
    where?: DifySettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DifySettings to fetch.
     */
    orderBy?: DifySettingOrderByWithRelationInput | DifySettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DifySettings.
     */
    cursor?: DifySettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DifySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DifySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DifySettings.
     */
    distinct?: DifySettingScalarFieldEnum | DifySettingScalarFieldEnum[]
  }

  /**
   * DifySetting findMany
   */
  export type DifySettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    /**
     * Filter, which DifySettings to fetch.
     */
    where?: DifySettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DifySettings to fetch.
     */
    orderBy?: DifySettingOrderByWithRelationInput | DifySettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DifySettings.
     */
    cursor?: DifySettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DifySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DifySettings.
     */
    skip?: number
    distinct?: DifySettingScalarFieldEnum | DifySettingScalarFieldEnum[]
  }

  /**
   * DifySetting create
   */
  export type DifySettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    /**
     * The data needed to create a DifySetting.
     */
    data: XOR<DifySettingCreateInput, DifySettingUncheckedCreateInput>
  }

  /**
   * DifySetting createMany
   */
  export type DifySettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DifySettings.
     */
    data: DifySettingCreateManyInput | DifySettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DifySetting update
   */
  export type DifySettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    /**
     * The data needed to update a DifySetting.
     */
    data: XOR<DifySettingUpdateInput, DifySettingUncheckedUpdateInput>
    /**
     * Choose, which DifySetting to update.
     */
    where: DifySettingWhereUniqueInput
  }

  /**
   * DifySetting updateMany
   */
  export type DifySettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DifySettings.
     */
    data: XOR<DifySettingUpdateManyMutationInput, DifySettingUncheckedUpdateManyInput>
    /**
     * Filter which DifySettings to update
     */
    where?: DifySettingWhereInput
    /**
     * Limit how many DifySettings to update.
     */
    limit?: number
  }

  /**
   * DifySetting upsert
   */
  export type DifySettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    /**
     * The filter to search for the DifySetting to update in case it exists.
     */
    where: DifySettingWhereUniqueInput
    /**
     * In case the DifySetting found by the `where` argument doesn't exist, create a new DifySetting with this data.
     */
    create: XOR<DifySettingCreateInput, DifySettingUncheckedCreateInput>
    /**
     * In case the DifySetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DifySettingUpdateInput, DifySettingUncheckedUpdateInput>
  }

  /**
   * DifySetting delete
   */
  export type DifySettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
    /**
     * Filter which DifySetting to delete.
     */
    where: DifySettingWhereUniqueInput
  }

  /**
   * DifySetting deleteMany
   */
  export type DifySettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DifySettings to delete
     */
    where?: DifySettingWhereInput
    /**
     * Limit how many DifySettings to delete.
     */
    limit?: number
  }

  /**
   * DifySetting.Fallback
   */
  export type DifySetting$FallbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dify
     */
    select?: DifySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dify
     */
    omit?: DifyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifyInclude<ExtArgs> | null
    where?: DifyWhereInput
  }

  /**
   * DifySetting without action
   */
  export type DifySettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DifySetting
     */
    select?: DifySettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DifySetting
     */
    omit?: DifySettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DifySettingInclude<ExtArgs> | null
  }


  /**
   * Model EvolutionBot
   */

  export type AggregateEvolutionBot = {
    _count: EvolutionBotCountAggregateOutputType | null
    _avg: EvolutionBotAvgAggregateOutputType | null
    _sum: EvolutionBotSumAggregateOutputType | null
    _min: EvolutionBotMinAggregateOutputType | null
    _max: EvolutionBotMaxAggregateOutputType | null
  }

  export type EvolutionBotAvgAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type EvolutionBotSumAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type EvolutionBotMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    apiUrl: string | null
    apiKey: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type EvolutionBotMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    apiUrl: string | null
    apiKey: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type EvolutionBotCountAggregateOutputType = {
    id: number
    enabled: number
    description: number
    apiUrl: number
    apiKey: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    ignoreJids: number
    splitMessages: number
    timePerChar: number
    triggerType: number
    triggerOperator: number
    triggerValue: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type EvolutionBotAvgAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type EvolutionBotSumAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type EvolutionBotMinAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    apiUrl?: true
    apiKey?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type EvolutionBotMaxAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    apiUrl?: true
    apiKey?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type EvolutionBotCountAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    apiUrl?: true
    apiKey?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    ignoreJids?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type EvolutionBotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolutionBot to aggregate.
     */
    where?: EvolutionBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionBots to fetch.
     */
    orderBy?: EvolutionBotOrderByWithRelationInput | EvolutionBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvolutionBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvolutionBots
    **/
    _count?: true | EvolutionBotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvolutionBotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvolutionBotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvolutionBotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvolutionBotMaxAggregateInputType
  }

  export type GetEvolutionBotAggregateType<T extends EvolutionBotAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolutionBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolutionBot[P]>
      : GetScalarType<T[P], AggregateEvolutionBot[P]>
  }




  export type EvolutionBotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolutionBotWhereInput
    orderBy?: EvolutionBotOrderByWithAggregationInput | EvolutionBotOrderByWithAggregationInput[]
    by: EvolutionBotScalarFieldEnum[] | EvolutionBotScalarFieldEnum
    having?: EvolutionBotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvolutionBotCountAggregateInputType | true
    _avg?: EvolutionBotAvgAggregateInputType
    _sum?: EvolutionBotSumAggregateInputType
    _min?: EvolutionBotMinAggregateInputType
    _max?: EvolutionBotMaxAggregateInputType
  }

  export type EvolutionBotGroupByOutputType = {
    id: string
    enabled: boolean
    description: string | null
    apiUrl: string | null
    apiKey: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    ignoreJids: JsonValue | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: EvolutionBotCountAggregateOutputType | null
    _avg: EvolutionBotAvgAggregateOutputType | null
    _sum: EvolutionBotSumAggregateOutputType | null
    _min: EvolutionBotMinAggregateOutputType | null
    _max: EvolutionBotMaxAggregateOutputType | null
  }

  type GetEvolutionBotGroupByPayload<T extends EvolutionBotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvolutionBotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvolutionBotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvolutionBotGroupByOutputType[P]>
            : GetScalarType<T[P], EvolutionBotGroupByOutputType[P]>
        }
      >
    >


  export type EvolutionBotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    description?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    EvolutionBotSetting?: boolean | EvolutionBot$EvolutionBotSettingArgs<ExtArgs>
    _count?: boolean | EvolutionBotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolutionBot"]>



  export type EvolutionBotSelectScalar = {
    id?: boolean
    enabled?: boolean
    description?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type EvolutionBotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "description" | "apiUrl" | "apiKey" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "ignoreJids" | "splitMessages" | "timePerChar" | "triggerType" | "triggerOperator" | "triggerValue" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["evolutionBot"]>
  export type EvolutionBotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    EvolutionBotSetting?: boolean | EvolutionBot$EvolutionBotSettingArgs<ExtArgs>
    _count?: boolean | EvolutionBotCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EvolutionBotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvolutionBot"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
      EvolutionBotSetting: Prisma.$EvolutionBotSettingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      description: string | null
      apiUrl: string | null
      apiKey: string | null
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      ignoreJids: Prisma.JsonValue | null
      splitMessages: boolean | null
      timePerChar: number | null
      triggerType: $Enums.TriggerType | null
      triggerOperator: $Enums.TriggerOperator | null
      triggerValue: string | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["evolutionBot"]>
    composites: {}
  }

  type EvolutionBotGetPayload<S extends boolean | null | undefined | EvolutionBotDefaultArgs> = $Result.GetResult<Prisma.$EvolutionBotPayload, S>

  type EvolutionBotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvolutionBotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvolutionBotCountAggregateInputType | true
    }

  export interface EvolutionBotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvolutionBot'], meta: { name: 'EvolutionBot' } }
    /**
     * Find zero or one EvolutionBot that matches the filter.
     * @param {EvolutionBotFindUniqueArgs} args - Arguments to find a EvolutionBot
     * @example
     * // Get one EvolutionBot
     * const evolutionBot = await prisma.evolutionBot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvolutionBotFindUniqueArgs>(args: SelectSubset<T, EvolutionBotFindUniqueArgs<ExtArgs>>): Prisma__EvolutionBotClient<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EvolutionBot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvolutionBotFindUniqueOrThrowArgs} args - Arguments to find a EvolutionBot
     * @example
     * // Get one EvolutionBot
     * const evolutionBot = await prisma.evolutionBot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvolutionBotFindUniqueOrThrowArgs>(args: SelectSubset<T, EvolutionBotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvolutionBotClient<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EvolutionBot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotFindFirstArgs} args - Arguments to find a EvolutionBot
     * @example
     * // Get one EvolutionBot
     * const evolutionBot = await prisma.evolutionBot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvolutionBotFindFirstArgs>(args?: SelectSubset<T, EvolutionBotFindFirstArgs<ExtArgs>>): Prisma__EvolutionBotClient<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EvolutionBot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotFindFirstOrThrowArgs} args - Arguments to find a EvolutionBot
     * @example
     * // Get one EvolutionBot
     * const evolutionBot = await prisma.evolutionBot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvolutionBotFindFirstOrThrowArgs>(args?: SelectSubset<T, EvolutionBotFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvolutionBotClient<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EvolutionBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvolutionBots
     * const evolutionBots = await prisma.evolutionBot.findMany()
     * 
     * // Get first 10 EvolutionBots
     * const evolutionBots = await prisma.evolutionBot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolutionBotWithIdOnly = await prisma.evolutionBot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvolutionBotFindManyArgs>(args?: SelectSubset<T, EvolutionBotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EvolutionBot.
     * @param {EvolutionBotCreateArgs} args - Arguments to create a EvolutionBot.
     * @example
     * // Create one EvolutionBot
     * const EvolutionBot = await prisma.evolutionBot.create({
     *   data: {
     *     // ... data to create a EvolutionBot
     *   }
     * })
     * 
     */
    create<T extends EvolutionBotCreateArgs>(args: SelectSubset<T, EvolutionBotCreateArgs<ExtArgs>>): Prisma__EvolutionBotClient<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EvolutionBots.
     * @param {EvolutionBotCreateManyArgs} args - Arguments to create many EvolutionBots.
     * @example
     * // Create many EvolutionBots
     * const evolutionBot = await prisma.evolutionBot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvolutionBotCreateManyArgs>(args?: SelectSubset<T, EvolutionBotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EvolutionBot.
     * @param {EvolutionBotDeleteArgs} args - Arguments to delete one EvolutionBot.
     * @example
     * // Delete one EvolutionBot
     * const EvolutionBot = await prisma.evolutionBot.delete({
     *   where: {
     *     // ... filter to delete one EvolutionBot
     *   }
     * })
     * 
     */
    delete<T extends EvolutionBotDeleteArgs>(args: SelectSubset<T, EvolutionBotDeleteArgs<ExtArgs>>): Prisma__EvolutionBotClient<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EvolutionBot.
     * @param {EvolutionBotUpdateArgs} args - Arguments to update one EvolutionBot.
     * @example
     * // Update one EvolutionBot
     * const evolutionBot = await prisma.evolutionBot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvolutionBotUpdateArgs>(args: SelectSubset<T, EvolutionBotUpdateArgs<ExtArgs>>): Prisma__EvolutionBotClient<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EvolutionBots.
     * @param {EvolutionBotDeleteManyArgs} args - Arguments to filter EvolutionBots to delete.
     * @example
     * // Delete a few EvolutionBots
     * const { count } = await prisma.evolutionBot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvolutionBotDeleteManyArgs>(args?: SelectSubset<T, EvolutionBotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvolutionBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvolutionBots
     * const evolutionBot = await prisma.evolutionBot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvolutionBotUpdateManyArgs>(args: SelectSubset<T, EvolutionBotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvolutionBot.
     * @param {EvolutionBotUpsertArgs} args - Arguments to update or create a EvolutionBot.
     * @example
     * // Update or create a EvolutionBot
     * const evolutionBot = await prisma.evolutionBot.upsert({
     *   create: {
     *     // ... data to create a EvolutionBot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvolutionBot we want to update
     *   }
     * })
     */
    upsert<T extends EvolutionBotUpsertArgs>(args: SelectSubset<T, EvolutionBotUpsertArgs<ExtArgs>>): Prisma__EvolutionBotClient<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EvolutionBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotCountArgs} args - Arguments to filter EvolutionBots to count.
     * @example
     * // Count the number of EvolutionBots
     * const count = await prisma.evolutionBot.count({
     *   where: {
     *     // ... the filter for the EvolutionBots we want to count
     *   }
     * })
    **/
    count<T extends EvolutionBotCountArgs>(
      args?: Subset<T, EvolutionBotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvolutionBotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvolutionBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvolutionBotAggregateArgs>(args: Subset<T, EvolutionBotAggregateArgs>): Prisma.PrismaPromise<GetEvolutionBotAggregateType<T>>

    /**
     * Group by EvolutionBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvolutionBotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvolutionBotGroupByArgs['orderBy'] }
        : { orderBy?: EvolutionBotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvolutionBotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolutionBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvolutionBot model
   */
  readonly fields: EvolutionBotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvolutionBot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvolutionBotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    EvolutionBotSetting<T extends EvolutionBot$EvolutionBotSettingArgs<ExtArgs> = {}>(args?: Subset<T, EvolutionBot$EvolutionBotSettingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvolutionBot model
   */ 
  interface EvolutionBotFieldRefs {
    readonly id: FieldRef<"EvolutionBot", 'String'>
    readonly enabled: FieldRef<"EvolutionBot", 'Boolean'>
    readonly description: FieldRef<"EvolutionBot", 'String'>
    readonly apiUrl: FieldRef<"EvolutionBot", 'String'>
    readonly apiKey: FieldRef<"EvolutionBot", 'String'>
    readonly expire: FieldRef<"EvolutionBot", 'Int'>
    readonly keywordFinish: FieldRef<"EvolutionBot", 'String'>
    readonly delayMessage: FieldRef<"EvolutionBot", 'Int'>
    readonly unknownMessage: FieldRef<"EvolutionBot", 'String'>
    readonly listeningFromMe: FieldRef<"EvolutionBot", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"EvolutionBot", 'Boolean'>
    readonly keepOpen: FieldRef<"EvolutionBot", 'Boolean'>
    readonly debounceTime: FieldRef<"EvolutionBot", 'Int'>
    readonly ignoreJids: FieldRef<"EvolutionBot", 'Json'>
    readonly splitMessages: FieldRef<"EvolutionBot", 'Boolean'>
    readonly timePerChar: FieldRef<"EvolutionBot", 'Int'>
    readonly triggerType: FieldRef<"EvolutionBot", 'TriggerType'>
    readonly triggerOperator: FieldRef<"EvolutionBot", 'TriggerOperator'>
    readonly triggerValue: FieldRef<"EvolutionBot", 'String'>
    readonly createdAt: FieldRef<"EvolutionBot", 'DateTime'>
    readonly updatedAt: FieldRef<"EvolutionBot", 'DateTime'>
    readonly instanceId: FieldRef<"EvolutionBot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EvolutionBot findUnique
   */
  export type EvolutionBotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBot to fetch.
     */
    where: EvolutionBotWhereUniqueInput
  }

  /**
   * EvolutionBot findUniqueOrThrow
   */
  export type EvolutionBotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBot to fetch.
     */
    where: EvolutionBotWhereUniqueInput
  }

  /**
   * EvolutionBot findFirst
   */
  export type EvolutionBotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBot to fetch.
     */
    where?: EvolutionBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionBots to fetch.
     */
    orderBy?: EvolutionBotOrderByWithRelationInput | EvolutionBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolutionBots.
     */
    cursor?: EvolutionBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolutionBots.
     */
    distinct?: EvolutionBotScalarFieldEnum | EvolutionBotScalarFieldEnum[]
  }

  /**
   * EvolutionBot findFirstOrThrow
   */
  export type EvolutionBotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBot to fetch.
     */
    where?: EvolutionBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionBots to fetch.
     */
    orderBy?: EvolutionBotOrderByWithRelationInput | EvolutionBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolutionBots.
     */
    cursor?: EvolutionBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionBots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolutionBots.
     */
    distinct?: EvolutionBotScalarFieldEnum | EvolutionBotScalarFieldEnum[]
  }

  /**
   * EvolutionBot findMany
   */
  export type EvolutionBotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBots to fetch.
     */
    where?: EvolutionBotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionBots to fetch.
     */
    orderBy?: EvolutionBotOrderByWithRelationInput | EvolutionBotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvolutionBots.
     */
    cursor?: EvolutionBotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionBots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionBots.
     */
    skip?: number
    distinct?: EvolutionBotScalarFieldEnum | EvolutionBotScalarFieldEnum[]
  }

  /**
   * EvolutionBot create
   */
  export type EvolutionBotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    /**
     * The data needed to create a EvolutionBot.
     */
    data: XOR<EvolutionBotCreateInput, EvolutionBotUncheckedCreateInput>
  }

  /**
   * EvolutionBot createMany
   */
  export type EvolutionBotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvolutionBots.
     */
    data: EvolutionBotCreateManyInput | EvolutionBotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvolutionBot update
   */
  export type EvolutionBotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    /**
     * The data needed to update a EvolutionBot.
     */
    data: XOR<EvolutionBotUpdateInput, EvolutionBotUncheckedUpdateInput>
    /**
     * Choose, which EvolutionBot to update.
     */
    where: EvolutionBotWhereUniqueInput
  }

  /**
   * EvolutionBot updateMany
   */
  export type EvolutionBotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvolutionBots.
     */
    data: XOR<EvolutionBotUpdateManyMutationInput, EvolutionBotUncheckedUpdateManyInput>
    /**
     * Filter which EvolutionBots to update
     */
    where?: EvolutionBotWhereInput
    /**
     * Limit how many EvolutionBots to update.
     */
    limit?: number
  }

  /**
   * EvolutionBot upsert
   */
  export type EvolutionBotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    /**
     * The filter to search for the EvolutionBot to update in case it exists.
     */
    where: EvolutionBotWhereUniqueInput
    /**
     * In case the EvolutionBot found by the `where` argument doesn't exist, create a new EvolutionBot with this data.
     */
    create: XOR<EvolutionBotCreateInput, EvolutionBotUncheckedCreateInput>
    /**
     * In case the EvolutionBot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvolutionBotUpdateInput, EvolutionBotUncheckedUpdateInput>
  }

  /**
   * EvolutionBot delete
   */
  export type EvolutionBotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    /**
     * Filter which EvolutionBot to delete.
     */
    where: EvolutionBotWhereUniqueInput
  }

  /**
   * EvolutionBot deleteMany
   */
  export type EvolutionBotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolutionBots to delete
     */
    where?: EvolutionBotWhereInput
    /**
     * Limit how many EvolutionBots to delete.
     */
    limit?: number
  }

  /**
   * EvolutionBot.EvolutionBotSetting
   */
  export type EvolutionBot$EvolutionBotSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    where?: EvolutionBotSettingWhereInput
    orderBy?: EvolutionBotSettingOrderByWithRelationInput | EvolutionBotSettingOrderByWithRelationInput[]
    cursor?: EvolutionBotSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvolutionBotSettingScalarFieldEnum | EvolutionBotSettingScalarFieldEnum[]
  }

  /**
   * EvolutionBot without action
   */
  export type EvolutionBotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
  }


  /**
   * Model EvolutionBotSetting
   */

  export type AggregateEvolutionBotSetting = {
    _count: EvolutionBotSettingCountAggregateOutputType | null
    _avg: EvolutionBotSettingAvgAggregateOutputType | null
    _sum: EvolutionBotSettingSumAggregateOutputType | null
    _min: EvolutionBotSettingMinAggregateOutputType | null
    _max: EvolutionBotSettingMaxAggregateOutputType | null
  }

  export type EvolutionBotSettingAvgAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type EvolutionBotSettingSumAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type EvolutionBotSettingMinAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    createdAt: Date | null
    updatedAt: Date | null
    botIdFallback: string | null
    instanceId: string | null
  }

  export type EvolutionBotSettingMaxAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    createdAt: Date | null
    updatedAt: Date | null
    botIdFallback: string | null
    instanceId: string | null
  }

  export type EvolutionBotSettingCountAggregateOutputType = {
    id: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    ignoreJids: number
    splitMessages: number
    timePerChar: number
    createdAt: number
    updatedAt: number
    botIdFallback: number
    instanceId: number
    _all: number
  }


  export type EvolutionBotSettingAvgAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type EvolutionBotSettingSumAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type EvolutionBotSettingMinAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    createdAt?: true
    updatedAt?: true
    botIdFallback?: true
    instanceId?: true
  }

  export type EvolutionBotSettingMaxAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    createdAt?: true
    updatedAt?: true
    botIdFallback?: true
    instanceId?: true
  }

  export type EvolutionBotSettingCountAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    ignoreJids?: true
    splitMessages?: true
    timePerChar?: true
    createdAt?: true
    updatedAt?: true
    botIdFallback?: true
    instanceId?: true
    _all?: true
  }

  export type EvolutionBotSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolutionBotSetting to aggregate.
     */
    where?: EvolutionBotSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionBotSettings to fetch.
     */
    orderBy?: EvolutionBotSettingOrderByWithRelationInput | EvolutionBotSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvolutionBotSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionBotSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionBotSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvolutionBotSettings
    **/
    _count?: true | EvolutionBotSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvolutionBotSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvolutionBotSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvolutionBotSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvolutionBotSettingMaxAggregateInputType
  }

  export type GetEvolutionBotSettingAggregateType<T extends EvolutionBotSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolutionBotSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolutionBotSetting[P]>
      : GetScalarType<T[P], AggregateEvolutionBotSetting[P]>
  }




  export type EvolutionBotSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvolutionBotSettingWhereInput
    orderBy?: EvolutionBotSettingOrderByWithAggregationInput | EvolutionBotSettingOrderByWithAggregationInput[]
    by: EvolutionBotSettingScalarFieldEnum[] | EvolutionBotSettingScalarFieldEnum
    having?: EvolutionBotSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvolutionBotSettingCountAggregateInputType | true
    _avg?: EvolutionBotSettingAvgAggregateInputType
    _sum?: EvolutionBotSettingSumAggregateInputType
    _min?: EvolutionBotSettingMinAggregateInputType
    _max?: EvolutionBotSettingMaxAggregateInputType
  }

  export type EvolutionBotSettingGroupByOutputType = {
    id: string
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    ignoreJids: JsonValue | null
    splitMessages: boolean | null
    timePerChar: number | null
    createdAt: Date | null
    updatedAt: Date
    botIdFallback: string | null
    instanceId: string
    _count: EvolutionBotSettingCountAggregateOutputType | null
    _avg: EvolutionBotSettingAvgAggregateOutputType | null
    _sum: EvolutionBotSettingSumAggregateOutputType | null
    _min: EvolutionBotSettingMinAggregateOutputType | null
    _max: EvolutionBotSettingMaxAggregateOutputType | null
  }

  type GetEvolutionBotSettingGroupByPayload<T extends EvolutionBotSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvolutionBotSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvolutionBotSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvolutionBotSettingGroupByOutputType[P]>
            : GetScalarType<T[P], EvolutionBotSettingGroupByOutputType[P]>
        }
      >
    >


  export type EvolutionBotSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    botIdFallback?: boolean
    instanceId?: boolean
    Fallback?: boolean | EvolutionBotSetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evolutionBotSetting"]>



  export type EvolutionBotSettingSelectScalar = {
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    botIdFallback?: boolean
    instanceId?: boolean
  }

  export type EvolutionBotSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "ignoreJids" | "splitMessages" | "timePerChar" | "createdAt" | "updatedAt" | "botIdFallback" | "instanceId", ExtArgs["result"]["evolutionBotSetting"]>
  export type EvolutionBotSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Fallback?: boolean | EvolutionBotSetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $EvolutionBotSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvolutionBotSetting"
    objects: {
      Fallback: Prisma.$EvolutionBotPayload<ExtArgs> | null
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      ignoreJids: Prisma.JsonValue | null
      splitMessages: boolean | null
      timePerChar: number | null
      createdAt: Date | null
      updatedAt: Date
      botIdFallback: string | null
      instanceId: string
    }, ExtArgs["result"]["evolutionBotSetting"]>
    composites: {}
  }

  type EvolutionBotSettingGetPayload<S extends boolean | null | undefined | EvolutionBotSettingDefaultArgs> = $Result.GetResult<Prisma.$EvolutionBotSettingPayload, S>

  type EvolutionBotSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvolutionBotSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvolutionBotSettingCountAggregateInputType | true
    }

  export interface EvolutionBotSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvolutionBotSetting'], meta: { name: 'EvolutionBotSetting' } }
    /**
     * Find zero or one EvolutionBotSetting that matches the filter.
     * @param {EvolutionBotSettingFindUniqueArgs} args - Arguments to find a EvolutionBotSetting
     * @example
     * // Get one EvolutionBotSetting
     * const evolutionBotSetting = await prisma.evolutionBotSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvolutionBotSettingFindUniqueArgs>(args: SelectSubset<T, EvolutionBotSettingFindUniqueArgs<ExtArgs>>): Prisma__EvolutionBotSettingClient<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EvolutionBotSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvolutionBotSettingFindUniqueOrThrowArgs} args - Arguments to find a EvolutionBotSetting
     * @example
     * // Get one EvolutionBotSetting
     * const evolutionBotSetting = await prisma.evolutionBotSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvolutionBotSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, EvolutionBotSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvolutionBotSettingClient<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EvolutionBotSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotSettingFindFirstArgs} args - Arguments to find a EvolutionBotSetting
     * @example
     * // Get one EvolutionBotSetting
     * const evolutionBotSetting = await prisma.evolutionBotSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvolutionBotSettingFindFirstArgs>(args?: SelectSubset<T, EvolutionBotSettingFindFirstArgs<ExtArgs>>): Prisma__EvolutionBotSettingClient<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EvolutionBotSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotSettingFindFirstOrThrowArgs} args - Arguments to find a EvolutionBotSetting
     * @example
     * // Get one EvolutionBotSetting
     * const evolutionBotSetting = await prisma.evolutionBotSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvolutionBotSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, EvolutionBotSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvolutionBotSettingClient<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EvolutionBotSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvolutionBotSettings
     * const evolutionBotSettings = await prisma.evolutionBotSetting.findMany()
     * 
     * // Get first 10 EvolutionBotSettings
     * const evolutionBotSettings = await prisma.evolutionBotSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolutionBotSettingWithIdOnly = await prisma.evolutionBotSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvolutionBotSettingFindManyArgs>(args?: SelectSubset<T, EvolutionBotSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EvolutionBotSetting.
     * @param {EvolutionBotSettingCreateArgs} args - Arguments to create a EvolutionBotSetting.
     * @example
     * // Create one EvolutionBotSetting
     * const EvolutionBotSetting = await prisma.evolutionBotSetting.create({
     *   data: {
     *     // ... data to create a EvolutionBotSetting
     *   }
     * })
     * 
     */
    create<T extends EvolutionBotSettingCreateArgs>(args: SelectSubset<T, EvolutionBotSettingCreateArgs<ExtArgs>>): Prisma__EvolutionBotSettingClient<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EvolutionBotSettings.
     * @param {EvolutionBotSettingCreateManyArgs} args - Arguments to create many EvolutionBotSettings.
     * @example
     * // Create many EvolutionBotSettings
     * const evolutionBotSetting = await prisma.evolutionBotSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvolutionBotSettingCreateManyArgs>(args?: SelectSubset<T, EvolutionBotSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EvolutionBotSetting.
     * @param {EvolutionBotSettingDeleteArgs} args - Arguments to delete one EvolutionBotSetting.
     * @example
     * // Delete one EvolutionBotSetting
     * const EvolutionBotSetting = await prisma.evolutionBotSetting.delete({
     *   where: {
     *     // ... filter to delete one EvolutionBotSetting
     *   }
     * })
     * 
     */
    delete<T extends EvolutionBotSettingDeleteArgs>(args: SelectSubset<T, EvolutionBotSettingDeleteArgs<ExtArgs>>): Prisma__EvolutionBotSettingClient<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EvolutionBotSetting.
     * @param {EvolutionBotSettingUpdateArgs} args - Arguments to update one EvolutionBotSetting.
     * @example
     * // Update one EvolutionBotSetting
     * const evolutionBotSetting = await prisma.evolutionBotSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvolutionBotSettingUpdateArgs>(args: SelectSubset<T, EvolutionBotSettingUpdateArgs<ExtArgs>>): Prisma__EvolutionBotSettingClient<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EvolutionBotSettings.
     * @param {EvolutionBotSettingDeleteManyArgs} args - Arguments to filter EvolutionBotSettings to delete.
     * @example
     * // Delete a few EvolutionBotSettings
     * const { count } = await prisma.evolutionBotSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvolutionBotSettingDeleteManyArgs>(args?: SelectSubset<T, EvolutionBotSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvolutionBotSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvolutionBotSettings
     * const evolutionBotSetting = await prisma.evolutionBotSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvolutionBotSettingUpdateManyArgs>(args: SelectSubset<T, EvolutionBotSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvolutionBotSetting.
     * @param {EvolutionBotSettingUpsertArgs} args - Arguments to update or create a EvolutionBotSetting.
     * @example
     * // Update or create a EvolutionBotSetting
     * const evolutionBotSetting = await prisma.evolutionBotSetting.upsert({
     *   create: {
     *     // ... data to create a EvolutionBotSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvolutionBotSetting we want to update
     *   }
     * })
     */
    upsert<T extends EvolutionBotSettingUpsertArgs>(args: SelectSubset<T, EvolutionBotSettingUpsertArgs<ExtArgs>>): Prisma__EvolutionBotSettingClient<$Result.GetResult<Prisma.$EvolutionBotSettingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EvolutionBotSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotSettingCountArgs} args - Arguments to filter EvolutionBotSettings to count.
     * @example
     * // Count the number of EvolutionBotSettings
     * const count = await prisma.evolutionBotSetting.count({
     *   where: {
     *     // ... the filter for the EvolutionBotSettings we want to count
     *   }
     * })
    **/
    count<T extends EvolutionBotSettingCountArgs>(
      args?: Subset<T, EvolutionBotSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvolutionBotSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvolutionBotSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvolutionBotSettingAggregateArgs>(args: Subset<T, EvolutionBotSettingAggregateArgs>): Prisma.PrismaPromise<GetEvolutionBotSettingAggregateType<T>>

    /**
     * Group by EvolutionBotSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionBotSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvolutionBotSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvolutionBotSettingGroupByArgs['orderBy'] }
        : { orderBy?: EvolutionBotSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvolutionBotSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolutionBotSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvolutionBotSetting model
   */
  readonly fields: EvolutionBotSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvolutionBotSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvolutionBotSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Fallback<T extends EvolutionBotSetting$FallbackArgs<ExtArgs> = {}>(args?: Subset<T, EvolutionBotSetting$FallbackArgs<ExtArgs>>): Prisma__EvolutionBotClient<$Result.GetResult<Prisma.$EvolutionBotPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvolutionBotSetting model
   */ 
  interface EvolutionBotSettingFieldRefs {
    readonly id: FieldRef<"EvolutionBotSetting", 'String'>
    readonly expire: FieldRef<"EvolutionBotSetting", 'Int'>
    readonly keywordFinish: FieldRef<"EvolutionBotSetting", 'String'>
    readonly delayMessage: FieldRef<"EvolutionBotSetting", 'Int'>
    readonly unknownMessage: FieldRef<"EvolutionBotSetting", 'String'>
    readonly listeningFromMe: FieldRef<"EvolutionBotSetting", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"EvolutionBotSetting", 'Boolean'>
    readonly keepOpen: FieldRef<"EvolutionBotSetting", 'Boolean'>
    readonly debounceTime: FieldRef<"EvolutionBotSetting", 'Int'>
    readonly ignoreJids: FieldRef<"EvolutionBotSetting", 'Json'>
    readonly splitMessages: FieldRef<"EvolutionBotSetting", 'Boolean'>
    readonly timePerChar: FieldRef<"EvolutionBotSetting", 'Int'>
    readonly createdAt: FieldRef<"EvolutionBotSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"EvolutionBotSetting", 'DateTime'>
    readonly botIdFallback: FieldRef<"EvolutionBotSetting", 'String'>
    readonly instanceId: FieldRef<"EvolutionBotSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EvolutionBotSetting findUnique
   */
  export type EvolutionBotSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBotSetting to fetch.
     */
    where: EvolutionBotSettingWhereUniqueInput
  }

  /**
   * EvolutionBotSetting findUniqueOrThrow
   */
  export type EvolutionBotSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBotSetting to fetch.
     */
    where: EvolutionBotSettingWhereUniqueInput
  }

  /**
   * EvolutionBotSetting findFirst
   */
  export type EvolutionBotSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBotSetting to fetch.
     */
    where?: EvolutionBotSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionBotSettings to fetch.
     */
    orderBy?: EvolutionBotSettingOrderByWithRelationInput | EvolutionBotSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolutionBotSettings.
     */
    cursor?: EvolutionBotSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionBotSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionBotSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolutionBotSettings.
     */
    distinct?: EvolutionBotSettingScalarFieldEnum | EvolutionBotSettingScalarFieldEnum[]
  }

  /**
   * EvolutionBotSetting findFirstOrThrow
   */
  export type EvolutionBotSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBotSetting to fetch.
     */
    where?: EvolutionBotSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionBotSettings to fetch.
     */
    orderBy?: EvolutionBotSettingOrderByWithRelationInput | EvolutionBotSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvolutionBotSettings.
     */
    cursor?: EvolutionBotSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionBotSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionBotSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvolutionBotSettings.
     */
    distinct?: EvolutionBotSettingScalarFieldEnum | EvolutionBotSettingScalarFieldEnum[]
  }

  /**
   * EvolutionBotSetting findMany
   */
  export type EvolutionBotSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    /**
     * Filter, which EvolutionBotSettings to fetch.
     */
    where?: EvolutionBotSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvolutionBotSettings to fetch.
     */
    orderBy?: EvolutionBotSettingOrderByWithRelationInput | EvolutionBotSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvolutionBotSettings.
     */
    cursor?: EvolutionBotSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvolutionBotSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvolutionBotSettings.
     */
    skip?: number
    distinct?: EvolutionBotSettingScalarFieldEnum | EvolutionBotSettingScalarFieldEnum[]
  }

  /**
   * EvolutionBotSetting create
   */
  export type EvolutionBotSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a EvolutionBotSetting.
     */
    data: XOR<EvolutionBotSettingCreateInput, EvolutionBotSettingUncheckedCreateInput>
  }

  /**
   * EvolutionBotSetting createMany
   */
  export type EvolutionBotSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvolutionBotSettings.
     */
    data: EvolutionBotSettingCreateManyInput | EvolutionBotSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvolutionBotSetting update
   */
  export type EvolutionBotSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a EvolutionBotSetting.
     */
    data: XOR<EvolutionBotSettingUpdateInput, EvolutionBotSettingUncheckedUpdateInput>
    /**
     * Choose, which EvolutionBotSetting to update.
     */
    where: EvolutionBotSettingWhereUniqueInput
  }

  /**
   * EvolutionBotSetting updateMany
   */
  export type EvolutionBotSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvolutionBotSettings.
     */
    data: XOR<EvolutionBotSettingUpdateManyMutationInput, EvolutionBotSettingUncheckedUpdateManyInput>
    /**
     * Filter which EvolutionBotSettings to update
     */
    where?: EvolutionBotSettingWhereInput
    /**
     * Limit how many EvolutionBotSettings to update.
     */
    limit?: number
  }

  /**
   * EvolutionBotSetting upsert
   */
  export type EvolutionBotSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the EvolutionBotSetting to update in case it exists.
     */
    where: EvolutionBotSettingWhereUniqueInput
    /**
     * In case the EvolutionBotSetting found by the `where` argument doesn't exist, create a new EvolutionBotSetting with this data.
     */
    create: XOR<EvolutionBotSettingCreateInput, EvolutionBotSettingUncheckedCreateInput>
    /**
     * In case the EvolutionBotSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvolutionBotSettingUpdateInput, EvolutionBotSettingUncheckedUpdateInput>
  }

  /**
   * EvolutionBotSetting delete
   */
  export type EvolutionBotSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
    /**
     * Filter which EvolutionBotSetting to delete.
     */
    where: EvolutionBotSettingWhereUniqueInput
  }

  /**
   * EvolutionBotSetting deleteMany
   */
  export type EvolutionBotSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvolutionBotSettings to delete
     */
    where?: EvolutionBotSettingWhereInput
    /**
     * Limit how many EvolutionBotSettings to delete.
     */
    limit?: number
  }

  /**
   * EvolutionBotSetting.Fallback
   */
  export type EvolutionBotSetting$FallbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBot
     */
    select?: EvolutionBotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBot
     */
    omit?: EvolutionBotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotInclude<ExtArgs> | null
    where?: EvolutionBotWhereInput
  }

  /**
   * EvolutionBotSetting without action
   */
  export type EvolutionBotSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvolutionBotSetting
     */
    select?: EvolutionBotSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvolutionBotSetting
     */
    omit?: EvolutionBotSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvolutionBotSettingInclude<ExtArgs> | null
  }


  /**
   * Model Flowise
   */

  export type AggregateFlowise = {
    _count: FlowiseCountAggregateOutputType | null
    _avg: FlowiseAvgAggregateOutputType | null
    _sum: FlowiseSumAggregateOutputType | null
    _min: FlowiseMinAggregateOutputType | null
    _max: FlowiseMaxAggregateOutputType | null
  }

  export type FlowiseAvgAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type FlowiseSumAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type FlowiseMinAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    apiUrl: string | null
    apiKey: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type FlowiseMaxAggregateOutputType = {
    id: string | null
    enabled: boolean | null
    description: string | null
    apiUrl: string | null
    apiKey: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
    instanceId: string | null
  }

  export type FlowiseCountAggregateOutputType = {
    id: number
    enabled: number
    description: number
    apiUrl: number
    apiKey: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    ignoreJids: number
    splitMessages: number
    timePerChar: number
    triggerType: number
    triggerOperator: number
    triggerValue: number
    createdAt: number
    updatedAt: number
    instanceId: number
    _all: number
  }


  export type FlowiseAvgAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type FlowiseSumAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type FlowiseMinAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    apiUrl?: true
    apiKey?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type FlowiseMaxAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    apiUrl?: true
    apiKey?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
  }

  export type FlowiseCountAggregateInputType = {
    id?: true
    enabled?: true
    description?: true
    apiUrl?: true
    apiKey?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    ignoreJids?: true
    splitMessages?: true
    timePerChar?: true
    triggerType?: true
    triggerOperator?: true
    triggerValue?: true
    createdAt?: true
    updatedAt?: true
    instanceId?: true
    _all?: true
  }

  export type FlowiseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flowise to aggregate.
     */
    where?: FlowiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowises to fetch.
     */
    orderBy?: FlowiseOrderByWithRelationInput | FlowiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flowises
    **/
    _count?: true | FlowiseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlowiseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlowiseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowiseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowiseMaxAggregateInputType
  }

  export type GetFlowiseAggregateType<T extends FlowiseAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowise[P]>
      : GetScalarType<T[P], AggregateFlowise[P]>
  }




  export type FlowiseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowiseWhereInput
    orderBy?: FlowiseOrderByWithAggregationInput | FlowiseOrderByWithAggregationInput[]
    by: FlowiseScalarFieldEnum[] | FlowiseScalarFieldEnum
    having?: FlowiseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowiseCountAggregateInputType | true
    _avg?: FlowiseAvgAggregateInputType
    _sum?: FlowiseSumAggregateInputType
    _min?: FlowiseMinAggregateInputType
    _max?: FlowiseMaxAggregateInputType
  }

  export type FlowiseGroupByOutputType = {
    id: string
    enabled: boolean
    description: string | null
    apiUrl: string | null
    apiKey: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    ignoreJids: JsonValue | null
    splitMessages: boolean | null
    timePerChar: number | null
    triggerType: $Enums.TriggerType | null
    triggerOperator: $Enums.TriggerOperator | null
    triggerValue: string | null
    createdAt: Date | null
    updatedAt: Date
    instanceId: string
    _count: FlowiseCountAggregateOutputType | null
    _avg: FlowiseAvgAggregateOutputType | null
    _sum: FlowiseSumAggregateOutputType | null
    _min: FlowiseMinAggregateOutputType | null
    _max: FlowiseMaxAggregateOutputType | null
  }

  type GetFlowiseGroupByPayload<T extends FlowiseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowiseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowiseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowiseGroupByOutputType[P]>
            : GetScalarType<T[P], FlowiseGroupByOutputType[P]>
        }
      >
    >


  export type FlowiseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    description?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    FlowiseSetting?: boolean | Flowise$FlowiseSettingArgs<ExtArgs>
    _count?: boolean | FlowiseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowise"]>



  export type FlowiseSelectScalar = {
    id?: boolean
    enabled?: boolean
    description?: boolean
    apiUrl?: boolean
    apiKey?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    triggerType?: boolean
    triggerOperator?: boolean
    triggerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instanceId?: boolean
  }

  export type FlowiseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enabled" | "description" | "apiUrl" | "apiKey" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "ignoreJids" | "splitMessages" | "timePerChar" | "triggerType" | "triggerOperator" | "triggerValue" | "createdAt" | "updatedAt" | "instanceId", ExtArgs["result"]["flowise"]>
  export type FlowiseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
    FlowiseSetting?: boolean | Flowise$FlowiseSettingArgs<ExtArgs>
    _count?: boolean | FlowiseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FlowisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flowise"
    objects: {
      Instance: Prisma.$InstancePayload<ExtArgs>
      FlowiseSetting: Prisma.$FlowiseSettingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enabled: boolean
      description: string | null
      apiUrl: string | null
      apiKey: string | null
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      ignoreJids: Prisma.JsonValue | null
      splitMessages: boolean | null
      timePerChar: number | null
      triggerType: $Enums.TriggerType | null
      triggerOperator: $Enums.TriggerOperator | null
      triggerValue: string | null
      createdAt: Date | null
      updatedAt: Date
      instanceId: string
    }, ExtArgs["result"]["flowise"]>
    composites: {}
  }

  type FlowiseGetPayload<S extends boolean | null | undefined | FlowiseDefaultArgs> = $Result.GetResult<Prisma.$FlowisePayload, S>

  type FlowiseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowiseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowiseCountAggregateInputType | true
    }

  export interface FlowiseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flowise'], meta: { name: 'Flowise' } }
    /**
     * Find zero or one Flowise that matches the filter.
     * @param {FlowiseFindUniqueArgs} args - Arguments to find a Flowise
     * @example
     * // Get one Flowise
     * const flowise = await prisma.flowise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowiseFindUniqueArgs>(args: SelectSubset<T, FlowiseFindUniqueArgs<ExtArgs>>): Prisma__FlowiseClient<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Flowise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowiseFindUniqueOrThrowArgs} args - Arguments to find a Flowise
     * @example
     * // Get one Flowise
     * const flowise = await prisma.flowise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowiseFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowiseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowiseClient<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Flowise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseFindFirstArgs} args - Arguments to find a Flowise
     * @example
     * // Get one Flowise
     * const flowise = await prisma.flowise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowiseFindFirstArgs>(args?: SelectSubset<T, FlowiseFindFirstArgs<ExtArgs>>): Prisma__FlowiseClient<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Flowise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseFindFirstOrThrowArgs} args - Arguments to find a Flowise
     * @example
     * // Get one Flowise
     * const flowise = await prisma.flowise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowiseFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowiseFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowiseClient<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Flowises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flowises
     * const flowises = await prisma.flowise.findMany()
     * 
     * // Get first 10 Flowises
     * const flowises = await prisma.flowise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flowiseWithIdOnly = await prisma.flowise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlowiseFindManyArgs>(args?: SelectSubset<T, FlowiseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Flowise.
     * @param {FlowiseCreateArgs} args - Arguments to create a Flowise.
     * @example
     * // Create one Flowise
     * const Flowise = await prisma.flowise.create({
     *   data: {
     *     // ... data to create a Flowise
     *   }
     * })
     * 
     */
    create<T extends FlowiseCreateArgs>(args: SelectSubset<T, FlowiseCreateArgs<ExtArgs>>): Prisma__FlowiseClient<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Flowises.
     * @param {FlowiseCreateManyArgs} args - Arguments to create many Flowises.
     * @example
     * // Create many Flowises
     * const flowise = await prisma.flowise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowiseCreateManyArgs>(args?: SelectSubset<T, FlowiseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Flowise.
     * @param {FlowiseDeleteArgs} args - Arguments to delete one Flowise.
     * @example
     * // Delete one Flowise
     * const Flowise = await prisma.flowise.delete({
     *   where: {
     *     // ... filter to delete one Flowise
     *   }
     * })
     * 
     */
    delete<T extends FlowiseDeleteArgs>(args: SelectSubset<T, FlowiseDeleteArgs<ExtArgs>>): Prisma__FlowiseClient<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Flowise.
     * @param {FlowiseUpdateArgs} args - Arguments to update one Flowise.
     * @example
     * // Update one Flowise
     * const flowise = await prisma.flowise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowiseUpdateArgs>(args: SelectSubset<T, FlowiseUpdateArgs<ExtArgs>>): Prisma__FlowiseClient<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Flowises.
     * @param {FlowiseDeleteManyArgs} args - Arguments to filter Flowises to delete.
     * @example
     * // Delete a few Flowises
     * const { count } = await prisma.flowise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowiseDeleteManyArgs>(args?: SelectSubset<T, FlowiseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flowises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flowises
     * const flowise = await prisma.flowise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowiseUpdateManyArgs>(args: SelectSubset<T, FlowiseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flowise.
     * @param {FlowiseUpsertArgs} args - Arguments to update or create a Flowise.
     * @example
     * // Update or create a Flowise
     * const flowise = await prisma.flowise.upsert({
     *   create: {
     *     // ... data to create a Flowise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flowise we want to update
     *   }
     * })
     */
    upsert<T extends FlowiseUpsertArgs>(args: SelectSubset<T, FlowiseUpsertArgs<ExtArgs>>): Prisma__FlowiseClient<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Flowises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseCountArgs} args - Arguments to filter Flowises to count.
     * @example
     * // Count the number of Flowises
     * const count = await prisma.flowise.count({
     *   where: {
     *     // ... the filter for the Flowises we want to count
     *   }
     * })
    **/
    count<T extends FlowiseCountArgs>(
      args?: Subset<T, FlowiseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowiseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flowise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowiseAggregateArgs>(args: Subset<T, FlowiseAggregateArgs>): Prisma.PrismaPromise<GetFlowiseAggregateType<T>>

    /**
     * Group by Flowise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowiseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowiseGroupByArgs['orderBy'] }
        : { orderBy?: FlowiseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowiseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowiseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flowise model
   */
  readonly fields: FlowiseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flowise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowiseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    FlowiseSetting<T extends Flowise$FlowiseSettingArgs<ExtArgs> = {}>(args?: Subset<T, Flowise$FlowiseSettingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flowise model
   */ 
  interface FlowiseFieldRefs {
    readonly id: FieldRef<"Flowise", 'String'>
    readonly enabled: FieldRef<"Flowise", 'Boolean'>
    readonly description: FieldRef<"Flowise", 'String'>
    readonly apiUrl: FieldRef<"Flowise", 'String'>
    readonly apiKey: FieldRef<"Flowise", 'String'>
    readonly expire: FieldRef<"Flowise", 'Int'>
    readonly keywordFinish: FieldRef<"Flowise", 'String'>
    readonly delayMessage: FieldRef<"Flowise", 'Int'>
    readonly unknownMessage: FieldRef<"Flowise", 'String'>
    readonly listeningFromMe: FieldRef<"Flowise", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"Flowise", 'Boolean'>
    readonly keepOpen: FieldRef<"Flowise", 'Boolean'>
    readonly debounceTime: FieldRef<"Flowise", 'Int'>
    readonly ignoreJids: FieldRef<"Flowise", 'Json'>
    readonly splitMessages: FieldRef<"Flowise", 'Boolean'>
    readonly timePerChar: FieldRef<"Flowise", 'Int'>
    readonly triggerType: FieldRef<"Flowise", 'TriggerType'>
    readonly triggerOperator: FieldRef<"Flowise", 'TriggerOperator'>
    readonly triggerValue: FieldRef<"Flowise", 'String'>
    readonly createdAt: FieldRef<"Flowise", 'DateTime'>
    readonly updatedAt: FieldRef<"Flowise", 'DateTime'>
    readonly instanceId: FieldRef<"Flowise", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Flowise findUnique
   */
  export type FlowiseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    /**
     * Filter, which Flowise to fetch.
     */
    where: FlowiseWhereUniqueInput
  }

  /**
   * Flowise findUniqueOrThrow
   */
  export type FlowiseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    /**
     * Filter, which Flowise to fetch.
     */
    where: FlowiseWhereUniqueInput
  }

  /**
   * Flowise findFirst
   */
  export type FlowiseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    /**
     * Filter, which Flowise to fetch.
     */
    where?: FlowiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowises to fetch.
     */
    orderBy?: FlowiseOrderByWithRelationInput | FlowiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flowises.
     */
    cursor?: FlowiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flowises.
     */
    distinct?: FlowiseScalarFieldEnum | FlowiseScalarFieldEnum[]
  }

  /**
   * Flowise findFirstOrThrow
   */
  export type FlowiseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    /**
     * Filter, which Flowise to fetch.
     */
    where?: FlowiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowises to fetch.
     */
    orderBy?: FlowiseOrderByWithRelationInput | FlowiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flowises.
     */
    cursor?: FlowiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flowises.
     */
    distinct?: FlowiseScalarFieldEnum | FlowiseScalarFieldEnum[]
  }

  /**
   * Flowise findMany
   */
  export type FlowiseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    /**
     * Filter, which Flowises to fetch.
     */
    where?: FlowiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flowises to fetch.
     */
    orderBy?: FlowiseOrderByWithRelationInput | FlowiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flowises.
     */
    cursor?: FlowiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flowises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flowises.
     */
    skip?: number
    distinct?: FlowiseScalarFieldEnum | FlowiseScalarFieldEnum[]
  }

  /**
   * Flowise create
   */
  export type FlowiseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    /**
     * The data needed to create a Flowise.
     */
    data: XOR<FlowiseCreateInput, FlowiseUncheckedCreateInput>
  }

  /**
   * Flowise createMany
   */
  export type FlowiseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flowises.
     */
    data: FlowiseCreateManyInput | FlowiseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flowise update
   */
  export type FlowiseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    /**
     * The data needed to update a Flowise.
     */
    data: XOR<FlowiseUpdateInput, FlowiseUncheckedUpdateInput>
    /**
     * Choose, which Flowise to update.
     */
    where: FlowiseWhereUniqueInput
  }

  /**
   * Flowise updateMany
   */
  export type FlowiseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flowises.
     */
    data: XOR<FlowiseUpdateManyMutationInput, FlowiseUncheckedUpdateManyInput>
    /**
     * Filter which Flowises to update
     */
    where?: FlowiseWhereInput
    /**
     * Limit how many Flowises to update.
     */
    limit?: number
  }

  /**
   * Flowise upsert
   */
  export type FlowiseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    /**
     * The filter to search for the Flowise to update in case it exists.
     */
    where: FlowiseWhereUniqueInput
    /**
     * In case the Flowise found by the `where` argument doesn't exist, create a new Flowise with this data.
     */
    create: XOR<FlowiseCreateInput, FlowiseUncheckedCreateInput>
    /**
     * In case the Flowise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowiseUpdateInput, FlowiseUncheckedUpdateInput>
  }

  /**
   * Flowise delete
   */
  export type FlowiseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    /**
     * Filter which Flowise to delete.
     */
    where: FlowiseWhereUniqueInput
  }

  /**
   * Flowise deleteMany
   */
  export type FlowiseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flowises to delete
     */
    where?: FlowiseWhereInput
    /**
     * Limit how many Flowises to delete.
     */
    limit?: number
  }

  /**
   * Flowise.FlowiseSetting
   */
  export type Flowise$FlowiseSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    where?: FlowiseSettingWhereInput
    orderBy?: FlowiseSettingOrderByWithRelationInput | FlowiseSettingOrderByWithRelationInput[]
    cursor?: FlowiseSettingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlowiseSettingScalarFieldEnum | FlowiseSettingScalarFieldEnum[]
  }

  /**
   * Flowise without action
   */
  export type FlowiseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
  }


  /**
   * Model FlowiseSetting
   */

  export type AggregateFlowiseSetting = {
    _count: FlowiseSettingCountAggregateOutputType | null
    _avg: FlowiseSettingAvgAggregateOutputType | null
    _sum: FlowiseSettingSumAggregateOutputType | null
    _min: FlowiseSettingMinAggregateOutputType | null
    _max: FlowiseSettingMaxAggregateOutputType | null
  }

  export type FlowiseSettingAvgAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type FlowiseSettingSumAggregateOutputType = {
    expire: number | null
    delayMessage: number | null
    debounceTime: number | null
    timePerChar: number | null
  }

  export type FlowiseSettingMinAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    createdAt: Date | null
    updatedAt: Date | null
    flowiseIdFallback: string | null
    instanceId: string | null
  }

  export type FlowiseSettingMaxAggregateOutputType = {
    id: string | null
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    splitMessages: boolean | null
    timePerChar: number | null
    createdAt: Date | null
    updatedAt: Date | null
    flowiseIdFallback: string | null
    instanceId: string | null
  }

  export type FlowiseSettingCountAggregateOutputType = {
    id: number
    expire: number
    keywordFinish: number
    delayMessage: number
    unknownMessage: number
    listeningFromMe: number
    stopBotFromMe: number
    keepOpen: number
    debounceTime: number
    ignoreJids: number
    splitMessages: number
    timePerChar: number
    createdAt: number
    updatedAt: number
    flowiseIdFallback: number
    instanceId: number
    _all: number
  }


  export type FlowiseSettingAvgAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type FlowiseSettingSumAggregateInputType = {
    expire?: true
    delayMessage?: true
    debounceTime?: true
    timePerChar?: true
  }

  export type FlowiseSettingMinAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    createdAt?: true
    updatedAt?: true
    flowiseIdFallback?: true
    instanceId?: true
  }

  export type FlowiseSettingMaxAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    splitMessages?: true
    timePerChar?: true
    createdAt?: true
    updatedAt?: true
    flowiseIdFallback?: true
    instanceId?: true
  }

  export type FlowiseSettingCountAggregateInputType = {
    id?: true
    expire?: true
    keywordFinish?: true
    delayMessage?: true
    unknownMessage?: true
    listeningFromMe?: true
    stopBotFromMe?: true
    keepOpen?: true
    debounceTime?: true
    ignoreJids?: true
    splitMessages?: true
    timePerChar?: true
    createdAt?: true
    updatedAt?: true
    flowiseIdFallback?: true
    instanceId?: true
    _all?: true
  }

  export type FlowiseSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowiseSetting to aggregate.
     */
    where?: FlowiseSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowiseSettings to fetch.
     */
    orderBy?: FlowiseSettingOrderByWithRelationInput | FlowiseSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlowiseSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowiseSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowiseSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlowiseSettings
    **/
    _count?: true | FlowiseSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlowiseSettingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlowiseSettingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlowiseSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlowiseSettingMaxAggregateInputType
  }

  export type GetFlowiseSettingAggregateType<T extends FlowiseSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateFlowiseSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlowiseSetting[P]>
      : GetScalarType<T[P], AggregateFlowiseSetting[P]>
  }




  export type FlowiseSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlowiseSettingWhereInput
    orderBy?: FlowiseSettingOrderByWithAggregationInput | FlowiseSettingOrderByWithAggregationInput[]
    by: FlowiseSettingScalarFieldEnum[] | FlowiseSettingScalarFieldEnum
    having?: FlowiseSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlowiseSettingCountAggregateInputType | true
    _avg?: FlowiseSettingAvgAggregateInputType
    _sum?: FlowiseSettingSumAggregateInputType
    _min?: FlowiseSettingMinAggregateInputType
    _max?: FlowiseSettingMaxAggregateInputType
  }

  export type FlowiseSettingGroupByOutputType = {
    id: string
    expire: number | null
    keywordFinish: string | null
    delayMessage: number | null
    unknownMessage: string | null
    listeningFromMe: boolean | null
    stopBotFromMe: boolean | null
    keepOpen: boolean | null
    debounceTime: number | null
    ignoreJids: JsonValue | null
    splitMessages: boolean | null
    timePerChar: number | null
    createdAt: Date | null
    updatedAt: Date
    flowiseIdFallback: string | null
    instanceId: string
    _count: FlowiseSettingCountAggregateOutputType | null
    _avg: FlowiseSettingAvgAggregateOutputType | null
    _sum: FlowiseSettingSumAggregateOutputType | null
    _min: FlowiseSettingMinAggregateOutputType | null
    _max: FlowiseSettingMaxAggregateOutputType | null
  }

  type GetFlowiseSettingGroupByPayload<T extends FlowiseSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlowiseSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlowiseSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlowiseSettingGroupByOutputType[P]>
            : GetScalarType<T[P], FlowiseSettingGroupByOutputType[P]>
        }
      >
    >


  export type FlowiseSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flowiseIdFallback?: boolean
    instanceId?: boolean
    Fallback?: boolean | FlowiseSetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flowiseSetting"]>



  export type FlowiseSettingSelectScalar = {
    id?: boolean
    expire?: boolean
    keywordFinish?: boolean
    delayMessage?: boolean
    unknownMessage?: boolean
    listeningFromMe?: boolean
    stopBotFromMe?: boolean
    keepOpen?: boolean
    debounceTime?: boolean
    ignoreJids?: boolean
    splitMessages?: boolean
    timePerChar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flowiseIdFallback?: boolean
    instanceId?: boolean
  }

  export type FlowiseSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expire" | "keywordFinish" | "delayMessage" | "unknownMessage" | "listeningFromMe" | "stopBotFromMe" | "keepOpen" | "debounceTime" | "ignoreJids" | "splitMessages" | "timePerChar" | "createdAt" | "updatedAt" | "flowiseIdFallback" | "instanceId", ExtArgs["result"]["flowiseSetting"]>
  export type FlowiseSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Fallback?: boolean | FlowiseSetting$FallbackArgs<ExtArgs>
    Instance?: boolean | InstanceDefaultArgs<ExtArgs>
  }

  export type $FlowiseSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlowiseSetting"
    objects: {
      Fallback: Prisma.$FlowisePayload<ExtArgs> | null
      Instance: Prisma.$InstancePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expire: number | null
      keywordFinish: string | null
      delayMessage: number | null
      unknownMessage: string | null
      listeningFromMe: boolean | null
      stopBotFromMe: boolean | null
      keepOpen: boolean | null
      debounceTime: number | null
      ignoreJids: Prisma.JsonValue | null
      splitMessages: boolean | null
      timePerChar: number | null
      createdAt: Date | null
      updatedAt: Date
      flowiseIdFallback: string | null
      instanceId: string
    }, ExtArgs["result"]["flowiseSetting"]>
    composites: {}
  }

  type FlowiseSettingGetPayload<S extends boolean | null | undefined | FlowiseSettingDefaultArgs> = $Result.GetResult<Prisma.$FlowiseSettingPayload, S>

  type FlowiseSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlowiseSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlowiseSettingCountAggregateInputType | true
    }

  export interface FlowiseSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlowiseSetting'], meta: { name: 'FlowiseSetting' } }
    /**
     * Find zero or one FlowiseSetting that matches the filter.
     * @param {FlowiseSettingFindUniqueArgs} args - Arguments to find a FlowiseSetting
     * @example
     * // Get one FlowiseSetting
     * const flowiseSetting = await prisma.flowiseSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlowiseSettingFindUniqueArgs>(args: SelectSubset<T, FlowiseSettingFindUniqueArgs<ExtArgs>>): Prisma__FlowiseSettingClient<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FlowiseSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlowiseSettingFindUniqueOrThrowArgs} args - Arguments to find a FlowiseSetting
     * @example
     * // Get one FlowiseSetting
     * const flowiseSetting = await prisma.flowiseSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlowiseSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, FlowiseSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlowiseSettingClient<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FlowiseSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseSettingFindFirstArgs} args - Arguments to find a FlowiseSetting
     * @example
     * // Get one FlowiseSetting
     * const flowiseSetting = await prisma.flowiseSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlowiseSettingFindFirstArgs>(args?: SelectSubset<T, FlowiseSettingFindFirstArgs<ExtArgs>>): Prisma__FlowiseSettingClient<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FlowiseSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseSettingFindFirstOrThrowArgs} args - Arguments to find a FlowiseSetting
     * @example
     * // Get one FlowiseSetting
     * const flowiseSetting = await prisma.flowiseSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlowiseSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, FlowiseSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlowiseSettingClient<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FlowiseSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlowiseSettings
     * const flowiseSettings = await prisma.flowiseSetting.findMany()
     * 
     * // Get first 10 FlowiseSettings
     * const flowiseSettings = await prisma.flowiseSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flowiseSettingWithIdOnly = await prisma.flowiseSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlowiseSettingFindManyArgs>(args?: SelectSubset<T, FlowiseSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FlowiseSetting.
     * @param {FlowiseSettingCreateArgs} args - Arguments to create a FlowiseSetting.
     * @example
     * // Create one FlowiseSetting
     * const FlowiseSetting = await prisma.flowiseSetting.create({
     *   data: {
     *     // ... data to create a FlowiseSetting
     *   }
     * })
     * 
     */
    create<T extends FlowiseSettingCreateArgs>(args: SelectSubset<T, FlowiseSettingCreateArgs<ExtArgs>>): Prisma__FlowiseSettingClient<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FlowiseSettings.
     * @param {FlowiseSettingCreateManyArgs} args - Arguments to create many FlowiseSettings.
     * @example
     * // Create many FlowiseSettings
     * const flowiseSetting = await prisma.flowiseSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlowiseSettingCreateManyArgs>(args?: SelectSubset<T, FlowiseSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FlowiseSetting.
     * @param {FlowiseSettingDeleteArgs} args - Arguments to delete one FlowiseSetting.
     * @example
     * // Delete one FlowiseSetting
     * const FlowiseSetting = await prisma.flowiseSetting.delete({
     *   where: {
     *     // ... filter to delete one FlowiseSetting
     *   }
     * })
     * 
     */
    delete<T extends FlowiseSettingDeleteArgs>(args: SelectSubset<T, FlowiseSettingDeleteArgs<ExtArgs>>): Prisma__FlowiseSettingClient<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FlowiseSetting.
     * @param {FlowiseSettingUpdateArgs} args - Arguments to update one FlowiseSetting.
     * @example
     * // Update one FlowiseSetting
     * const flowiseSetting = await prisma.flowiseSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlowiseSettingUpdateArgs>(args: SelectSubset<T, FlowiseSettingUpdateArgs<ExtArgs>>): Prisma__FlowiseSettingClient<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FlowiseSettings.
     * @param {FlowiseSettingDeleteManyArgs} args - Arguments to filter FlowiseSettings to delete.
     * @example
     * // Delete a few FlowiseSettings
     * const { count } = await prisma.flowiseSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlowiseSettingDeleteManyArgs>(args?: SelectSubset<T, FlowiseSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlowiseSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlowiseSettings
     * const flowiseSetting = await prisma.flowiseSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlowiseSettingUpdateManyArgs>(args: SelectSubset<T, FlowiseSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlowiseSetting.
     * @param {FlowiseSettingUpsertArgs} args - Arguments to update or create a FlowiseSetting.
     * @example
     * // Update or create a FlowiseSetting
     * const flowiseSetting = await prisma.flowiseSetting.upsert({
     *   create: {
     *     // ... data to create a FlowiseSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlowiseSetting we want to update
     *   }
     * })
     */
    upsert<T extends FlowiseSettingUpsertArgs>(args: SelectSubset<T, FlowiseSettingUpsertArgs<ExtArgs>>): Prisma__FlowiseSettingClient<$Result.GetResult<Prisma.$FlowiseSettingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FlowiseSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseSettingCountArgs} args - Arguments to filter FlowiseSettings to count.
     * @example
     * // Count the number of FlowiseSettings
     * const count = await prisma.flowiseSetting.count({
     *   where: {
     *     // ... the filter for the FlowiseSettings we want to count
     *   }
     * })
    **/
    count<T extends FlowiseSettingCountArgs>(
      args?: Subset<T, FlowiseSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlowiseSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlowiseSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlowiseSettingAggregateArgs>(args: Subset<T, FlowiseSettingAggregateArgs>): Prisma.PrismaPromise<GetFlowiseSettingAggregateType<T>>

    /**
     * Group by FlowiseSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlowiseSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlowiseSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlowiseSettingGroupByArgs['orderBy'] }
        : { orderBy?: FlowiseSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlowiseSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlowiseSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlowiseSetting model
   */
  readonly fields: FlowiseSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlowiseSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlowiseSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Fallback<T extends FlowiseSetting$FallbackArgs<ExtArgs> = {}>(args?: Subset<T, FlowiseSetting$FallbackArgs<ExtArgs>>): Prisma__FlowiseClient<$Result.GetResult<Prisma.$FlowisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    Instance<T extends InstanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstanceDefaultArgs<ExtArgs>>): Prisma__InstanceClient<$Result.GetResult<Prisma.$InstancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlowiseSetting model
   */ 
  interface FlowiseSettingFieldRefs {
    readonly id: FieldRef<"FlowiseSetting", 'String'>
    readonly expire: FieldRef<"FlowiseSetting", 'Int'>
    readonly keywordFinish: FieldRef<"FlowiseSetting", 'String'>
    readonly delayMessage: FieldRef<"FlowiseSetting", 'Int'>
    readonly unknownMessage: FieldRef<"FlowiseSetting", 'String'>
    readonly listeningFromMe: FieldRef<"FlowiseSetting", 'Boolean'>
    readonly stopBotFromMe: FieldRef<"FlowiseSetting", 'Boolean'>
    readonly keepOpen: FieldRef<"FlowiseSetting", 'Boolean'>
    readonly debounceTime: FieldRef<"FlowiseSetting", 'Int'>
    readonly ignoreJids: FieldRef<"FlowiseSetting", 'Json'>
    readonly splitMessages: FieldRef<"FlowiseSetting", 'Boolean'>
    readonly timePerChar: FieldRef<"FlowiseSetting", 'Int'>
    readonly createdAt: FieldRef<"FlowiseSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"FlowiseSetting", 'DateTime'>
    readonly flowiseIdFallback: FieldRef<"FlowiseSetting", 'String'>
    readonly instanceId: FieldRef<"FlowiseSetting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FlowiseSetting findUnique
   */
  export type FlowiseSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    /**
     * Filter, which FlowiseSetting to fetch.
     */
    where: FlowiseSettingWhereUniqueInput
  }

  /**
   * FlowiseSetting findUniqueOrThrow
   */
  export type FlowiseSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    /**
     * Filter, which FlowiseSetting to fetch.
     */
    where: FlowiseSettingWhereUniqueInput
  }

  /**
   * FlowiseSetting findFirst
   */
  export type FlowiseSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    /**
     * Filter, which FlowiseSetting to fetch.
     */
    where?: FlowiseSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowiseSettings to fetch.
     */
    orderBy?: FlowiseSettingOrderByWithRelationInput | FlowiseSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowiseSettings.
     */
    cursor?: FlowiseSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowiseSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowiseSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowiseSettings.
     */
    distinct?: FlowiseSettingScalarFieldEnum | FlowiseSettingScalarFieldEnum[]
  }

  /**
   * FlowiseSetting findFirstOrThrow
   */
  export type FlowiseSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    /**
     * Filter, which FlowiseSetting to fetch.
     */
    where?: FlowiseSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowiseSettings to fetch.
     */
    orderBy?: FlowiseSettingOrderByWithRelationInput | FlowiseSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlowiseSettings.
     */
    cursor?: FlowiseSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowiseSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowiseSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlowiseSettings.
     */
    distinct?: FlowiseSettingScalarFieldEnum | FlowiseSettingScalarFieldEnum[]
  }

  /**
   * FlowiseSetting findMany
   */
  export type FlowiseSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    /**
     * Filter, which FlowiseSettings to fetch.
     */
    where?: FlowiseSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlowiseSettings to fetch.
     */
    orderBy?: FlowiseSettingOrderByWithRelationInput | FlowiseSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlowiseSettings.
     */
    cursor?: FlowiseSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlowiseSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlowiseSettings.
     */
    skip?: number
    distinct?: FlowiseSettingScalarFieldEnum | FlowiseSettingScalarFieldEnum[]
  }

  /**
   * FlowiseSetting create
   */
  export type FlowiseSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a FlowiseSetting.
     */
    data: XOR<FlowiseSettingCreateInput, FlowiseSettingUncheckedCreateInput>
  }

  /**
   * FlowiseSetting createMany
   */
  export type FlowiseSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlowiseSettings.
     */
    data: FlowiseSettingCreateManyInput | FlowiseSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlowiseSetting update
   */
  export type FlowiseSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a FlowiseSetting.
     */
    data: XOR<FlowiseSettingUpdateInput, FlowiseSettingUncheckedUpdateInput>
    /**
     * Choose, which FlowiseSetting to update.
     */
    where: FlowiseSettingWhereUniqueInput
  }

  /**
   * FlowiseSetting updateMany
   */
  export type FlowiseSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlowiseSettings.
     */
    data: XOR<FlowiseSettingUpdateManyMutationInput, FlowiseSettingUncheckedUpdateManyInput>
    /**
     * Filter which FlowiseSettings to update
     */
    where?: FlowiseSettingWhereInput
    /**
     * Limit how many FlowiseSettings to update.
     */
    limit?: number
  }

  /**
   * FlowiseSetting upsert
   */
  export type FlowiseSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the FlowiseSetting to update in case it exists.
     */
    where: FlowiseSettingWhereUniqueInput
    /**
     * In case the FlowiseSetting found by the `where` argument doesn't exist, create a new FlowiseSetting with this data.
     */
    create: XOR<FlowiseSettingCreateInput, FlowiseSettingUncheckedCreateInput>
    /**
     * In case the FlowiseSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlowiseSettingUpdateInput, FlowiseSettingUncheckedUpdateInput>
  }

  /**
   * FlowiseSetting delete
   */
  export type FlowiseSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
    /**
     * Filter which FlowiseSetting to delete.
     */
    where: FlowiseSettingWhereUniqueInput
  }

  /**
   * FlowiseSetting deleteMany
   */
  export type FlowiseSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlowiseSettings to delete
     */
    where?: FlowiseSettingWhereInput
    /**
     * Limit how many FlowiseSettings to delete.
     */
    limit?: number
  }

  /**
   * FlowiseSetting.Fallback
   */
  export type FlowiseSetting$FallbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flowise
     */
    select?: FlowiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flowise
     */
    omit?: FlowiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseInclude<ExtArgs> | null
    where?: FlowiseWhereInput
  }

  /**
   * FlowiseSetting without action
   */
  export type FlowiseSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlowiseSetting
     */
    select?: FlowiseSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlowiseSetting
     */
    omit?: FlowiseSettingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlowiseSettingInclude<ExtArgs> | null
  }


  /**
   * Model IsOnWhatsapp
   */

  export type AggregateIsOnWhatsapp = {
    _count: IsOnWhatsappCountAggregateOutputType | null
    _min: IsOnWhatsappMinAggregateOutputType | null
    _max: IsOnWhatsappMaxAggregateOutputType | null
  }

  export type IsOnWhatsappMinAggregateOutputType = {
    id: string | null
    remoteJid: string | null
    jidOptions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IsOnWhatsappMaxAggregateOutputType = {
    id: string | null
    remoteJid: string | null
    jidOptions: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IsOnWhatsappCountAggregateOutputType = {
    id: number
    remoteJid: number
    jidOptions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IsOnWhatsappMinAggregateInputType = {
    id?: true
    remoteJid?: true
    jidOptions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IsOnWhatsappMaxAggregateInputType = {
    id?: true
    remoteJid?: true
    jidOptions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IsOnWhatsappCountAggregateInputType = {
    id?: true
    remoteJid?: true
    jidOptions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IsOnWhatsappAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IsOnWhatsapp to aggregate.
     */
    where?: IsOnWhatsappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IsOnWhatsapps to fetch.
     */
    orderBy?: IsOnWhatsappOrderByWithRelationInput | IsOnWhatsappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IsOnWhatsappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IsOnWhatsapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IsOnWhatsapps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IsOnWhatsapps
    **/
    _count?: true | IsOnWhatsappCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IsOnWhatsappMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IsOnWhatsappMaxAggregateInputType
  }

  export type GetIsOnWhatsappAggregateType<T extends IsOnWhatsappAggregateArgs> = {
        [P in keyof T & keyof AggregateIsOnWhatsapp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIsOnWhatsapp[P]>
      : GetScalarType<T[P], AggregateIsOnWhatsapp[P]>
  }




  export type IsOnWhatsappGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IsOnWhatsappWhereInput
    orderBy?: IsOnWhatsappOrderByWithAggregationInput | IsOnWhatsappOrderByWithAggregationInput[]
    by: IsOnWhatsappScalarFieldEnum[] | IsOnWhatsappScalarFieldEnum
    having?: IsOnWhatsappScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IsOnWhatsappCountAggregateInputType | true
    _min?: IsOnWhatsappMinAggregateInputType
    _max?: IsOnWhatsappMaxAggregateInputType
  }

  export type IsOnWhatsappGroupByOutputType = {
    id: string
    remoteJid: string
    jidOptions: string
    createdAt: Date
    updatedAt: Date
    _count: IsOnWhatsappCountAggregateOutputType | null
    _min: IsOnWhatsappMinAggregateOutputType | null
    _max: IsOnWhatsappMaxAggregateOutputType | null
  }

  type GetIsOnWhatsappGroupByPayload<T extends IsOnWhatsappGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IsOnWhatsappGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IsOnWhatsappGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IsOnWhatsappGroupByOutputType[P]>
            : GetScalarType<T[P], IsOnWhatsappGroupByOutputType[P]>
        }
      >
    >


  export type IsOnWhatsappSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    remoteJid?: boolean
    jidOptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["isOnWhatsapp"]>



  export type IsOnWhatsappSelectScalar = {
    id?: boolean
    remoteJid?: boolean
    jidOptions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IsOnWhatsappOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "remoteJid" | "jidOptions" | "createdAt" | "updatedAt", ExtArgs["result"]["isOnWhatsapp"]>

  export type $IsOnWhatsappPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IsOnWhatsapp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      remoteJid: string
      jidOptions: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["isOnWhatsapp"]>
    composites: {}
  }

  type IsOnWhatsappGetPayload<S extends boolean | null | undefined | IsOnWhatsappDefaultArgs> = $Result.GetResult<Prisma.$IsOnWhatsappPayload, S>

  type IsOnWhatsappCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IsOnWhatsappFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IsOnWhatsappCountAggregateInputType | true
    }

  export interface IsOnWhatsappDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IsOnWhatsapp'], meta: { name: 'IsOnWhatsapp' } }
    /**
     * Find zero or one IsOnWhatsapp that matches the filter.
     * @param {IsOnWhatsappFindUniqueArgs} args - Arguments to find a IsOnWhatsapp
     * @example
     * // Get one IsOnWhatsapp
     * const isOnWhatsapp = await prisma.isOnWhatsapp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IsOnWhatsappFindUniqueArgs>(args: SelectSubset<T, IsOnWhatsappFindUniqueArgs<ExtArgs>>): Prisma__IsOnWhatsappClient<$Result.GetResult<Prisma.$IsOnWhatsappPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one IsOnWhatsapp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IsOnWhatsappFindUniqueOrThrowArgs} args - Arguments to find a IsOnWhatsapp
     * @example
     * // Get one IsOnWhatsapp
     * const isOnWhatsapp = await prisma.isOnWhatsapp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IsOnWhatsappFindUniqueOrThrowArgs>(args: SelectSubset<T, IsOnWhatsappFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IsOnWhatsappClient<$Result.GetResult<Prisma.$IsOnWhatsappPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first IsOnWhatsapp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IsOnWhatsappFindFirstArgs} args - Arguments to find a IsOnWhatsapp
     * @example
     * // Get one IsOnWhatsapp
     * const isOnWhatsapp = await prisma.isOnWhatsapp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IsOnWhatsappFindFirstArgs>(args?: SelectSubset<T, IsOnWhatsappFindFirstArgs<ExtArgs>>): Prisma__IsOnWhatsappClient<$Result.GetResult<Prisma.$IsOnWhatsappPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first IsOnWhatsapp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IsOnWhatsappFindFirstOrThrowArgs} args - Arguments to find a IsOnWhatsapp
     * @example
     * // Get one IsOnWhatsapp
     * const isOnWhatsapp = await prisma.isOnWhatsapp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IsOnWhatsappFindFirstOrThrowArgs>(args?: SelectSubset<T, IsOnWhatsappFindFirstOrThrowArgs<ExtArgs>>): Prisma__IsOnWhatsappClient<$Result.GetResult<Prisma.$IsOnWhatsappPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more IsOnWhatsapps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IsOnWhatsappFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IsOnWhatsapps
     * const isOnWhatsapps = await prisma.isOnWhatsapp.findMany()
     * 
     * // Get first 10 IsOnWhatsapps
     * const isOnWhatsapps = await prisma.isOnWhatsapp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const isOnWhatsappWithIdOnly = await prisma.isOnWhatsapp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IsOnWhatsappFindManyArgs>(args?: SelectSubset<T, IsOnWhatsappFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IsOnWhatsappPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a IsOnWhatsapp.
     * @param {IsOnWhatsappCreateArgs} args - Arguments to create a IsOnWhatsapp.
     * @example
     * // Create one IsOnWhatsapp
     * const IsOnWhatsapp = await prisma.isOnWhatsapp.create({
     *   data: {
     *     // ... data to create a IsOnWhatsapp
     *   }
     * })
     * 
     */
    create<T extends IsOnWhatsappCreateArgs>(args: SelectSubset<T, IsOnWhatsappCreateArgs<ExtArgs>>): Prisma__IsOnWhatsappClient<$Result.GetResult<Prisma.$IsOnWhatsappPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many IsOnWhatsapps.
     * @param {IsOnWhatsappCreateManyArgs} args - Arguments to create many IsOnWhatsapps.
     * @example
     * // Create many IsOnWhatsapps
     * const isOnWhatsapp = await prisma.isOnWhatsapp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IsOnWhatsappCreateManyArgs>(args?: SelectSubset<T, IsOnWhatsappCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IsOnWhatsapp.
     * @param {IsOnWhatsappDeleteArgs} args - Arguments to delete one IsOnWhatsapp.
     * @example
     * // Delete one IsOnWhatsapp
     * const IsOnWhatsapp = await prisma.isOnWhatsapp.delete({
     *   where: {
     *     // ... filter to delete one IsOnWhatsapp
     *   }
     * })
     * 
     */
    delete<T extends IsOnWhatsappDeleteArgs>(args: SelectSubset<T, IsOnWhatsappDeleteArgs<ExtArgs>>): Prisma__IsOnWhatsappClient<$Result.GetResult<Prisma.$IsOnWhatsappPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one IsOnWhatsapp.
     * @param {IsOnWhatsappUpdateArgs} args - Arguments to update one IsOnWhatsapp.
     * @example
     * // Update one IsOnWhatsapp
     * const isOnWhatsapp = await prisma.isOnWhatsapp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IsOnWhatsappUpdateArgs>(args: SelectSubset<T, IsOnWhatsappUpdateArgs<ExtArgs>>): Prisma__IsOnWhatsappClient<$Result.GetResult<Prisma.$IsOnWhatsappPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more IsOnWhatsapps.
     * @param {IsOnWhatsappDeleteManyArgs} args - Arguments to filter IsOnWhatsapps to delete.
     * @example
     * // Delete a few IsOnWhatsapps
     * const { count } = await prisma.isOnWhatsapp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IsOnWhatsappDeleteManyArgs>(args?: SelectSubset<T, IsOnWhatsappDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IsOnWhatsapps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IsOnWhatsappUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IsOnWhatsapps
     * const isOnWhatsapp = await prisma.isOnWhatsapp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IsOnWhatsappUpdateManyArgs>(args: SelectSubset<T, IsOnWhatsappUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IsOnWhatsapp.
     * @param {IsOnWhatsappUpsertArgs} args - Arguments to update or create a IsOnWhatsapp.
     * @example
     * // Update or create a IsOnWhatsapp
     * const isOnWhatsapp = await prisma.isOnWhatsapp.upsert({
     *   create: {
     *     // ... data to create a IsOnWhatsapp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IsOnWhatsapp we want to update
     *   }
     * })
     */
    upsert<T extends IsOnWhatsappUpsertArgs>(args: SelectSubset<T, IsOnWhatsappUpsertArgs<ExtArgs>>): Prisma__IsOnWhatsappClient<$Result.GetResult<Prisma.$IsOnWhatsappPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of IsOnWhatsapps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IsOnWhatsappCountArgs} args - Arguments to filter IsOnWhatsapps to count.
     * @example
     * // Count the number of IsOnWhatsapps
     * const count = await prisma.isOnWhatsapp.count({
     *   where: {
     *     // ... the filter for the IsOnWhatsapps we want to count
     *   }
     * })
    **/
    count<T extends IsOnWhatsappCountArgs>(
      args?: Subset<T, IsOnWhatsappCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IsOnWhatsappCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IsOnWhatsapp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IsOnWhatsappAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IsOnWhatsappAggregateArgs>(args: Subset<T, IsOnWhatsappAggregateArgs>): Prisma.PrismaPromise<GetIsOnWhatsappAggregateType<T>>

    /**
     * Group by IsOnWhatsapp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IsOnWhatsappGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IsOnWhatsappGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IsOnWhatsappGroupByArgs['orderBy'] }
        : { orderBy?: IsOnWhatsappGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IsOnWhatsappGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIsOnWhatsappGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IsOnWhatsapp model
   */
  readonly fields: IsOnWhatsappFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IsOnWhatsapp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IsOnWhatsappClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IsOnWhatsapp model
   */ 
  interface IsOnWhatsappFieldRefs {
    readonly id: FieldRef<"IsOnWhatsapp", 'String'>
    readonly remoteJid: FieldRef<"IsOnWhatsapp", 'String'>
    readonly jidOptions: FieldRef<"IsOnWhatsapp", 'String'>
    readonly createdAt: FieldRef<"IsOnWhatsapp", 'DateTime'>
    readonly updatedAt: FieldRef<"IsOnWhatsapp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IsOnWhatsapp findUnique
   */
  export type IsOnWhatsappFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
    /**
     * Filter, which IsOnWhatsapp to fetch.
     */
    where: IsOnWhatsappWhereUniqueInput
  }

  /**
   * IsOnWhatsapp findUniqueOrThrow
   */
  export type IsOnWhatsappFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
    /**
     * Filter, which IsOnWhatsapp to fetch.
     */
    where: IsOnWhatsappWhereUniqueInput
  }

  /**
   * IsOnWhatsapp findFirst
   */
  export type IsOnWhatsappFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
    /**
     * Filter, which IsOnWhatsapp to fetch.
     */
    where?: IsOnWhatsappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IsOnWhatsapps to fetch.
     */
    orderBy?: IsOnWhatsappOrderByWithRelationInput | IsOnWhatsappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IsOnWhatsapps.
     */
    cursor?: IsOnWhatsappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IsOnWhatsapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IsOnWhatsapps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IsOnWhatsapps.
     */
    distinct?: IsOnWhatsappScalarFieldEnum | IsOnWhatsappScalarFieldEnum[]
  }

  /**
   * IsOnWhatsapp findFirstOrThrow
   */
  export type IsOnWhatsappFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
    /**
     * Filter, which IsOnWhatsapp to fetch.
     */
    where?: IsOnWhatsappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IsOnWhatsapps to fetch.
     */
    orderBy?: IsOnWhatsappOrderByWithRelationInput | IsOnWhatsappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IsOnWhatsapps.
     */
    cursor?: IsOnWhatsappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IsOnWhatsapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IsOnWhatsapps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IsOnWhatsapps.
     */
    distinct?: IsOnWhatsappScalarFieldEnum | IsOnWhatsappScalarFieldEnum[]
  }

  /**
   * IsOnWhatsapp findMany
   */
  export type IsOnWhatsappFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
    /**
     * Filter, which IsOnWhatsapps to fetch.
     */
    where?: IsOnWhatsappWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IsOnWhatsapps to fetch.
     */
    orderBy?: IsOnWhatsappOrderByWithRelationInput | IsOnWhatsappOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IsOnWhatsapps.
     */
    cursor?: IsOnWhatsappWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IsOnWhatsapps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IsOnWhatsapps.
     */
    skip?: number
    distinct?: IsOnWhatsappScalarFieldEnum | IsOnWhatsappScalarFieldEnum[]
  }

  /**
   * IsOnWhatsapp create
   */
  export type IsOnWhatsappCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
    /**
     * The data needed to create a IsOnWhatsapp.
     */
    data: XOR<IsOnWhatsappCreateInput, IsOnWhatsappUncheckedCreateInput>
  }

  /**
   * IsOnWhatsapp createMany
   */
  export type IsOnWhatsappCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IsOnWhatsapps.
     */
    data: IsOnWhatsappCreateManyInput | IsOnWhatsappCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IsOnWhatsapp update
   */
  export type IsOnWhatsappUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
    /**
     * The data needed to update a IsOnWhatsapp.
     */
    data: XOR<IsOnWhatsappUpdateInput, IsOnWhatsappUncheckedUpdateInput>
    /**
     * Choose, which IsOnWhatsapp to update.
     */
    where: IsOnWhatsappWhereUniqueInput
  }

  /**
   * IsOnWhatsapp updateMany
   */
  export type IsOnWhatsappUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IsOnWhatsapps.
     */
    data: XOR<IsOnWhatsappUpdateManyMutationInput, IsOnWhatsappUncheckedUpdateManyInput>
    /**
     * Filter which IsOnWhatsapps to update
     */
    where?: IsOnWhatsappWhereInput
    /**
     * Limit how many IsOnWhatsapps to update.
     */
    limit?: number
  }

  /**
   * IsOnWhatsapp upsert
   */
  export type IsOnWhatsappUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
    /**
     * The filter to search for the IsOnWhatsapp to update in case it exists.
     */
    where: IsOnWhatsappWhereUniqueInput
    /**
     * In case the IsOnWhatsapp found by the `where` argument doesn't exist, create a new IsOnWhatsapp with this data.
     */
    create: XOR<IsOnWhatsappCreateInput, IsOnWhatsappUncheckedCreateInput>
    /**
     * In case the IsOnWhatsapp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IsOnWhatsappUpdateInput, IsOnWhatsappUncheckedUpdateInput>
  }

  /**
   * IsOnWhatsapp delete
   */
  export type IsOnWhatsappDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
    /**
     * Filter which IsOnWhatsapp to delete.
     */
    where: IsOnWhatsappWhereUniqueInput
  }

  /**
   * IsOnWhatsapp deleteMany
   */
  export type IsOnWhatsappDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IsOnWhatsapps to delete
     */
    where?: IsOnWhatsappWhereInput
    /**
     * Limit how many IsOnWhatsapps to delete.
     */
    limit?: number
  }

  /**
   * IsOnWhatsapp without action
   */
  export type IsOnWhatsappDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IsOnWhatsapp
     */
    select?: IsOnWhatsappSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IsOnWhatsapp
     */
    omit?: IsOnWhatsappOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const InstanceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    connectionStatus: 'connectionStatus',
    ownerJid: 'ownerJid',
    profileName: 'profileName',
    profilePicUrl: 'profilePicUrl',
    integration: 'integration',
    number: 'number',
    businessId: 'businessId',
    token: 'token',
    clientName: 'clientName',
    disconnectionReasonCode: 'disconnectionReasonCode',
    disconnectionObject: 'disconnectionObject',
    disconnectionAt: 'disconnectionAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstanceScalarFieldEnum = (typeof InstanceScalarFieldEnum)[keyof typeof InstanceScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    creds: 'creds',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    remoteJid: 'remoteJid',
    name: 'name',
    labels: 'labels',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId',
    unreadMessages: 'unreadMessages'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    remoteJid: 'remoteJid',
    pushName: 'pushName',
    profilePicUrl: 'profilePicUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    key: 'key',
    pushName: 'pushName',
    participant: 'participant',
    messageType: 'messageType',
    message: 'message',
    contextInfo: 'contextInfo',
    source: 'source',
    messageTimestamp: 'messageTimestamp',
    chatwootMessageId: 'chatwootMessageId',
    chatwootInboxId: 'chatwootInboxId',
    chatwootConversationId: 'chatwootConversationId',
    chatwootContactInboxSourceId: 'chatwootContactInboxSourceId',
    chatwootIsRead: 'chatwootIsRead',
    instanceId: 'instanceId',
    typebotSessionId: 'typebotSessionId',
    webhookUrl: 'webhookUrl',
    status: 'status',
    sessionId: 'sessionId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageUpdateScalarFieldEnum: {
    id: 'id',
    keyId: 'keyId',
    remoteJid: 'remoteJid',
    fromMe: 'fromMe',
    participant: 'participant',
    pollUpdates: 'pollUpdates',
    status: 'status',
    messageId: 'messageId',
    instanceId: 'instanceId'
  };

  export type MessageUpdateScalarFieldEnum = (typeof MessageUpdateScalarFieldEnum)[keyof typeof MessageUpdateScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    url: 'url',
    headers: 'headers',
    enabled: 'enabled',
    events: 'events',
    webhookByEvents: 'webhookByEvents',
    webhookBase64: 'webhookBase64',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const ChatwootScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    accountId: 'accountId',
    token: 'token',
    url: 'url',
    nameInbox: 'nameInbox',
    signMsg: 'signMsg',
    signDelimiter: 'signDelimiter',
    number: 'number',
    reopenConversation: 'reopenConversation',
    conversationPending: 'conversationPending',
    mergeBrazilContacts: 'mergeBrazilContacts',
    importContacts: 'importContacts',
    importMessages: 'importMessages',
    daysLimitImportMessages: 'daysLimitImportMessages',
    organization: 'organization',
    logo: 'logo',
    ignoreJids: 'ignoreJids',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type ChatwootScalarFieldEnum = (typeof ChatwootScalarFieldEnum)[keyof typeof ChatwootScalarFieldEnum]


  export const LabelScalarFieldEnum: {
    id: 'id',
    labelId: 'labelId',
    name: 'name',
    color: 'color',
    predefinedId: 'predefinedId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type LabelScalarFieldEnum = (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum]


  export const ProxyScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    host: 'host',
    port: 'port',
    protocol: 'protocol',
    username: 'username',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type ProxyScalarFieldEnum = (typeof ProxyScalarFieldEnum)[keyof typeof ProxyScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    rejectCall: 'rejectCall',
    msgCall: 'msgCall',
    groupsIgnore: 'groupsIgnore',
    alwaysOnline: 'alwaysOnline',
    readMessages: 'readMessages',
    readStatus: 'readStatus',
    syncFullHistory: 'syncFullHistory',
    wavoipToken: 'wavoipToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const RabbitmqScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    events: 'events',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type RabbitmqScalarFieldEnum = (typeof RabbitmqScalarFieldEnum)[keyof typeof RabbitmqScalarFieldEnum]


  export const SqsScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    events: 'events',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type SqsScalarFieldEnum = (typeof SqsScalarFieldEnum)[keyof typeof SqsScalarFieldEnum]


  export const WebsocketScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    events: 'events',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type WebsocketScalarFieldEnum = (typeof WebsocketScalarFieldEnum)[keyof typeof WebsocketScalarFieldEnum]


  export const PusherScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    appId: 'appId',
    key: 'key',
    secret: 'secret',
    cluster: 'cluster',
    useTLS: 'useTLS',
    events: 'events',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type PusherScalarFieldEnum = (typeof PusherScalarFieldEnum)[keyof typeof PusherScalarFieldEnum]


  export const TypebotScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    description: 'description',
    url: 'url',
    typebot: 'typebot',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ignoreJids: 'ignoreJids',
    triggerType: 'triggerType',
    triggerOperator: 'triggerOperator',
    triggerValue: 'triggerValue',
    instanceId: 'instanceId'
  };

  export type TypebotScalarFieldEnum = (typeof TypebotScalarFieldEnum)[keyof typeof TypebotScalarFieldEnum]


  export const TypebotSettingScalarFieldEnum: {
    id: 'id',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    typebotIdFallback: 'typebotIdFallback',
    ignoreJids: 'ignoreJids',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type TypebotSettingScalarFieldEnum = (typeof TypebotSettingScalarFieldEnum)[keyof typeof TypebotSettingScalarFieldEnum]


  export const IntegrationSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    remoteJid: 'remoteJid',
    pushName: 'pushName',
    status: 'status',
    awaitUser: 'awaitUser',
    context: 'context',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId',
    parameters: 'parameters',
    botId: 'botId'
  };

  export type IntegrationSessionScalarFieldEnum = (typeof IntegrationSessionScalarFieldEnum)[keyof typeof IntegrationSessionScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    type: 'type',
    mimetype: 'mimetype',
    createdAt: 'createdAt',
    messageId: 'messageId',
    instanceId: 'instanceId'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const OpenaiCredsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    apiKey: 'apiKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type OpenaiCredsScalarFieldEnum = (typeof OpenaiCredsScalarFieldEnum)[keyof typeof OpenaiCredsScalarFieldEnum]


  export const OpenaiBotScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    description: 'description',
    botType: 'botType',
    assistantId: 'assistantId',
    functionUrl: 'functionUrl',
    model: 'model',
    systemMessages: 'systemMessages',
    assistantMessages: 'assistantMessages',
    userMessages: 'userMessages',
    maxTokens: 'maxTokens',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    ignoreJids: 'ignoreJids',
    splitMessages: 'splitMessages',
    timePerChar: 'timePerChar',
    triggerType: 'triggerType',
    triggerOperator: 'triggerOperator',
    triggerValue: 'triggerValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    openaiCredsId: 'openaiCredsId',
    instanceId: 'instanceId'
  };

  export type OpenaiBotScalarFieldEnum = (typeof OpenaiBotScalarFieldEnum)[keyof typeof OpenaiBotScalarFieldEnum]


  export const OpenaiSettingScalarFieldEnum: {
    id: 'id',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    ignoreJids: 'ignoreJids',
    splitMessages: 'splitMessages',
    timePerChar: 'timePerChar',
    speechToText: 'speechToText',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    openaiCredsId: 'openaiCredsId',
    openaiIdFallback: 'openaiIdFallback',
    instanceId: 'instanceId'
  };

  export type OpenaiSettingScalarFieldEnum = (typeof OpenaiSettingScalarFieldEnum)[keyof typeof OpenaiSettingScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    name: 'name',
    template: 'template',
    webhookUrl: 'webhookUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const DifyScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    description: 'description',
    botType: 'botType',
    apiUrl: 'apiUrl',
    apiKey: 'apiKey',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    ignoreJids: 'ignoreJids',
    splitMessages: 'splitMessages',
    timePerChar: 'timePerChar',
    triggerType: 'triggerType',
    triggerOperator: 'triggerOperator',
    triggerValue: 'triggerValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type DifyScalarFieldEnum = (typeof DifyScalarFieldEnum)[keyof typeof DifyScalarFieldEnum]


  export const DifySettingScalarFieldEnum: {
    id: 'id',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    ignoreJids: 'ignoreJids',
    splitMessages: 'splitMessages',
    timePerChar: 'timePerChar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    difyIdFallback: 'difyIdFallback',
    instanceId: 'instanceId'
  };

  export type DifySettingScalarFieldEnum = (typeof DifySettingScalarFieldEnum)[keyof typeof DifySettingScalarFieldEnum]


  export const EvolutionBotScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    description: 'description',
    apiUrl: 'apiUrl',
    apiKey: 'apiKey',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    ignoreJids: 'ignoreJids',
    splitMessages: 'splitMessages',
    timePerChar: 'timePerChar',
    triggerType: 'triggerType',
    triggerOperator: 'triggerOperator',
    triggerValue: 'triggerValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type EvolutionBotScalarFieldEnum = (typeof EvolutionBotScalarFieldEnum)[keyof typeof EvolutionBotScalarFieldEnum]


  export const EvolutionBotSettingScalarFieldEnum: {
    id: 'id',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    ignoreJids: 'ignoreJids',
    splitMessages: 'splitMessages',
    timePerChar: 'timePerChar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    botIdFallback: 'botIdFallback',
    instanceId: 'instanceId'
  };

  export type EvolutionBotSettingScalarFieldEnum = (typeof EvolutionBotSettingScalarFieldEnum)[keyof typeof EvolutionBotSettingScalarFieldEnum]


  export const FlowiseScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    description: 'description',
    apiUrl: 'apiUrl',
    apiKey: 'apiKey',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    ignoreJids: 'ignoreJids',
    splitMessages: 'splitMessages',
    timePerChar: 'timePerChar',
    triggerType: 'triggerType',
    triggerOperator: 'triggerOperator',
    triggerValue: 'triggerValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    instanceId: 'instanceId'
  };

  export type FlowiseScalarFieldEnum = (typeof FlowiseScalarFieldEnum)[keyof typeof FlowiseScalarFieldEnum]


  export const FlowiseSettingScalarFieldEnum: {
    id: 'id',
    expire: 'expire',
    keywordFinish: 'keywordFinish',
    delayMessage: 'delayMessage',
    unknownMessage: 'unknownMessage',
    listeningFromMe: 'listeningFromMe',
    stopBotFromMe: 'stopBotFromMe',
    keepOpen: 'keepOpen',
    debounceTime: 'debounceTime',
    ignoreJids: 'ignoreJids',
    splitMessages: 'splitMessages',
    timePerChar: 'timePerChar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    flowiseIdFallback: 'flowiseIdFallback',
    instanceId: 'instanceId'
  };

  export type FlowiseSettingScalarFieldEnum = (typeof FlowiseSettingScalarFieldEnum)[keyof typeof FlowiseSettingScalarFieldEnum]


  export const IsOnWhatsappScalarFieldEnum: {
    id: 'id',
    remoteJid: 'remoteJid',
    jidOptions: 'jidOptions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IsOnWhatsappScalarFieldEnum = (typeof IsOnWhatsappScalarFieldEnum)[keyof typeof IsOnWhatsappScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const InstanceOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    ownerJid: 'ownerJid',
    profileName: 'profileName',
    profilePicUrl: 'profilePicUrl',
    integration: 'integration',
    number: 'number',
    businessId: 'businessId',
    token: 'token',
    clientName: 'clientName'
  };

  export type InstanceOrderByRelevanceFieldEnum = (typeof InstanceOrderByRelevanceFieldEnum)[keyof typeof InstanceOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    creds: 'creds'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const ChatOrderByRelevanceFieldEnum: {
    id: 'id',
    remoteJid: 'remoteJid',
    name: 'name',
    instanceId: 'instanceId'
  };

  export type ChatOrderByRelevanceFieldEnum = (typeof ChatOrderByRelevanceFieldEnum)[keyof typeof ChatOrderByRelevanceFieldEnum]


  export const ContactOrderByRelevanceFieldEnum: {
    id: 'id',
    remoteJid: 'remoteJid',
    pushName: 'pushName',
    profilePicUrl: 'profilePicUrl',
    instanceId: 'instanceId'
  };

  export type ContactOrderByRelevanceFieldEnum = (typeof ContactOrderByRelevanceFieldEnum)[keyof typeof ContactOrderByRelevanceFieldEnum]


  export const MessageOrderByRelevanceFieldEnum: {
    id: 'id',
    pushName: 'pushName',
    participant: 'participant',
    messageType: 'messageType',
    chatwootContactInboxSourceId: 'chatwootContactInboxSourceId',
    instanceId: 'instanceId',
    typebotSessionId: 'typebotSessionId',
    webhookUrl: 'webhookUrl',
    status: 'status',
    sessionId: 'sessionId'
  };

  export type MessageOrderByRelevanceFieldEnum = (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum]


  export const MessageUpdateOrderByRelevanceFieldEnum: {
    id: 'id',
    keyId: 'keyId',
    remoteJid: 'remoteJid',
    participant: 'participant',
    status: 'status',
    messageId: 'messageId',
    instanceId: 'instanceId'
  };

  export type MessageUpdateOrderByRelevanceFieldEnum = (typeof MessageUpdateOrderByRelevanceFieldEnum)[keyof typeof MessageUpdateOrderByRelevanceFieldEnum]


  export const WebhookOrderByRelevanceFieldEnum: {
    id: 'id',
    url: 'url',
    instanceId: 'instanceId'
  };

  export type WebhookOrderByRelevanceFieldEnum = (typeof WebhookOrderByRelevanceFieldEnum)[keyof typeof WebhookOrderByRelevanceFieldEnum]


  export const ChatwootOrderByRelevanceFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    token: 'token',
    url: 'url',
    nameInbox: 'nameInbox',
    signDelimiter: 'signDelimiter',
    number: 'number',
    organization: 'organization',
    logo: 'logo',
    instanceId: 'instanceId'
  };

  export type ChatwootOrderByRelevanceFieldEnum = (typeof ChatwootOrderByRelevanceFieldEnum)[keyof typeof ChatwootOrderByRelevanceFieldEnum]


  export const LabelOrderByRelevanceFieldEnum: {
    id: 'id',
    labelId: 'labelId',
    name: 'name',
    color: 'color',
    predefinedId: 'predefinedId',
    instanceId: 'instanceId'
  };

  export type LabelOrderByRelevanceFieldEnum = (typeof LabelOrderByRelevanceFieldEnum)[keyof typeof LabelOrderByRelevanceFieldEnum]


  export const ProxyOrderByRelevanceFieldEnum: {
    id: 'id',
    host: 'host',
    port: 'port',
    protocol: 'protocol',
    username: 'username',
    password: 'password',
    instanceId: 'instanceId'
  };

  export type ProxyOrderByRelevanceFieldEnum = (typeof ProxyOrderByRelevanceFieldEnum)[keyof typeof ProxyOrderByRelevanceFieldEnum]


  export const SettingOrderByRelevanceFieldEnum: {
    id: 'id',
    msgCall: 'msgCall',
    wavoipToken: 'wavoipToken',
    instanceId: 'instanceId'
  };

  export type SettingOrderByRelevanceFieldEnum = (typeof SettingOrderByRelevanceFieldEnum)[keyof typeof SettingOrderByRelevanceFieldEnum]


  export const RabbitmqOrderByRelevanceFieldEnum: {
    id: 'id',
    instanceId: 'instanceId'
  };

  export type RabbitmqOrderByRelevanceFieldEnum = (typeof RabbitmqOrderByRelevanceFieldEnum)[keyof typeof RabbitmqOrderByRelevanceFieldEnum]


  export const SqsOrderByRelevanceFieldEnum: {
    id: 'id',
    instanceId: 'instanceId'
  };

  export type SqsOrderByRelevanceFieldEnum = (typeof SqsOrderByRelevanceFieldEnum)[keyof typeof SqsOrderByRelevanceFieldEnum]


  export const WebsocketOrderByRelevanceFieldEnum: {
    id: 'id',
    instanceId: 'instanceId'
  };

  export type WebsocketOrderByRelevanceFieldEnum = (typeof WebsocketOrderByRelevanceFieldEnum)[keyof typeof WebsocketOrderByRelevanceFieldEnum]


  export const PusherOrderByRelevanceFieldEnum: {
    id: 'id',
    appId: 'appId',
    key: 'key',
    secret: 'secret',
    cluster: 'cluster',
    instanceId: 'instanceId'
  };

  export type PusherOrderByRelevanceFieldEnum = (typeof PusherOrderByRelevanceFieldEnum)[keyof typeof PusherOrderByRelevanceFieldEnum]


  export const TypebotOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    url: 'url',
    typebot: 'typebot',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    triggerValue: 'triggerValue',
    instanceId: 'instanceId'
  };

  export type TypebotOrderByRelevanceFieldEnum = (typeof TypebotOrderByRelevanceFieldEnum)[keyof typeof TypebotOrderByRelevanceFieldEnum]


  export const TypebotSettingOrderByRelevanceFieldEnum: {
    id: 'id',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    typebotIdFallback: 'typebotIdFallback',
    instanceId: 'instanceId'
  };

  export type TypebotSettingOrderByRelevanceFieldEnum = (typeof TypebotSettingOrderByRelevanceFieldEnum)[keyof typeof TypebotSettingOrderByRelevanceFieldEnum]


  export const IntegrationSessionOrderByRelevanceFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    remoteJid: 'remoteJid',
    pushName: 'pushName',
    type: 'type',
    instanceId: 'instanceId',
    botId: 'botId'
  };

  export type IntegrationSessionOrderByRelevanceFieldEnum = (typeof IntegrationSessionOrderByRelevanceFieldEnum)[keyof typeof IntegrationSessionOrderByRelevanceFieldEnum]


  export const MediaOrderByRelevanceFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    type: 'type',
    mimetype: 'mimetype',
    messageId: 'messageId',
    instanceId: 'instanceId'
  };

  export type MediaOrderByRelevanceFieldEnum = (typeof MediaOrderByRelevanceFieldEnum)[keyof typeof MediaOrderByRelevanceFieldEnum]


  export const OpenaiCredsOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    apiKey: 'apiKey',
    instanceId: 'instanceId'
  };

  export type OpenaiCredsOrderByRelevanceFieldEnum = (typeof OpenaiCredsOrderByRelevanceFieldEnum)[keyof typeof OpenaiCredsOrderByRelevanceFieldEnum]


  export const OpenaiBotOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    assistantId: 'assistantId',
    functionUrl: 'functionUrl',
    model: 'model',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    triggerValue: 'triggerValue',
    openaiCredsId: 'openaiCredsId',
    instanceId: 'instanceId'
  };

  export type OpenaiBotOrderByRelevanceFieldEnum = (typeof OpenaiBotOrderByRelevanceFieldEnum)[keyof typeof OpenaiBotOrderByRelevanceFieldEnum]


  export const OpenaiSettingOrderByRelevanceFieldEnum: {
    id: 'id',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    openaiCredsId: 'openaiCredsId',
    openaiIdFallback: 'openaiIdFallback',
    instanceId: 'instanceId'
  };

  export type OpenaiSettingOrderByRelevanceFieldEnum = (typeof OpenaiSettingOrderByRelevanceFieldEnum)[keyof typeof OpenaiSettingOrderByRelevanceFieldEnum]


  export const TemplateOrderByRelevanceFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    name: 'name',
    webhookUrl: 'webhookUrl',
    instanceId: 'instanceId'
  };

  export type TemplateOrderByRelevanceFieldEnum = (typeof TemplateOrderByRelevanceFieldEnum)[keyof typeof TemplateOrderByRelevanceFieldEnum]


  export const DifyOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    apiUrl: 'apiUrl',
    apiKey: 'apiKey',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    triggerValue: 'triggerValue',
    instanceId: 'instanceId'
  };

  export type DifyOrderByRelevanceFieldEnum = (typeof DifyOrderByRelevanceFieldEnum)[keyof typeof DifyOrderByRelevanceFieldEnum]


  export const DifySettingOrderByRelevanceFieldEnum: {
    id: 'id',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    difyIdFallback: 'difyIdFallback',
    instanceId: 'instanceId'
  };

  export type DifySettingOrderByRelevanceFieldEnum = (typeof DifySettingOrderByRelevanceFieldEnum)[keyof typeof DifySettingOrderByRelevanceFieldEnum]


  export const EvolutionBotOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    apiUrl: 'apiUrl',
    apiKey: 'apiKey',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    triggerValue: 'triggerValue',
    instanceId: 'instanceId'
  };

  export type EvolutionBotOrderByRelevanceFieldEnum = (typeof EvolutionBotOrderByRelevanceFieldEnum)[keyof typeof EvolutionBotOrderByRelevanceFieldEnum]


  export const EvolutionBotSettingOrderByRelevanceFieldEnum: {
    id: 'id',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    botIdFallback: 'botIdFallback',
    instanceId: 'instanceId'
  };

  export type EvolutionBotSettingOrderByRelevanceFieldEnum = (typeof EvolutionBotSettingOrderByRelevanceFieldEnum)[keyof typeof EvolutionBotSettingOrderByRelevanceFieldEnum]


  export const FlowiseOrderByRelevanceFieldEnum: {
    id: 'id',
    description: 'description',
    apiUrl: 'apiUrl',
    apiKey: 'apiKey',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    triggerValue: 'triggerValue',
    instanceId: 'instanceId'
  };

  export type FlowiseOrderByRelevanceFieldEnum = (typeof FlowiseOrderByRelevanceFieldEnum)[keyof typeof FlowiseOrderByRelevanceFieldEnum]


  export const FlowiseSettingOrderByRelevanceFieldEnum: {
    id: 'id',
    keywordFinish: 'keywordFinish',
    unknownMessage: 'unknownMessage',
    flowiseIdFallback: 'flowiseIdFallback',
    instanceId: 'instanceId'
  };

  export type FlowiseSettingOrderByRelevanceFieldEnum = (typeof FlowiseSettingOrderByRelevanceFieldEnum)[keyof typeof FlowiseSettingOrderByRelevanceFieldEnum]


  export const IsOnWhatsappOrderByRelevanceFieldEnum: {
    id: 'id',
    remoteJid: 'remoteJid',
    jidOptions: 'jidOptions'
  };

  export type IsOnWhatsappOrderByRelevanceFieldEnum = (typeof IsOnWhatsappOrderByRelevanceFieldEnum)[keyof typeof IsOnWhatsappOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'InstanceConnectionStatus'
   */
  export type EnumInstanceConnectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstanceConnectionStatus'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DeviceMessage'
   */
  export type EnumDeviceMessageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceMessage'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TriggerType'
   */
  export type EnumTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerType'>
    


  /**
   * Reference to a field of type 'TriggerOperator'
   */
  export type EnumTriggerOperatorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerOperator'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'OpenaiBotType'
   */
  export type EnumOpenaiBotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OpenaiBotType'>
    


  /**
   * Reference to a field of type 'DifyBotType'
   */
  export type EnumDifyBotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifyBotType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type InstanceWhereInput = {
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    id?: StringFilter<"Instance"> | string
    name?: StringFilter<"Instance"> | string
    connectionStatus?: EnumInstanceConnectionStatusFilter<"Instance"> | $Enums.InstanceConnectionStatus
    ownerJid?: StringNullableFilter<"Instance"> | string | null
    profileName?: StringNullableFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableFilter<"Instance"> | string | null
    integration?: StringNullableFilter<"Instance"> | string | null
    number?: StringNullableFilter<"Instance"> | string | null
    businessId?: StringNullableFilter<"Instance"> | string | null
    token?: StringNullableFilter<"Instance"> | string | null
    clientName?: StringNullableFilter<"Instance"> | string | null
    disconnectionReasonCode?: IntNullableFilter<"Instance"> | number | null
    disconnectionObject?: JsonNullableFilter<"Instance">
    disconnectionAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    Chat?: ChatListRelationFilter
    Contact?: ContactListRelationFilter
    Message?: MessageListRelationFilter
    Webhook?: XOR<WebhookNullableScalarRelationFilter, WebhookWhereInput> | null
    Chatwoot?: XOR<ChatwootNullableScalarRelationFilter, ChatwootWhereInput> | null
    Label?: LabelListRelationFilter
    Proxy?: XOR<ProxyNullableScalarRelationFilter, ProxyWhereInput> | null
    Setting?: XOR<SettingNullableScalarRelationFilter, SettingWhereInput> | null
    Rabbitmq?: XOR<RabbitmqNullableScalarRelationFilter, RabbitmqWhereInput> | null
    Sqs?: XOR<SqsNullableScalarRelationFilter, SqsWhereInput> | null
    Websocket?: XOR<WebsocketNullableScalarRelationFilter, WebsocketWhereInput> | null
    Typebot?: TypebotListRelationFilter
    Session?: XOR<SessionNullableScalarRelationFilter, SessionWhereInput> | null
    MessageUpdate?: MessageUpdateListRelationFilter
    TypebotSetting?: XOR<TypebotSettingNullableScalarRelationFilter, TypebotSettingWhereInput> | null
    Media?: MediaListRelationFilter
    OpenaiCreds?: OpenaiCredsListRelationFilter
    OpenaiBot?: OpenaiBotListRelationFilter
    OpenaiSetting?: XOR<OpenaiSettingNullableScalarRelationFilter, OpenaiSettingWhereInput> | null
    Template?: TemplateListRelationFilter
    Dify?: DifyListRelationFilter
    DifySetting?: XOR<DifySettingNullableScalarRelationFilter, DifySettingWhereInput> | null
    integrationSessions?: IntegrationSessionListRelationFilter
    EvolutionBot?: EvolutionBotListRelationFilter
    EvolutionBotSetting?: XOR<EvolutionBotSettingNullableScalarRelationFilter, EvolutionBotSettingWhereInput> | null
    Flowise?: FlowiseListRelationFilter
    FlowiseSetting?: XOR<FlowiseSettingNullableScalarRelationFilter, FlowiseSettingWhereInput> | null
    Pusher?: XOR<PusherNullableScalarRelationFilter, PusherWhereInput> | null
  }

  export type InstanceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    connectionStatus?: SortOrder
    ownerJid?: SortOrderInput | SortOrder
    profileName?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    integration?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    disconnectionReasonCode?: SortOrderInput | SortOrder
    disconnectionObject?: SortOrderInput | SortOrder
    disconnectionAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Chat?: ChatOrderByRelationAggregateInput
    Contact?: ContactOrderByRelationAggregateInput
    Message?: MessageOrderByRelationAggregateInput
    Webhook?: WebhookOrderByWithRelationInput
    Chatwoot?: ChatwootOrderByWithRelationInput
    Label?: LabelOrderByRelationAggregateInput
    Proxy?: ProxyOrderByWithRelationInput
    Setting?: SettingOrderByWithRelationInput
    Rabbitmq?: RabbitmqOrderByWithRelationInput
    Sqs?: SqsOrderByWithRelationInput
    Websocket?: WebsocketOrderByWithRelationInput
    Typebot?: TypebotOrderByRelationAggregateInput
    Session?: SessionOrderByWithRelationInput
    MessageUpdate?: MessageUpdateOrderByRelationAggregateInput
    TypebotSetting?: TypebotSettingOrderByWithRelationInput
    Media?: MediaOrderByRelationAggregateInput
    OpenaiCreds?: OpenaiCredsOrderByRelationAggregateInput
    OpenaiBot?: OpenaiBotOrderByRelationAggregateInput
    OpenaiSetting?: OpenaiSettingOrderByWithRelationInput
    Template?: TemplateOrderByRelationAggregateInput
    Dify?: DifyOrderByRelationAggregateInput
    DifySetting?: DifySettingOrderByWithRelationInput
    integrationSessions?: IntegrationSessionOrderByRelationAggregateInput
    EvolutionBot?: EvolutionBotOrderByRelationAggregateInput
    EvolutionBotSetting?: EvolutionBotSettingOrderByWithRelationInput
    Flowise?: FlowiseOrderByRelationAggregateInput
    FlowiseSetting?: FlowiseSettingOrderByWithRelationInput
    Pusher?: PusherOrderByWithRelationInput
    _relevance?: InstanceOrderByRelevanceInput
  }

  export type InstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: InstanceWhereInput | InstanceWhereInput[]
    OR?: InstanceWhereInput[]
    NOT?: InstanceWhereInput | InstanceWhereInput[]
    connectionStatus?: EnumInstanceConnectionStatusFilter<"Instance"> | $Enums.InstanceConnectionStatus
    ownerJid?: StringNullableFilter<"Instance"> | string | null
    profileName?: StringNullableFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableFilter<"Instance"> | string | null
    integration?: StringNullableFilter<"Instance"> | string | null
    number?: StringNullableFilter<"Instance"> | string | null
    businessId?: StringNullableFilter<"Instance"> | string | null
    token?: StringNullableFilter<"Instance"> | string | null
    clientName?: StringNullableFilter<"Instance"> | string | null
    disconnectionReasonCode?: IntNullableFilter<"Instance"> | number | null
    disconnectionObject?: JsonNullableFilter<"Instance">
    disconnectionAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Instance"> | Date | string | null
    Chat?: ChatListRelationFilter
    Contact?: ContactListRelationFilter
    Message?: MessageListRelationFilter
    Webhook?: XOR<WebhookNullableScalarRelationFilter, WebhookWhereInput> | null
    Chatwoot?: XOR<ChatwootNullableScalarRelationFilter, ChatwootWhereInput> | null
    Label?: LabelListRelationFilter
    Proxy?: XOR<ProxyNullableScalarRelationFilter, ProxyWhereInput> | null
    Setting?: XOR<SettingNullableScalarRelationFilter, SettingWhereInput> | null
    Rabbitmq?: XOR<RabbitmqNullableScalarRelationFilter, RabbitmqWhereInput> | null
    Sqs?: XOR<SqsNullableScalarRelationFilter, SqsWhereInput> | null
    Websocket?: XOR<WebsocketNullableScalarRelationFilter, WebsocketWhereInput> | null
    Typebot?: TypebotListRelationFilter
    Session?: XOR<SessionNullableScalarRelationFilter, SessionWhereInput> | null
    MessageUpdate?: MessageUpdateListRelationFilter
    TypebotSetting?: XOR<TypebotSettingNullableScalarRelationFilter, TypebotSettingWhereInput> | null
    Media?: MediaListRelationFilter
    OpenaiCreds?: OpenaiCredsListRelationFilter
    OpenaiBot?: OpenaiBotListRelationFilter
    OpenaiSetting?: XOR<OpenaiSettingNullableScalarRelationFilter, OpenaiSettingWhereInput> | null
    Template?: TemplateListRelationFilter
    Dify?: DifyListRelationFilter
    DifySetting?: XOR<DifySettingNullableScalarRelationFilter, DifySettingWhereInput> | null
    integrationSessions?: IntegrationSessionListRelationFilter
    EvolutionBot?: EvolutionBotListRelationFilter
    EvolutionBotSetting?: XOR<EvolutionBotSettingNullableScalarRelationFilter, EvolutionBotSettingWhereInput> | null
    Flowise?: FlowiseListRelationFilter
    FlowiseSetting?: XOR<FlowiseSettingNullableScalarRelationFilter, FlowiseSettingWhereInput> | null
    Pusher?: XOR<PusherNullableScalarRelationFilter, PusherWhereInput> | null
  }, "id" | "name">

  export type InstanceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    connectionStatus?: SortOrder
    ownerJid?: SortOrderInput | SortOrder
    profileName?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    integration?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    disconnectionReasonCode?: SortOrderInput | SortOrder
    disconnectionObject?: SortOrderInput | SortOrder
    disconnectionAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: InstanceCountOrderByAggregateInput
    _avg?: InstanceAvgOrderByAggregateInput
    _max?: InstanceMaxOrderByAggregateInput
    _min?: InstanceMinOrderByAggregateInput
    _sum?: InstanceSumOrderByAggregateInput
  }

  export type InstanceScalarWhereWithAggregatesInput = {
    AND?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    OR?: InstanceScalarWhereWithAggregatesInput[]
    NOT?: InstanceScalarWhereWithAggregatesInput | InstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Instance"> | string
    name?: StringWithAggregatesFilter<"Instance"> | string
    connectionStatus?: EnumInstanceConnectionStatusWithAggregatesFilter<"Instance"> | $Enums.InstanceConnectionStatus
    ownerJid?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    profileName?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    profilePicUrl?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    integration?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    number?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    businessId?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    token?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    clientName?: StringNullableWithAggregatesFilter<"Instance"> | string | null
    disconnectionReasonCode?: IntNullableWithAggregatesFilter<"Instance"> | number | null
    disconnectionObject?: JsonNullableWithAggregatesFilter<"Instance">
    disconnectionAt?: DateTimeNullableWithAggregatesFilter<"Instance"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Instance"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Instance"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionId?: StringFilter<"Session"> | string
    creds?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    creds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    creds?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "sessionId">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    creds?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionId?: StringWithAggregatesFilter<"Session"> | string
    creds?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    remoteJid?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
    labels?: JsonNullableFilter<"Chat">
    createdAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    instanceId?: StringFilter<"Chat"> | string
    unreadMessages?: IntFilter<"Chat"> | number
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    name?: SortOrderInput | SortOrder
    labels?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    unreadMessages?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: ChatOrderByRelevanceInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId_remoteJid?: ChatInstanceIdRemoteJidCompoundUniqueInput
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    remoteJid?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
    labels?: JsonNullableFilter<"Chat">
    createdAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    instanceId?: StringFilter<"Chat"> | string
    unreadMessages?: IntFilter<"Chat"> | number
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId_remoteJid">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    name?: SortOrderInput | SortOrder
    labels?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    unreadMessages?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _avg?: ChatAvgOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
    _sum?: ChatSumOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    remoteJid?: StringWithAggregatesFilter<"Chat"> | string
    name?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    labels?: JsonNullableWithAggregatesFilter<"Chat">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
    instanceId?: StringWithAggregatesFilter<"Chat"> | string
    unreadMessages?: IntWithAggregatesFilter<"Chat"> | number
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    remoteJid?: StringFilter<"Contact"> | string
    pushName?: StringNullableFilter<"Contact"> | string | null
    profilePicUrl?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    instanceId?: StringFilter<"Contact"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: ContactOrderByRelevanceInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    remoteJid_instanceId?: ContactRemoteJidInstanceIdCompoundUniqueInput
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    remoteJid?: StringFilter<"Contact"> | string
    pushName?: StringNullableFilter<"Contact"> | string | null
    profilePicUrl?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    instanceId?: StringFilter<"Contact"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "remoteJid_instanceId">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrderInput | SortOrder
    profilePicUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    remoteJid?: StringWithAggregatesFilter<"Contact"> | string
    pushName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    profilePicUrl?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    instanceId?: StringWithAggregatesFilter<"Contact"> | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    key?: JsonFilter<"Message">
    pushName?: StringNullableFilter<"Message"> | string | null
    participant?: StringNullableFilter<"Message"> | string | null
    messageType?: StringFilter<"Message"> | string
    message?: JsonFilter<"Message">
    contextInfo?: JsonNullableFilter<"Message">
    source?: EnumDeviceMessageFilter<"Message"> | $Enums.DeviceMessage
    messageTimestamp?: IntFilter<"Message"> | number
    chatwootMessageId?: IntNullableFilter<"Message"> | number | null
    chatwootInboxId?: IntNullableFilter<"Message"> | number | null
    chatwootConversationId?: IntNullableFilter<"Message"> | number | null
    chatwootContactInboxSourceId?: StringNullableFilter<"Message"> | string | null
    chatwootIsRead?: BoolNullableFilter<"Message"> | boolean | null
    instanceId?: StringFilter<"Message"> | string
    typebotSessionId?: StringNullableFilter<"Message"> | string | null
    webhookUrl?: StringNullableFilter<"Message"> | string | null
    status?: StringNullableFilter<"Message"> | string | null
    sessionId?: StringNullableFilter<"Message"> | string | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    MessageUpdate?: MessageUpdateListRelationFilter
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    session?: XOR<IntegrationSessionNullableScalarRelationFilter, IntegrationSessionWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    pushName?: SortOrderInput | SortOrder
    participant?: SortOrderInput | SortOrder
    messageType?: SortOrder
    message?: SortOrder
    contextInfo?: SortOrderInput | SortOrder
    source?: SortOrder
    messageTimestamp?: SortOrder
    chatwootMessageId?: SortOrderInput | SortOrder
    chatwootInboxId?: SortOrderInput | SortOrder
    chatwootConversationId?: SortOrderInput | SortOrder
    chatwootContactInboxSourceId?: SortOrderInput | SortOrder
    chatwootIsRead?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    typebotSessionId?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    Instance?: InstanceOrderByWithRelationInput
    MessageUpdate?: MessageUpdateOrderByRelationAggregateInput
    Media?: MediaOrderByWithRelationInput
    session?: IntegrationSessionOrderByWithRelationInput
    _relevance?: MessageOrderByRelevanceInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    key?: JsonFilter<"Message">
    pushName?: StringNullableFilter<"Message"> | string | null
    participant?: StringNullableFilter<"Message"> | string | null
    messageType?: StringFilter<"Message"> | string
    message?: JsonFilter<"Message">
    contextInfo?: JsonNullableFilter<"Message">
    source?: EnumDeviceMessageFilter<"Message"> | $Enums.DeviceMessage
    messageTimestamp?: IntFilter<"Message"> | number
    chatwootMessageId?: IntNullableFilter<"Message"> | number | null
    chatwootInboxId?: IntNullableFilter<"Message"> | number | null
    chatwootConversationId?: IntNullableFilter<"Message"> | number | null
    chatwootContactInboxSourceId?: StringNullableFilter<"Message"> | string | null
    chatwootIsRead?: BoolNullableFilter<"Message"> | boolean | null
    instanceId?: StringFilter<"Message"> | string
    typebotSessionId?: StringNullableFilter<"Message"> | string | null
    webhookUrl?: StringNullableFilter<"Message"> | string | null
    status?: StringNullableFilter<"Message"> | string | null
    sessionId?: StringNullableFilter<"Message"> | string | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    MessageUpdate?: MessageUpdateListRelationFilter
    Media?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    session?: XOR<IntegrationSessionNullableScalarRelationFilter, IntegrationSessionWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    pushName?: SortOrderInput | SortOrder
    participant?: SortOrderInput | SortOrder
    messageType?: SortOrder
    message?: SortOrder
    contextInfo?: SortOrderInput | SortOrder
    source?: SortOrder
    messageTimestamp?: SortOrder
    chatwootMessageId?: SortOrderInput | SortOrder
    chatwootInboxId?: SortOrderInput | SortOrder
    chatwootConversationId?: SortOrderInput | SortOrder
    chatwootContactInboxSourceId?: SortOrderInput | SortOrder
    chatwootIsRead?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    typebotSessionId?: SortOrderInput | SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    key?: JsonWithAggregatesFilter<"Message">
    pushName?: StringNullableWithAggregatesFilter<"Message"> | string | null
    participant?: StringNullableWithAggregatesFilter<"Message"> | string | null
    messageType?: StringWithAggregatesFilter<"Message"> | string
    message?: JsonWithAggregatesFilter<"Message">
    contextInfo?: JsonNullableWithAggregatesFilter<"Message">
    source?: EnumDeviceMessageWithAggregatesFilter<"Message"> | $Enums.DeviceMessage
    messageTimestamp?: IntWithAggregatesFilter<"Message"> | number
    chatwootMessageId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    chatwootInboxId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    chatwootConversationId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    chatwootContactInboxSourceId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    chatwootIsRead?: BoolNullableWithAggregatesFilter<"Message"> | boolean | null
    instanceId?: StringWithAggregatesFilter<"Message"> | string
    typebotSessionId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    webhookUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    status?: StringNullableWithAggregatesFilter<"Message"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"Message"> | string | null
  }

  export type MessageUpdateWhereInput = {
    AND?: MessageUpdateWhereInput | MessageUpdateWhereInput[]
    OR?: MessageUpdateWhereInput[]
    NOT?: MessageUpdateWhereInput | MessageUpdateWhereInput[]
    id?: StringFilter<"MessageUpdate"> | string
    keyId?: StringFilter<"MessageUpdate"> | string
    remoteJid?: StringFilter<"MessageUpdate"> | string
    fromMe?: BoolFilter<"MessageUpdate"> | boolean
    participant?: StringNullableFilter<"MessageUpdate"> | string | null
    pollUpdates?: JsonNullableFilter<"MessageUpdate">
    status?: StringFilter<"MessageUpdate"> | string
    messageId?: StringFilter<"MessageUpdate"> | string
    instanceId?: StringFilter<"MessageUpdate"> | string
    Message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type MessageUpdateOrderByWithRelationInput = {
    id?: SortOrder
    keyId?: SortOrder
    remoteJid?: SortOrder
    fromMe?: SortOrder
    participant?: SortOrderInput | SortOrder
    pollUpdates?: SortOrderInput | SortOrder
    status?: SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
    Message?: MessageOrderByWithRelationInput
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: MessageUpdateOrderByRelevanceInput
  }

  export type MessageUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageUpdateWhereInput | MessageUpdateWhereInput[]
    OR?: MessageUpdateWhereInput[]
    NOT?: MessageUpdateWhereInput | MessageUpdateWhereInput[]
    keyId?: StringFilter<"MessageUpdate"> | string
    remoteJid?: StringFilter<"MessageUpdate"> | string
    fromMe?: BoolFilter<"MessageUpdate"> | boolean
    participant?: StringNullableFilter<"MessageUpdate"> | string | null
    pollUpdates?: JsonNullableFilter<"MessageUpdate">
    status?: StringFilter<"MessageUpdate"> | string
    messageId?: StringFilter<"MessageUpdate"> | string
    instanceId?: StringFilter<"MessageUpdate"> | string
    Message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id">

  export type MessageUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    keyId?: SortOrder
    remoteJid?: SortOrder
    fromMe?: SortOrder
    participant?: SortOrderInput | SortOrder
    pollUpdates?: SortOrderInput | SortOrder
    status?: SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
    _count?: MessageUpdateCountOrderByAggregateInput
    _max?: MessageUpdateMaxOrderByAggregateInput
    _min?: MessageUpdateMinOrderByAggregateInput
  }

  export type MessageUpdateScalarWhereWithAggregatesInput = {
    AND?: MessageUpdateScalarWhereWithAggregatesInput | MessageUpdateScalarWhereWithAggregatesInput[]
    OR?: MessageUpdateScalarWhereWithAggregatesInput[]
    NOT?: MessageUpdateScalarWhereWithAggregatesInput | MessageUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageUpdate"> | string
    keyId?: StringWithAggregatesFilter<"MessageUpdate"> | string
    remoteJid?: StringWithAggregatesFilter<"MessageUpdate"> | string
    fromMe?: BoolWithAggregatesFilter<"MessageUpdate"> | boolean
    participant?: StringNullableWithAggregatesFilter<"MessageUpdate"> | string | null
    pollUpdates?: JsonNullableWithAggregatesFilter<"MessageUpdate">
    status?: StringWithAggregatesFilter<"MessageUpdate"> | string
    messageId?: StringWithAggregatesFilter<"MessageUpdate"> | string
    instanceId?: StringWithAggregatesFilter<"MessageUpdate"> | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    headers?: JsonNullableFilter<"Webhook">
    enabled?: BoolNullableFilter<"Webhook"> | boolean | null
    events?: JsonNullableFilter<"Webhook">
    webhookByEvents?: BoolNullableFilter<"Webhook"> | boolean | null
    webhookBase64?: BoolNullableFilter<"Webhook"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    instanceId?: StringFilter<"Webhook"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    headers?: SortOrderInput | SortOrder
    enabled?: SortOrderInput | SortOrder
    events?: SortOrderInput | SortOrder
    webhookByEvents?: SortOrderInput | SortOrder
    webhookBase64?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: WebhookOrderByRelevanceInput
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    url?: StringFilter<"Webhook"> | string
    headers?: JsonNullableFilter<"Webhook">
    enabled?: BoolNullableFilter<"Webhook"> | boolean | null
    events?: JsonNullableFilter<"Webhook">
    webhookByEvents?: BoolNullableFilter<"Webhook"> | boolean | null
    webhookBase64?: BoolNullableFilter<"Webhook"> | boolean | null
    createdAt?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    headers?: SortOrderInput | SortOrder
    enabled?: SortOrderInput | SortOrder
    events?: SortOrderInput | SortOrder
    webhookByEvents?: SortOrderInput | SortOrder
    webhookBase64?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    headers?: JsonNullableWithAggregatesFilter<"Webhook">
    enabled?: BoolNullableWithAggregatesFilter<"Webhook"> | boolean | null
    events?: JsonNullableWithAggregatesFilter<"Webhook">
    webhookByEvents?: BoolNullableWithAggregatesFilter<"Webhook"> | boolean | null
    webhookBase64?: BoolNullableWithAggregatesFilter<"Webhook"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Webhook"> | string
  }

  export type ChatwootWhereInput = {
    AND?: ChatwootWhereInput | ChatwootWhereInput[]
    OR?: ChatwootWhereInput[]
    NOT?: ChatwootWhereInput | ChatwootWhereInput[]
    id?: StringFilter<"Chatwoot"> | string
    enabled?: BoolNullableFilter<"Chatwoot"> | boolean | null
    accountId?: StringNullableFilter<"Chatwoot"> | string | null
    token?: StringNullableFilter<"Chatwoot"> | string | null
    url?: StringNullableFilter<"Chatwoot"> | string | null
    nameInbox?: StringNullableFilter<"Chatwoot"> | string | null
    signMsg?: BoolNullableFilter<"Chatwoot"> | boolean | null
    signDelimiter?: StringNullableFilter<"Chatwoot"> | string | null
    number?: StringNullableFilter<"Chatwoot"> | string | null
    reopenConversation?: BoolNullableFilter<"Chatwoot"> | boolean | null
    conversationPending?: BoolNullableFilter<"Chatwoot"> | boolean | null
    mergeBrazilContacts?: BoolNullableFilter<"Chatwoot"> | boolean | null
    importContacts?: BoolNullableFilter<"Chatwoot"> | boolean | null
    importMessages?: BoolNullableFilter<"Chatwoot"> | boolean | null
    daysLimitImportMessages?: IntNullableFilter<"Chatwoot"> | number | null
    organization?: StringNullableFilter<"Chatwoot"> | string | null
    logo?: StringNullableFilter<"Chatwoot"> | string | null
    ignoreJids?: JsonNullableFilter<"Chatwoot">
    createdAt?: DateTimeNullableFilter<"Chatwoot"> | Date | string | null
    updatedAt?: DateTimeFilter<"Chatwoot"> | Date | string
    instanceId?: StringFilter<"Chatwoot"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type ChatwootOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    nameInbox?: SortOrderInput | SortOrder
    signMsg?: SortOrderInput | SortOrder
    signDelimiter?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    reopenConversation?: SortOrderInput | SortOrder
    conversationPending?: SortOrderInput | SortOrder
    mergeBrazilContacts?: SortOrderInput | SortOrder
    importContacts?: SortOrderInput | SortOrder
    importMessages?: SortOrderInput | SortOrder
    daysLimitImportMessages?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: ChatwootOrderByRelevanceInput
  }

  export type ChatwootWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: ChatwootWhereInput | ChatwootWhereInput[]
    OR?: ChatwootWhereInput[]
    NOT?: ChatwootWhereInput | ChatwootWhereInput[]
    enabled?: BoolNullableFilter<"Chatwoot"> | boolean | null
    accountId?: StringNullableFilter<"Chatwoot"> | string | null
    token?: StringNullableFilter<"Chatwoot"> | string | null
    url?: StringNullableFilter<"Chatwoot"> | string | null
    nameInbox?: StringNullableFilter<"Chatwoot"> | string | null
    signMsg?: BoolNullableFilter<"Chatwoot"> | boolean | null
    signDelimiter?: StringNullableFilter<"Chatwoot"> | string | null
    number?: StringNullableFilter<"Chatwoot"> | string | null
    reopenConversation?: BoolNullableFilter<"Chatwoot"> | boolean | null
    conversationPending?: BoolNullableFilter<"Chatwoot"> | boolean | null
    mergeBrazilContacts?: BoolNullableFilter<"Chatwoot"> | boolean | null
    importContacts?: BoolNullableFilter<"Chatwoot"> | boolean | null
    importMessages?: BoolNullableFilter<"Chatwoot"> | boolean | null
    daysLimitImportMessages?: IntNullableFilter<"Chatwoot"> | number | null
    organization?: StringNullableFilter<"Chatwoot"> | string | null
    logo?: StringNullableFilter<"Chatwoot"> | string | null
    ignoreJids?: JsonNullableFilter<"Chatwoot">
    createdAt?: DateTimeNullableFilter<"Chatwoot"> | Date | string | null
    updatedAt?: DateTimeFilter<"Chatwoot"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type ChatwootOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrderInput | SortOrder
    accountId?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    nameInbox?: SortOrderInput | SortOrder
    signMsg?: SortOrderInput | SortOrder
    signDelimiter?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    reopenConversation?: SortOrderInput | SortOrder
    conversationPending?: SortOrderInput | SortOrder
    mergeBrazilContacts?: SortOrderInput | SortOrder
    importContacts?: SortOrderInput | SortOrder
    importMessages?: SortOrderInput | SortOrder
    daysLimitImportMessages?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: ChatwootCountOrderByAggregateInput
    _avg?: ChatwootAvgOrderByAggregateInput
    _max?: ChatwootMaxOrderByAggregateInput
    _min?: ChatwootMinOrderByAggregateInput
    _sum?: ChatwootSumOrderByAggregateInput
  }

  export type ChatwootScalarWhereWithAggregatesInput = {
    AND?: ChatwootScalarWhereWithAggregatesInput | ChatwootScalarWhereWithAggregatesInput[]
    OR?: ChatwootScalarWhereWithAggregatesInput[]
    NOT?: ChatwootScalarWhereWithAggregatesInput | ChatwootScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chatwoot"> | string
    enabled?: BoolNullableWithAggregatesFilter<"Chatwoot"> | boolean | null
    accountId?: StringNullableWithAggregatesFilter<"Chatwoot"> | string | null
    token?: StringNullableWithAggregatesFilter<"Chatwoot"> | string | null
    url?: StringNullableWithAggregatesFilter<"Chatwoot"> | string | null
    nameInbox?: StringNullableWithAggregatesFilter<"Chatwoot"> | string | null
    signMsg?: BoolNullableWithAggregatesFilter<"Chatwoot"> | boolean | null
    signDelimiter?: StringNullableWithAggregatesFilter<"Chatwoot"> | string | null
    number?: StringNullableWithAggregatesFilter<"Chatwoot"> | string | null
    reopenConversation?: BoolNullableWithAggregatesFilter<"Chatwoot"> | boolean | null
    conversationPending?: BoolNullableWithAggregatesFilter<"Chatwoot"> | boolean | null
    mergeBrazilContacts?: BoolNullableWithAggregatesFilter<"Chatwoot"> | boolean | null
    importContacts?: BoolNullableWithAggregatesFilter<"Chatwoot"> | boolean | null
    importMessages?: BoolNullableWithAggregatesFilter<"Chatwoot"> | boolean | null
    daysLimitImportMessages?: IntNullableWithAggregatesFilter<"Chatwoot"> | number | null
    organization?: StringNullableWithAggregatesFilter<"Chatwoot"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Chatwoot"> | string | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"Chatwoot">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Chatwoot"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Chatwoot"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Chatwoot"> | string
  }

  export type LabelWhereInput = {
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    id?: StringFilter<"Label"> | string
    labelId?: StringNullableFilter<"Label"> | string | null
    name?: StringFilter<"Label"> | string
    color?: StringFilter<"Label"> | string
    predefinedId?: StringNullableFilter<"Label"> | string | null
    createdAt?: DateTimeNullableFilter<"Label"> | Date | string | null
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    instanceId?: StringFilter<"Label"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type LabelOrderByWithRelationInput = {
    id?: SortOrder
    labelId?: SortOrderInput | SortOrder
    name?: SortOrder
    color?: SortOrder
    predefinedId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: LabelOrderByRelevanceInput
  }

  export type LabelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabelWhereInput | LabelWhereInput[]
    OR?: LabelWhereInput[]
    NOT?: LabelWhereInput | LabelWhereInput[]
    labelId?: StringNullableFilter<"Label"> | string | null
    name?: StringFilter<"Label"> | string
    color?: StringFilter<"Label"> | string
    predefinedId?: StringNullableFilter<"Label"> | string | null
    createdAt?: DateTimeNullableFilter<"Label"> | Date | string | null
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    instanceId?: StringFilter<"Label"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id">

  export type LabelOrderByWithAggregationInput = {
    id?: SortOrder
    labelId?: SortOrderInput | SortOrder
    name?: SortOrder
    color?: SortOrder
    predefinedId?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: LabelCountOrderByAggregateInput
    _max?: LabelMaxOrderByAggregateInput
    _min?: LabelMinOrderByAggregateInput
  }

  export type LabelScalarWhereWithAggregatesInput = {
    AND?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    OR?: LabelScalarWhereWithAggregatesInput[]
    NOT?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Label"> | string
    labelId?: StringNullableWithAggregatesFilter<"Label"> | string | null
    name?: StringWithAggregatesFilter<"Label"> | string
    color?: StringWithAggregatesFilter<"Label"> | string
    predefinedId?: StringNullableWithAggregatesFilter<"Label"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Label"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Label"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Label"> | string
  }

  export type ProxyWhereInput = {
    AND?: ProxyWhereInput | ProxyWhereInput[]
    OR?: ProxyWhereInput[]
    NOT?: ProxyWhereInput | ProxyWhereInput[]
    id?: StringFilter<"Proxy"> | string
    enabled?: BoolFilter<"Proxy"> | boolean
    host?: StringFilter<"Proxy"> | string
    port?: StringFilter<"Proxy"> | string
    protocol?: StringFilter<"Proxy"> | string
    username?: StringFilter<"Proxy"> | string
    password?: StringFilter<"Proxy"> | string
    createdAt?: DateTimeNullableFilter<"Proxy"> | Date | string | null
    updatedAt?: DateTimeFilter<"Proxy"> | Date | string
    instanceId?: StringFilter<"Proxy"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type ProxyOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    host?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: ProxyOrderByRelevanceInput
  }

  export type ProxyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: ProxyWhereInput | ProxyWhereInput[]
    OR?: ProxyWhereInput[]
    NOT?: ProxyWhereInput | ProxyWhereInput[]
    enabled?: BoolFilter<"Proxy"> | boolean
    host?: StringFilter<"Proxy"> | string
    port?: StringFilter<"Proxy"> | string
    protocol?: StringFilter<"Proxy"> | string
    username?: StringFilter<"Proxy"> | string
    password?: StringFilter<"Proxy"> | string
    createdAt?: DateTimeNullableFilter<"Proxy"> | Date | string | null
    updatedAt?: DateTimeFilter<"Proxy"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type ProxyOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    host?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: ProxyCountOrderByAggregateInput
    _max?: ProxyMaxOrderByAggregateInput
    _min?: ProxyMinOrderByAggregateInput
  }

  export type ProxyScalarWhereWithAggregatesInput = {
    AND?: ProxyScalarWhereWithAggregatesInput | ProxyScalarWhereWithAggregatesInput[]
    OR?: ProxyScalarWhereWithAggregatesInput[]
    NOT?: ProxyScalarWhereWithAggregatesInput | ProxyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proxy"> | string
    enabled?: BoolWithAggregatesFilter<"Proxy"> | boolean
    host?: StringWithAggregatesFilter<"Proxy"> | string
    port?: StringWithAggregatesFilter<"Proxy"> | string
    protocol?: StringWithAggregatesFilter<"Proxy"> | string
    username?: StringWithAggregatesFilter<"Proxy"> | string
    password?: StringWithAggregatesFilter<"Proxy"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Proxy"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Proxy"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Proxy"> | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    rejectCall?: BoolFilter<"Setting"> | boolean
    msgCall?: StringNullableFilter<"Setting"> | string | null
    groupsIgnore?: BoolFilter<"Setting"> | boolean
    alwaysOnline?: BoolFilter<"Setting"> | boolean
    readMessages?: BoolFilter<"Setting"> | boolean
    readStatus?: BoolFilter<"Setting"> | boolean
    syncFullHistory?: BoolFilter<"Setting"> | boolean
    wavoipToken?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeNullableFilter<"Setting"> | Date | string | null
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
    instanceId?: StringFilter<"Setting"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    rejectCall?: SortOrder
    msgCall?: SortOrderInput | SortOrder
    groupsIgnore?: SortOrder
    alwaysOnline?: SortOrder
    readMessages?: SortOrder
    readStatus?: SortOrder
    syncFullHistory?: SortOrder
    wavoipToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: SettingOrderByRelevanceInput
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    rejectCall?: BoolFilter<"Setting"> | boolean
    msgCall?: StringNullableFilter<"Setting"> | string | null
    groupsIgnore?: BoolFilter<"Setting"> | boolean
    alwaysOnline?: BoolFilter<"Setting"> | boolean
    readMessages?: BoolFilter<"Setting"> | boolean
    readStatus?: BoolFilter<"Setting"> | boolean
    syncFullHistory?: BoolFilter<"Setting"> | boolean
    wavoipToken?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeNullableFilter<"Setting"> | Date | string | null
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    rejectCall?: SortOrder
    msgCall?: SortOrderInput | SortOrder
    groupsIgnore?: SortOrder
    alwaysOnline?: SortOrder
    readMessages?: SortOrder
    readStatus?: SortOrder
    syncFullHistory?: SortOrder
    wavoipToken?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    rejectCall?: BoolWithAggregatesFilter<"Setting"> | boolean
    msgCall?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    groupsIgnore?: BoolWithAggregatesFilter<"Setting"> | boolean
    alwaysOnline?: BoolWithAggregatesFilter<"Setting"> | boolean
    readMessages?: BoolWithAggregatesFilter<"Setting"> | boolean
    readStatus?: BoolWithAggregatesFilter<"Setting"> | boolean
    syncFullHistory?: BoolWithAggregatesFilter<"Setting"> | boolean
    wavoipToken?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Setting"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Setting"> | string
  }

  export type RabbitmqWhereInput = {
    AND?: RabbitmqWhereInput | RabbitmqWhereInput[]
    OR?: RabbitmqWhereInput[]
    NOT?: RabbitmqWhereInput | RabbitmqWhereInput[]
    id?: StringFilter<"Rabbitmq"> | string
    enabled?: BoolFilter<"Rabbitmq"> | boolean
    events?: JsonFilter<"Rabbitmq">
    createdAt?: DateTimeNullableFilter<"Rabbitmq"> | Date | string | null
    updatedAt?: DateTimeFilter<"Rabbitmq"> | Date | string
    instanceId?: StringFilter<"Rabbitmq"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type RabbitmqOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: RabbitmqOrderByRelevanceInput
  }

  export type RabbitmqWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: RabbitmqWhereInput | RabbitmqWhereInput[]
    OR?: RabbitmqWhereInput[]
    NOT?: RabbitmqWhereInput | RabbitmqWhereInput[]
    enabled?: BoolFilter<"Rabbitmq"> | boolean
    events?: JsonFilter<"Rabbitmq">
    createdAt?: DateTimeNullableFilter<"Rabbitmq"> | Date | string | null
    updatedAt?: DateTimeFilter<"Rabbitmq"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type RabbitmqOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: RabbitmqCountOrderByAggregateInput
    _max?: RabbitmqMaxOrderByAggregateInput
    _min?: RabbitmqMinOrderByAggregateInput
  }

  export type RabbitmqScalarWhereWithAggregatesInput = {
    AND?: RabbitmqScalarWhereWithAggregatesInput | RabbitmqScalarWhereWithAggregatesInput[]
    OR?: RabbitmqScalarWhereWithAggregatesInput[]
    NOT?: RabbitmqScalarWhereWithAggregatesInput | RabbitmqScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Rabbitmq"> | string
    enabled?: BoolWithAggregatesFilter<"Rabbitmq"> | boolean
    events?: JsonWithAggregatesFilter<"Rabbitmq">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Rabbitmq"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Rabbitmq"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Rabbitmq"> | string
  }

  export type SqsWhereInput = {
    AND?: SqsWhereInput | SqsWhereInput[]
    OR?: SqsWhereInput[]
    NOT?: SqsWhereInput | SqsWhereInput[]
    id?: StringFilter<"Sqs"> | string
    enabled?: BoolFilter<"Sqs"> | boolean
    events?: JsonFilter<"Sqs">
    createdAt?: DateTimeNullableFilter<"Sqs"> | Date | string | null
    updatedAt?: DateTimeFilter<"Sqs"> | Date | string
    instanceId?: StringFilter<"Sqs"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type SqsOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: SqsOrderByRelevanceInput
  }

  export type SqsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: SqsWhereInput | SqsWhereInput[]
    OR?: SqsWhereInput[]
    NOT?: SqsWhereInput | SqsWhereInput[]
    enabled?: BoolFilter<"Sqs"> | boolean
    events?: JsonFilter<"Sqs">
    createdAt?: DateTimeNullableFilter<"Sqs"> | Date | string | null
    updatedAt?: DateTimeFilter<"Sqs"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type SqsOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: SqsCountOrderByAggregateInput
    _max?: SqsMaxOrderByAggregateInput
    _min?: SqsMinOrderByAggregateInput
  }

  export type SqsScalarWhereWithAggregatesInput = {
    AND?: SqsScalarWhereWithAggregatesInput | SqsScalarWhereWithAggregatesInput[]
    OR?: SqsScalarWhereWithAggregatesInput[]
    NOT?: SqsScalarWhereWithAggregatesInput | SqsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sqs"> | string
    enabled?: BoolWithAggregatesFilter<"Sqs"> | boolean
    events?: JsonWithAggregatesFilter<"Sqs">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Sqs"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Sqs"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Sqs"> | string
  }

  export type WebsocketWhereInput = {
    AND?: WebsocketWhereInput | WebsocketWhereInput[]
    OR?: WebsocketWhereInput[]
    NOT?: WebsocketWhereInput | WebsocketWhereInput[]
    id?: StringFilter<"Websocket"> | string
    enabled?: BoolFilter<"Websocket"> | boolean
    events?: JsonFilter<"Websocket">
    createdAt?: DateTimeNullableFilter<"Websocket"> | Date | string | null
    updatedAt?: DateTimeFilter<"Websocket"> | Date | string
    instanceId?: StringFilter<"Websocket"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type WebsocketOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: WebsocketOrderByRelevanceInput
  }

  export type WebsocketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: WebsocketWhereInput | WebsocketWhereInput[]
    OR?: WebsocketWhereInput[]
    NOT?: WebsocketWhereInput | WebsocketWhereInput[]
    enabled?: BoolFilter<"Websocket"> | boolean
    events?: JsonFilter<"Websocket">
    createdAt?: DateTimeNullableFilter<"Websocket"> | Date | string | null
    updatedAt?: DateTimeFilter<"Websocket"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type WebsocketOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: WebsocketCountOrderByAggregateInput
    _max?: WebsocketMaxOrderByAggregateInput
    _min?: WebsocketMinOrderByAggregateInput
  }

  export type WebsocketScalarWhereWithAggregatesInput = {
    AND?: WebsocketScalarWhereWithAggregatesInput | WebsocketScalarWhereWithAggregatesInput[]
    OR?: WebsocketScalarWhereWithAggregatesInput[]
    NOT?: WebsocketScalarWhereWithAggregatesInput | WebsocketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Websocket"> | string
    enabled?: BoolWithAggregatesFilter<"Websocket"> | boolean
    events?: JsonWithAggregatesFilter<"Websocket">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Websocket"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Websocket"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Websocket"> | string
  }

  export type PusherWhereInput = {
    AND?: PusherWhereInput | PusherWhereInput[]
    OR?: PusherWhereInput[]
    NOT?: PusherWhereInput | PusherWhereInput[]
    id?: StringFilter<"Pusher"> | string
    enabled?: BoolFilter<"Pusher"> | boolean
    appId?: StringFilter<"Pusher"> | string
    key?: StringFilter<"Pusher"> | string
    secret?: StringFilter<"Pusher"> | string
    cluster?: StringFilter<"Pusher"> | string
    useTLS?: BoolFilter<"Pusher"> | boolean
    events?: JsonFilter<"Pusher">
    createdAt?: DateTimeNullableFilter<"Pusher"> | Date | string | null
    updatedAt?: DateTimeFilter<"Pusher"> | Date | string
    instanceId?: StringFilter<"Pusher"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type PusherOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    appId?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    cluster?: SortOrder
    useTLS?: SortOrder
    events?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: PusherOrderByRelevanceInput
  }

  export type PusherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: PusherWhereInput | PusherWhereInput[]
    OR?: PusherWhereInput[]
    NOT?: PusherWhereInput | PusherWhereInput[]
    enabled?: BoolFilter<"Pusher"> | boolean
    appId?: StringFilter<"Pusher"> | string
    key?: StringFilter<"Pusher"> | string
    secret?: StringFilter<"Pusher"> | string
    cluster?: StringFilter<"Pusher"> | string
    useTLS?: BoolFilter<"Pusher"> | boolean
    events?: JsonFilter<"Pusher">
    createdAt?: DateTimeNullableFilter<"Pusher"> | Date | string | null
    updatedAt?: DateTimeFilter<"Pusher"> | Date | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type PusherOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    appId?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    cluster?: SortOrder
    useTLS?: SortOrder
    events?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: PusherCountOrderByAggregateInput
    _max?: PusherMaxOrderByAggregateInput
    _min?: PusherMinOrderByAggregateInput
  }

  export type PusherScalarWhereWithAggregatesInput = {
    AND?: PusherScalarWhereWithAggregatesInput | PusherScalarWhereWithAggregatesInput[]
    OR?: PusherScalarWhereWithAggregatesInput[]
    NOT?: PusherScalarWhereWithAggregatesInput | PusherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pusher"> | string
    enabled?: BoolWithAggregatesFilter<"Pusher"> | boolean
    appId?: StringWithAggregatesFilter<"Pusher"> | string
    key?: StringWithAggregatesFilter<"Pusher"> | string
    secret?: StringWithAggregatesFilter<"Pusher"> | string
    cluster?: StringWithAggregatesFilter<"Pusher"> | string
    useTLS?: BoolWithAggregatesFilter<"Pusher"> | boolean
    events?: JsonWithAggregatesFilter<"Pusher">
    createdAt?: DateTimeNullableWithAggregatesFilter<"Pusher"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Pusher"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Pusher"> | string
  }

  export type TypebotWhereInput = {
    AND?: TypebotWhereInput | TypebotWhereInput[]
    OR?: TypebotWhereInput[]
    NOT?: TypebotWhereInput | TypebotWhereInput[]
    id?: StringFilter<"Typebot"> | string
    enabled?: BoolFilter<"Typebot"> | boolean
    description?: StringNullableFilter<"Typebot"> | string | null
    url?: StringFilter<"Typebot"> | string
    typebot?: StringFilter<"Typebot"> | string
    expire?: IntNullableFilter<"Typebot"> | number | null
    keywordFinish?: StringNullableFilter<"Typebot"> | string | null
    delayMessage?: IntNullableFilter<"Typebot"> | number | null
    unknownMessage?: StringNullableFilter<"Typebot"> | string | null
    listeningFromMe?: BoolNullableFilter<"Typebot"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"Typebot"> | boolean | null
    keepOpen?: BoolNullableFilter<"Typebot"> | boolean | null
    debounceTime?: IntNullableFilter<"Typebot"> | number | null
    createdAt?: DateTimeNullableFilter<"Typebot"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Typebot"> | Date | string | null
    ignoreJids?: JsonNullableFilter<"Typebot">
    triggerType?: EnumTriggerTypeNullableFilter<"Typebot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"Typebot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"Typebot"> | string | null
    instanceId?: StringFilter<"Typebot"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    TypebotSetting?: TypebotSettingListRelationFilter
  }

  export type TypebotOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    typebot?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    TypebotSetting?: TypebotSettingOrderByRelationAggregateInput
    _relevance?: TypebotOrderByRelevanceInput
  }

  export type TypebotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TypebotWhereInput | TypebotWhereInput[]
    OR?: TypebotWhereInput[]
    NOT?: TypebotWhereInput | TypebotWhereInput[]
    enabled?: BoolFilter<"Typebot"> | boolean
    description?: StringNullableFilter<"Typebot"> | string | null
    url?: StringFilter<"Typebot"> | string
    typebot?: StringFilter<"Typebot"> | string
    expire?: IntNullableFilter<"Typebot"> | number | null
    keywordFinish?: StringNullableFilter<"Typebot"> | string | null
    delayMessage?: IntNullableFilter<"Typebot"> | number | null
    unknownMessage?: StringNullableFilter<"Typebot"> | string | null
    listeningFromMe?: BoolNullableFilter<"Typebot"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"Typebot"> | boolean | null
    keepOpen?: BoolNullableFilter<"Typebot"> | boolean | null
    debounceTime?: IntNullableFilter<"Typebot"> | number | null
    createdAt?: DateTimeNullableFilter<"Typebot"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Typebot"> | Date | string | null
    ignoreJids?: JsonNullableFilter<"Typebot">
    triggerType?: EnumTriggerTypeNullableFilter<"Typebot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"Typebot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"Typebot"> | string | null
    instanceId?: StringFilter<"Typebot"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    TypebotSetting?: TypebotSettingListRelationFilter
  }, "id">

  export type TypebotOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrder
    typebot?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    _count?: TypebotCountOrderByAggregateInput
    _avg?: TypebotAvgOrderByAggregateInput
    _max?: TypebotMaxOrderByAggregateInput
    _min?: TypebotMinOrderByAggregateInput
    _sum?: TypebotSumOrderByAggregateInput
  }

  export type TypebotScalarWhereWithAggregatesInput = {
    AND?: TypebotScalarWhereWithAggregatesInput | TypebotScalarWhereWithAggregatesInput[]
    OR?: TypebotScalarWhereWithAggregatesInput[]
    NOT?: TypebotScalarWhereWithAggregatesInput | TypebotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Typebot"> | string
    enabled?: BoolWithAggregatesFilter<"Typebot"> | boolean
    description?: StringNullableWithAggregatesFilter<"Typebot"> | string | null
    url?: StringWithAggregatesFilter<"Typebot"> | string
    typebot?: StringWithAggregatesFilter<"Typebot"> | string
    expire?: IntNullableWithAggregatesFilter<"Typebot"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"Typebot"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"Typebot"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"Typebot"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"Typebot"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"Typebot"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"Typebot"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"Typebot"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Typebot"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Typebot"> | Date | string | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"Typebot">
    triggerType?: EnumTriggerTypeNullableWithAggregatesFilter<"Typebot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableWithAggregatesFilter<"Typebot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableWithAggregatesFilter<"Typebot"> | string | null
    instanceId?: StringWithAggregatesFilter<"Typebot"> | string
  }

  export type TypebotSettingWhereInput = {
    AND?: TypebotSettingWhereInput | TypebotSettingWhereInput[]
    OR?: TypebotSettingWhereInput[]
    NOT?: TypebotSettingWhereInput | TypebotSettingWhereInput[]
    id?: StringFilter<"TypebotSetting"> | string
    expire?: IntNullableFilter<"TypebotSetting"> | number | null
    keywordFinish?: StringNullableFilter<"TypebotSetting"> | string | null
    delayMessage?: IntNullableFilter<"TypebotSetting"> | number | null
    unknownMessage?: StringNullableFilter<"TypebotSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"TypebotSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"TypebotSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"TypebotSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"TypebotSetting"> | number | null
    typebotIdFallback?: StringNullableFilter<"TypebotSetting"> | string | null
    ignoreJids?: JsonNullableFilter<"TypebotSetting">
    createdAt?: DateTimeNullableFilter<"TypebotSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"TypebotSetting"> | Date | string
    instanceId?: StringFilter<"TypebotSetting"> | string
    Fallback?: XOR<TypebotNullableScalarRelationFilter, TypebotWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type TypebotSettingOrderByWithRelationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    typebotIdFallback?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Fallback?: TypebotOrderByWithRelationInput
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: TypebotSettingOrderByRelevanceInput
  }

  export type TypebotSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: TypebotSettingWhereInput | TypebotSettingWhereInput[]
    OR?: TypebotSettingWhereInput[]
    NOT?: TypebotSettingWhereInput | TypebotSettingWhereInput[]
    expire?: IntNullableFilter<"TypebotSetting"> | number | null
    keywordFinish?: StringNullableFilter<"TypebotSetting"> | string | null
    delayMessage?: IntNullableFilter<"TypebotSetting"> | number | null
    unknownMessage?: StringNullableFilter<"TypebotSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"TypebotSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"TypebotSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"TypebotSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"TypebotSetting"> | number | null
    typebotIdFallback?: StringNullableFilter<"TypebotSetting"> | string | null
    ignoreJids?: JsonNullableFilter<"TypebotSetting">
    createdAt?: DateTimeNullableFilter<"TypebotSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"TypebotSetting"> | Date | string
    Fallback?: XOR<TypebotNullableScalarRelationFilter, TypebotWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type TypebotSettingOrderByWithAggregationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    typebotIdFallback?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: TypebotSettingCountOrderByAggregateInput
    _avg?: TypebotSettingAvgOrderByAggregateInput
    _max?: TypebotSettingMaxOrderByAggregateInput
    _min?: TypebotSettingMinOrderByAggregateInput
    _sum?: TypebotSettingSumOrderByAggregateInput
  }

  export type TypebotSettingScalarWhereWithAggregatesInput = {
    AND?: TypebotSettingScalarWhereWithAggregatesInput | TypebotSettingScalarWhereWithAggregatesInput[]
    OR?: TypebotSettingScalarWhereWithAggregatesInput[]
    NOT?: TypebotSettingScalarWhereWithAggregatesInput | TypebotSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TypebotSetting"> | string
    expire?: IntNullableWithAggregatesFilter<"TypebotSetting"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"TypebotSetting"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"TypebotSetting"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"TypebotSetting"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"TypebotSetting"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"TypebotSetting"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"TypebotSetting"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"TypebotSetting"> | number | null
    typebotIdFallback?: StringNullableWithAggregatesFilter<"TypebotSetting"> | string | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"TypebotSetting">
    createdAt?: DateTimeNullableWithAggregatesFilter<"TypebotSetting"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"TypebotSetting"> | Date | string
    instanceId?: StringWithAggregatesFilter<"TypebotSetting"> | string
  }

  export type IntegrationSessionWhereInput = {
    AND?: IntegrationSessionWhereInput | IntegrationSessionWhereInput[]
    OR?: IntegrationSessionWhereInput[]
    NOT?: IntegrationSessionWhereInput | IntegrationSessionWhereInput[]
    id?: StringFilter<"IntegrationSession"> | string
    sessionId?: StringFilter<"IntegrationSession"> | string
    remoteJid?: StringFilter<"IntegrationSession"> | string
    pushName?: StringNullableFilter<"IntegrationSession"> | string | null
    status?: EnumSessionStatusFilter<"IntegrationSession"> | $Enums.SessionStatus
    awaitUser?: BoolFilter<"IntegrationSession"> | boolean
    context?: JsonNullableFilter<"IntegrationSession">
    type?: StringNullableFilter<"IntegrationSession"> | string | null
    createdAt?: DateTimeNullableFilter<"IntegrationSession"> | Date | string | null
    updatedAt?: DateTimeFilter<"IntegrationSession"> | Date | string
    instanceId?: StringFilter<"IntegrationSession"> | string
    parameters?: JsonNullableFilter<"IntegrationSession">
    botId?: StringNullableFilter<"IntegrationSession"> | string | null
    Message?: MessageListRelationFilter
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type IntegrationSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrderInput | SortOrder
    status?: SortOrder
    awaitUser?: SortOrder
    context?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    parameters?: SortOrderInput | SortOrder
    botId?: SortOrderInput | SortOrder
    Message?: MessageOrderByRelationAggregateInput
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: IntegrationSessionOrderByRelevanceInput
  }

  export type IntegrationSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntegrationSessionWhereInput | IntegrationSessionWhereInput[]
    OR?: IntegrationSessionWhereInput[]
    NOT?: IntegrationSessionWhereInput | IntegrationSessionWhereInput[]
    sessionId?: StringFilter<"IntegrationSession"> | string
    remoteJid?: StringFilter<"IntegrationSession"> | string
    pushName?: StringNullableFilter<"IntegrationSession"> | string | null
    status?: EnumSessionStatusFilter<"IntegrationSession"> | $Enums.SessionStatus
    awaitUser?: BoolFilter<"IntegrationSession"> | boolean
    context?: JsonNullableFilter<"IntegrationSession">
    type?: StringNullableFilter<"IntegrationSession"> | string | null
    createdAt?: DateTimeNullableFilter<"IntegrationSession"> | Date | string | null
    updatedAt?: DateTimeFilter<"IntegrationSession"> | Date | string
    instanceId?: StringFilter<"IntegrationSession"> | string
    parameters?: JsonNullableFilter<"IntegrationSession">
    botId?: StringNullableFilter<"IntegrationSession"> | string | null
    Message?: MessageListRelationFilter
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id">

  export type IntegrationSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrderInput | SortOrder
    status?: SortOrder
    awaitUser?: SortOrder
    context?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    parameters?: SortOrderInput | SortOrder
    botId?: SortOrderInput | SortOrder
    _count?: IntegrationSessionCountOrderByAggregateInput
    _max?: IntegrationSessionMaxOrderByAggregateInput
    _min?: IntegrationSessionMinOrderByAggregateInput
  }

  export type IntegrationSessionScalarWhereWithAggregatesInput = {
    AND?: IntegrationSessionScalarWhereWithAggregatesInput | IntegrationSessionScalarWhereWithAggregatesInput[]
    OR?: IntegrationSessionScalarWhereWithAggregatesInput[]
    NOT?: IntegrationSessionScalarWhereWithAggregatesInput | IntegrationSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntegrationSession"> | string
    sessionId?: StringWithAggregatesFilter<"IntegrationSession"> | string
    remoteJid?: StringWithAggregatesFilter<"IntegrationSession"> | string
    pushName?: StringNullableWithAggregatesFilter<"IntegrationSession"> | string | null
    status?: EnumSessionStatusWithAggregatesFilter<"IntegrationSession"> | $Enums.SessionStatus
    awaitUser?: BoolWithAggregatesFilter<"IntegrationSession"> | boolean
    context?: JsonNullableWithAggregatesFilter<"IntegrationSession">
    type?: StringNullableWithAggregatesFilter<"IntegrationSession"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"IntegrationSession"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"IntegrationSession"> | Date | string
    instanceId?: StringWithAggregatesFilter<"IntegrationSession"> | string
    parameters?: JsonNullableWithAggregatesFilter<"IntegrationSession">
    botId?: StringNullableWithAggregatesFilter<"IntegrationSession"> | string | null
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    fileName?: StringFilter<"Media"> | string
    type?: StringFilter<"Media"> | string
    mimetype?: StringFilter<"Media"> | string
    createdAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    messageId?: StringFilter<"Media"> | string
    instanceId?: StringFilter<"Media"> | string
    Message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    mimetype?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
    Message?: MessageOrderByWithRelationInput
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: MediaOrderByRelevanceInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fileName?: string
    messageId?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    type?: StringFilter<"Media"> | string
    mimetype?: StringFilter<"Media"> | string
    createdAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    instanceId?: StringFilter<"Media"> | string
    Message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "fileName" | "messageId">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    mimetype?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    fileName?: StringWithAggregatesFilter<"Media"> | string
    type?: StringWithAggregatesFilter<"Media"> | string
    mimetype?: StringWithAggregatesFilter<"Media"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Media"> | Date | string | null
    messageId?: StringWithAggregatesFilter<"Media"> | string
    instanceId?: StringWithAggregatesFilter<"Media"> | string
  }

  export type OpenaiCredsWhereInput = {
    AND?: OpenaiCredsWhereInput | OpenaiCredsWhereInput[]
    OR?: OpenaiCredsWhereInput[]
    NOT?: OpenaiCredsWhereInput | OpenaiCredsWhereInput[]
    id?: StringFilter<"OpenaiCreds"> | string
    name?: StringNullableFilter<"OpenaiCreds"> | string | null
    apiKey?: StringNullableFilter<"OpenaiCreds"> | string | null
    createdAt?: DateTimeNullableFilter<"OpenaiCreds"> | Date | string | null
    updatedAt?: DateTimeFilter<"OpenaiCreds"> | Date | string
    instanceId?: StringFilter<"OpenaiCreds"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    OpenaiAssistant?: OpenaiBotListRelationFilter
    OpenaiSetting?: XOR<OpenaiSettingNullableScalarRelationFilter, OpenaiSettingWhereInput> | null
  }

  export type OpenaiCredsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    OpenaiAssistant?: OpenaiBotOrderByRelationAggregateInput
    OpenaiSetting?: OpenaiSettingOrderByWithRelationInput
    _relevance?: OpenaiCredsOrderByRelevanceInput
  }

  export type OpenaiCredsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    apiKey?: string
    AND?: OpenaiCredsWhereInput | OpenaiCredsWhereInput[]
    OR?: OpenaiCredsWhereInput[]
    NOT?: OpenaiCredsWhereInput | OpenaiCredsWhereInput[]
    createdAt?: DateTimeNullableFilter<"OpenaiCreds"> | Date | string | null
    updatedAt?: DateTimeFilter<"OpenaiCreds"> | Date | string
    instanceId?: StringFilter<"OpenaiCreds"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    OpenaiAssistant?: OpenaiBotListRelationFilter
    OpenaiSetting?: XOR<OpenaiSettingNullableScalarRelationFilter, OpenaiSettingWhereInput> | null
  }, "id" | "name" | "apiKey">

  export type OpenaiCredsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: OpenaiCredsCountOrderByAggregateInput
    _max?: OpenaiCredsMaxOrderByAggregateInput
    _min?: OpenaiCredsMinOrderByAggregateInput
  }

  export type OpenaiCredsScalarWhereWithAggregatesInput = {
    AND?: OpenaiCredsScalarWhereWithAggregatesInput | OpenaiCredsScalarWhereWithAggregatesInput[]
    OR?: OpenaiCredsScalarWhereWithAggregatesInput[]
    NOT?: OpenaiCredsScalarWhereWithAggregatesInput | OpenaiCredsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpenaiCreds"> | string
    name?: StringNullableWithAggregatesFilter<"OpenaiCreds"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"OpenaiCreds"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"OpenaiCreds"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"OpenaiCreds"> | Date | string
    instanceId?: StringWithAggregatesFilter<"OpenaiCreds"> | string
  }

  export type OpenaiBotWhereInput = {
    AND?: OpenaiBotWhereInput | OpenaiBotWhereInput[]
    OR?: OpenaiBotWhereInput[]
    NOT?: OpenaiBotWhereInput | OpenaiBotWhereInput[]
    id?: StringFilter<"OpenaiBot"> | string
    enabled?: BoolFilter<"OpenaiBot"> | boolean
    description?: StringNullableFilter<"OpenaiBot"> | string | null
    botType?: EnumOpenaiBotTypeFilter<"OpenaiBot"> | $Enums.OpenaiBotType
    assistantId?: StringNullableFilter<"OpenaiBot"> | string | null
    functionUrl?: StringNullableFilter<"OpenaiBot"> | string | null
    model?: StringNullableFilter<"OpenaiBot"> | string | null
    systemMessages?: JsonNullableFilter<"OpenaiBot">
    assistantMessages?: JsonNullableFilter<"OpenaiBot">
    userMessages?: JsonNullableFilter<"OpenaiBot">
    maxTokens?: IntNullableFilter<"OpenaiBot"> | number | null
    expire?: IntNullableFilter<"OpenaiBot"> | number | null
    keywordFinish?: StringNullableFilter<"OpenaiBot"> | string | null
    delayMessage?: IntNullableFilter<"OpenaiBot"> | number | null
    unknownMessage?: StringNullableFilter<"OpenaiBot"> | string | null
    listeningFromMe?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    keepOpen?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    debounceTime?: IntNullableFilter<"OpenaiBot"> | number | null
    ignoreJids?: JsonNullableFilter<"OpenaiBot">
    splitMessages?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    timePerChar?: IntNullableFilter<"OpenaiBot"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"OpenaiBot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"OpenaiBot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"OpenaiBot"> | string | null
    createdAt?: DateTimeNullableFilter<"OpenaiBot"> | Date | string | null
    updatedAt?: DateTimeFilter<"OpenaiBot"> | Date | string
    openaiCredsId?: StringFilter<"OpenaiBot"> | string
    instanceId?: StringFilter<"OpenaiBot"> | string
    OpenaiCreds?: XOR<OpenaiCredsScalarRelationFilter, OpenaiCredsWhereInput>
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    OpenaiSetting?: OpenaiSettingListRelationFilter
  }

  export type OpenaiBotOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    botType?: SortOrder
    assistantId?: SortOrderInput | SortOrder
    functionUrl?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    systemMessages?: SortOrderInput | SortOrder
    assistantMessages?: SortOrderInput | SortOrder
    userMessages?: SortOrderInput | SortOrder
    maxTokens?: SortOrderInput | SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    instanceId?: SortOrder
    OpenaiCreds?: OpenaiCredsOrderByWithRelationInput
    Instance?: InstanceOrderByWithRelationInput
    OpenaiSetting?: OpenaiSettingOrderByRelationAggregateInput
    _relevance?: OpenaiBotOrderByRelevanceInput
  }

  export type OpenaiBotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OpenaiBotWhereInput | OpenaiBotWhereInput[]
    OR?: OpenaiBotWhereInput[]
    NOT?: OpenaiBotWhereInput | OpenaiBotWhereInput[]
    enabled?: BoolFilter<"OpenaiBot"> | boolean
    description?: StringNullableFilter<"OpenaiBot"> | string | null
    botType?: EnumOpenaiBotTypeFilter<"OpenaiBot"> | $Enums.OpenaiBotType
    assistantId?: StringNullableFilter<"OpenaiBot"> | string | null
    functionUrl?: StringNullableFilter<"OpenaiBot"> | string | null
    model?: StringNullableFilter<"OpenaiBot"> | string | null
    systemMessages?: JsonNullableFilter<"OpenaiBot">
    assistantMessages?: JsonNullableFilter<"OpenaiBot">
    userMessages?: JsonNullableFilter<"OpenaiBot">
    maxTokens?: IntNullableFilter<"OpenaiBot"> | number | null
    expire?: IntNullableFilter<"OpenaiBot"> | number | null
    keywordFinish?: StringNullableFilter<"OpenaiBot"> | string | null
    delayMessage?: IntNullableFilter<"OpenaiBot"> | number | null
    unknownMessage?: StringNullableFilter<"OpenaiBot"> | string | null
    listeningFromMe?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    keepOpen?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    debounceTime?: IntNullableFilter<"OpenaiBot"> | number | null
    ignoreJids?: JsonNullableFilter<"OpenaiBot">
    splitMessages?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    timePerChar?: IntNullableFilter<"OpenaiBot"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"OpenaiBot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"OpenaiBot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"OpenaiBot"> | string | null
    createdAt?: DateTimeNullableFilter<"OpenaiBot"> | Date | string | null
    updatedAt?: DateTimeFilter<"OpenaiBot"> | Date | string
    openaiCredsId?: StringFilter<"OpenaiBot"> | string
    instanceId?: StringFilter<"OpenaiBot"> | string
    OpenaiCreds?: XOR<OpenaiCredsScalarRelationFilter, OpenaiCredsWhereInput>
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    OpenaiSetting?: OpenaiSettingListRelationFilter
  }, "id">

  export type OpenaiBotOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    botType?: SortOrder
    assistantId?: SortOrderInput | SortOrder
    functionUrl?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    systemMessages?: SortOrderInput | SortOrder
    assistantMessages?: SortOrderInput | SortOrder
    userMessages?: SortOrderInput | SortOrder
    maxTokens?: SortOrderInput | SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    instanceId?: SortOrder
    _count?: OpenaiBotCountOrderByAggregateInput
    _avg?: OpenaiBotAvgOrderByAggregateInput
    _max?: OpenaiBotMaxOrderByAggregateInput
    _min?: OpenaiBotMinOrderByAggregateInput
    _sum?: OpenaiBotSumOrderByAggregateInput
  }

  export type OpenaiBotScalarWhereWithAggregatesInput = {
    AND?: OpenaiBotScalarWhereWithAggregatesInput | OpenaiBotScalarWhereWithAggregatesInput[]
    OR?: OpenaiBotScalarWhereWithAggregatesInput[]
    NOT?: OpenaiBotScalarWhereWithAggregatesInput | OpenaiBotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpenaiBot"> | string
    enabled?: BoolWithAggregatesFilter<"OpenaiBot"> | boolean
    description?: StringNullableWithAggregatesFilter<"OpenaiBot"> | string | null
    botType?: EnumOpenaiBotTypeWithAggregatesFilter<"OpenaiBot"> | $Enums.OpenaiBotType
    assistantId?: StringNullableWithAggregatesFilter<"OpenaiBot"> | string | null
    functionUrl?: StringNullableWithAggregatesFilter<"OpenaiBot"> | string | null
    model?: StringNullableWithAggregatesFilter<"OpenaiBot"> | string | null
    systemMessages?: JsonNullableWithAggregatesFilter<"OpenaiBot">
    assistantMessages?: JsonNullableWithAggregatesFilter<"OpenaiBot">
    userMessages?: JsonNullableWithAggregatesFilter<"OpenaiBot">
    maxTokens?: IntNullableWithAggregatesFilter<"OpenaiBot"> | number | null
    expire?: IntNullableWithAggregatesFilter<"OpenaiBot"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"OpenaiBot"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"OpenaiBot"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"OpenaiBot"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"OpenaiBot"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"OpenaiBot"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"OpenaiBot"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"OpenaiBot"> | number | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"OpenaiBot">
    splitMessages?: BoolNullableWithAggregatesFilter<"OpenaiBot"> | boolean | null
    timePerChar?: IntNullableWithAggregatesFilter<"OpenaiBot"> | number | null
    triggerType?: EnumTriggerTypeNullableWithAggregatesFilter<"OpenaiBot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableWithAggregatesFilter<"OpenaiBot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableWithAggregatesFilter<"OpenaiBot"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"OpenaiBot"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"OpenaiBot"> | Date | string
    openaiCredsId?: StringWithAggregatesFilter<"OpenaiBot"> | string
    instanceId?: StringWithAggregatesFilter<"OpenaiBot"> | string
  }

  export type OpenaiSettingWhereInput = {
    AND?: OpenaiSettingWhereInput | OpenaiSettingWhereInput[]
    OR?: OpenaiSettingWhereInput[]
    NOT?: OpenaiSettingWhereInput | OpenaiSettingWhereInput[]
    id?: StringFilter<"OpenaiSetting"> | string
    expire?: IntNullableFilter<"OpenaiSetting"> | number | null
    keywordFinish?: StringNullableFilter<"OpenaiSetting"> | string | null
    delayMessage?: IntNullableFilter<"OpenaiSetting"> | number | null
    unknownMessage?: StringNullableFilter<"OpenaiSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"OpenaiSetting"> | number | null
    ignoreJids?: JsonNullableFilter<"OpenaiSetting">
    splitMessages?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    timePerChar?: IntNullableFilter<"OpenaiSetting"> | number | null
    speechToText?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    createdAt?: DateTimeNullableFilter<"OpenaiSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"OpenaiSetting"> | Date | string
    openaiCredsId?: StringFilter<"OpenaiSetting"> | string
    openaiIdFallback?: StringNullableFilter<"OpenaiSetting"> | string | null
    instanceId?: StringFilter<"OpenaiSetting"> | string
    OpenaiCreds?: XOR<OpenaiCredsNullableScalarRelationFilter, OpenaiCredsWhereInput> | null
    Fallback?: XOR<OpenaiBotNullableScalarRelationFilter, OpenaiBotWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type OpenaiSettingOrderByWithRelationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    speechToText?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    openaiIdFallback?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    OpenaiCreds?: OpenaiCredsOrderByWithRelationInput
    Fallback?: OpenaiBotOrderByWithRelationInput
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: OpenaiSettingOrderByRelevanceInput
  }

  export type OpenaiSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    openaiCredsId?: string
    instanceId?: string
    AND?: OpenaiSettingWhereInput | OpenaiSettingWhereInput[]
    OR?: OpenaiSettingWhereInput[]
    NOT?: OpenaiSettingWhereInput | OpenaiSettingWhereInput[]
    expire?: IntNullableFilter<"OpenaiSetting"> | number | null
    keywordFinish?: StringNullableFilter<"OpenaiSetting"> | string | null
    delayMessage?: IntNullableFilter<"OpenaiSetting"> | number | null
    unknownMessage?: StringNullableFilter<"OpenaiSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"OpenaiSetting"> | number | null
    ignoreJids?: JsonNullableFilter<"OpenaiSetting">
    splitMessages?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    timePerChar?: IntNullableFilter<"OpenaiSetting"> | number | null
    speechToText?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    createdAt?: DateTimeNullableFilter<"OpenaiSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"OpenaiSetting"> | Date | string
    openaiIdFallback?: StringNullableFilter<"OpenaiSetting"> | string | null
    OpenaiCreds?: XOR<OpenaiCredsNullableScalarRelationFilter, OpenaiCredsWhereInput> | null
    Fallback?: XOR<OpenaiBotNullableScalarRelationFilter, OpenaiBotWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "openaiCredsId" | "instanceId">

  export type OpenaiSettingOrderByWithAggregationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    speechToText?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    openaiIdFallback?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    _count?: OpenaiSettingCountOrderByAggregateInput
    _avg?: OpenaiSettingAvgOrderByAggregateInput
    _max?: OpenaiSettingMaxOrderByAggregateInput
    _min?: OpenaiSettingMinOrderByAggregateInput
    _sum?: OpenaiSettingSumOrderByAggregateInput
  }

  export type OpenaiSettingScalarWhereWithAggregatesInput = {
    AND?: OpenaiSettingScalarWhereWithAggregatesInput | OpenaiSettingScalarWhereWithAggregatesInput[]
    OR?: OpenaiSettingScalarWhereWithAggregatesInput[]
    NOT?: OpenaiSettingScalarWhereWithAggregatesInput | OpenaiSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpenaiSetting"> | string
    expire?: IntNullableWithAggregatesFilter<"OpenaiSetting"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"OpenaiSetting"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"OpenaiSetting"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"OpenaiSetting"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"OpenaiSetting"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"OpenaiSetting"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"OpenaiSetting"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"OpenaiSetting"> | number | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"OpenaiSetting">
    splitMessages?: BoolNullableWithAggregatesFilter<"OpenaiSetting"> | boolean | null
    timePerChar?: IntNullableWithAggregatesFilter<"OpenaiSetting"> | number | null
    speechToText?: BoolNullableWithAggregatesFilter<"OpenaiSetting"> | boolean | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"OpenaiSetting"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"OpenaiSetting"> | Date | string
    openaiCredsId?: StringWithAggregatesFilter<"OpenaiSetting"> | string
    openaiIdFallback?: StringNullableWithAggregatesFilter<"OpenaiSetting"> | string | null
    instanceId?: StringWithAggregatesFilter<"OpenaiSetting"> | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: StringFilter<"Template"> | string
    templateId?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    template?: JsonFilter<"Template">
    webhookUrl?: StringNullableFilter<"Template"> | string | null
    createdAt?: DateTimeNullableFilter<"Template"> | Date | string | null
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    instanceId?: StringFilter<"Template"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrder
    name?: SortOrder
    template?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: TemplateOrderByRelevanceInput
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    templateId?: string
    name?: string
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    template?: JsonFilter<"Template">
    webhookUrl?: StringNullableFilter<"Template"> | string | null
    createdAt?: DateTimeNullableFilter<"Template"> | Date | string | null
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    instanceId?: StringFilter<"Template"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "templateId" | "name">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrder
    name?: SortOrder
    template?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Template"> | string
    templateId?: StringWithAggregatesFilter<"Template"> | string
    name?: StringWithAggregatesFilter<"Template"> | string
    template?: JsonWithAggregatesFilter<"Template">
    webhookUrl?: StringNullableWithAggregatesFilter<"Template"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Template"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Template"> | string
  }

  export type DifyWhereInput = {
    AND?: DifyWhereInput | DifyWhereInput[]
    OR?: DifyWhereInput[]
    NOT?: DifyWhereInput | DifyWhereInput[]
    id?: StringFilter<"Dify"> | string
    enabled?: BoolFilter<"Dify"> | boolean
    description?: StringNullableFilter<"Dify"> | string | null
    botType?: EnumDifyBotTypeFilter<"Dify"> | $Enums.DifyBotType
    apiUrl?: StringNullableFilter<"Dify"> | string | null
    apiKey?: StringNullableFilter<"Dify"> | string | null
    expire?: IntNullableFilter<"Dify"> | number | null
    keywordFinish?: StringNullableFilter<"Dify"> | string | null
    delayMessage?: IntNullableFilter<"Dify"> | number | null
    unknownMessage?: StringNullableFilter<"Dify"> | string | null
    listeningFromMe?: BoolNullableFilter<"Dify"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"Dify"> | boolean | null
    keepOpen?: BoolNullableFilter<"Dify"> | boolean | null
    debounceTime?: IntNullableFilter<"Dify"> | number | null
    ignoreJids?: JsonNullableFilter<"Dify">
    splitMessages?: BoolNullableFilter<"Dify"> | boolean | null
    timePerChar?: IntNullableFilter<"Dify"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"Dify"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"Dify"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"Dify"> | string | null
    createdAt?: DateTimeNullableFilter<"Dify"> | Date | string | null
    updatedAt?: DateTimeFilter<"Dify"> | Date | string
    instanceId?: StringFilter<"Dify"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    DifySetting?: DifySettingListRelationFilter
  }

  export type DifyOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    botType?: SortOrder
    apiUrl?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    DifySetting?: DifySettingOrderByRelationAggregateInput
    _relevance?: DifyOrderByRelevanceInput
  }

  export type DifyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DifyWhereInput | DifyWhereInput[]
    OR?: DifyWhereInput[]
    NOT?: DifyWhereInput | DifyWhereInput[]
    enabled?: BoolFilter<"Dify"> | boolean
    description?: StringNullableFilter<"Dify"> | string | null
    botType?: EnumDifyBotTypeFilter<"Dify"> | $Enums.DifyBotType
    apiUrl?: StringNullableFilter<"Dify"> | string | null
    apiKey?: StringNullableFilter<"Dify"> | string | null
    expire?: IntNullableFilter<"Dify"> | number | null
    keywordFinish?: StringNullableFilter<"Dify"> | string | null
    delayMessage?: IntNullableFilter<"Dify"> | number | null
    unknownMessage?: StringNullableFilter<"Dify"> | string | null
    listeningFromMe?: BoolNullableFilter<"Dify"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"Dify"> | boolean | null
    keepOpen?: BoolNullableFilter<"Dify"> | boolean | null
    debounceTime?: IntNullableFilter<"Dify"> | number | null
    ignoreJids?: JsonNullableFilter<"Dify">
    splitMessages?: BoolNullableFilter<"Dify"> | boolean | null
    timePerChar?: IntNullableFilter<"Dify"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"Dify"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"Dify"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"Dify"> | string | null
    createdAt?: DateTimeNullableFilter<"Dify"> | Date | string | null
    updatedAt?: DateTimeFilter<"Dify"> | Date | string
    instanceId?: StringFilter<"Dify"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    DifySetting?: DifySettingListRelationFilter
  }, "id">

  export type DifyOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    botType?: SortOrder
    apiUrl?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: DifyCountOrderByAggregateInput
    _avg?: DifyAvgOrderByAggregateInput
    _max?: DifyMaxOrderByAggregateInput
    _min?: DifyMinOrderByAggregateInput
    _sum?: DifySumOrderByAggregateInput
  }

  export type DifyScalarWhereWithAggregatesInput = {
    AND?: DifyScalarWhereWithAggregatesInput | DifyScalarWhereWithAggregatesInput[]
    OR?: DifyScalarWhereWithAggregatesInput[]
    NOT?: DifyScalarWhereWithAggregatesInput | DifyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dify"> | string
    enabled?: BoolWithAggregatesFilter<"Dify"> | boolean
    description?: StringNullableWithAggregatesFilter<"Dify"> | string | null
    botType?: EnumDifyBotTypeWithAggregatesFilter<"Dify"> | $Enums.DifyBotType
    apiUrl?: StringNullableWithAggregatesFilter<"Dify"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"Dify"> | string | null
    expire?: IntNullableWithAggregatesFilter<"Dify"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"Dify"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"Dify"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"Dify"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"Dify"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"Dify"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"Dify"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"Dify"> | number | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"Dify">
    splitMessages?: BoolNullableWithAggregatesFilter<"Dify"> | boolean | null
    timePerChar?: IntNullableWithAggregatesFilter<"Dify"> | number | null
    triggerType?: EnumTriggerTypeNullableWithAggregatesFilter<"Dify"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableWithAggregatesFilter<"Dify"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableWithAggregatesFilter<"Dify"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Dify"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Dify"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Dify"> | string
  }

  export type DifySettingWhereInput = {
    AND?: DifySettingWhereInput | DifySettingWhereInput[]
    OR?: DifySettingWhereInput[]
    NOT?: DifySettingWhereInput | DifySettingWhereInput[]
    id?: StringFilter<"DifySetting"> | string
    expire?: IntNullableFilter<"DifySetting"> | number | null
    keywordFinish?: StringNullableFilter<"DifySetting"> | string | null
    delayMessage?: IntNullableFilter<"DifySetting"> | number | null
    unknownMessage?: StringNullableFilter<"DifySetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"DifySetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"DifySetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"DifySetting"> | boolean | null
    debounceTime?: IntNullableFilter<"DifySetting"> | number | null
    ignoreJids?: JsonNullableFilter<"DifySetting">
    splitMessages?: BoolNullableFilter<"DifySetting"> | boolean | null
    timePerChar?: IntNullableFilter<"DifySetting"> | number | null
    createdAt?: DateTimeNullableFilter<"DifySetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"DifySetting"> | Date | string
    difyIdFallback?: StringNullableFilter<"DifySetting"> | string | null
    instanceId?: StringFilter<"DifySetting"> | string
    Fallback?: XOR<DifyNullableScalarRelationFilter, DifyWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type DifySettingOrderByWithRelationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    difyIdFallback?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    Fallback?: DifyOrderByWithRelationInput
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: DifySettingOrderByRelevanceInput
  }

  export type DifySettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: DifySettingWhereInput | DifySettingWhereInput[]
    OR?: DifySettingWhereInput[]
    NOT?: DifySettingWhereInput | DifySettingWhereInput[]
    expire?: IntNullableFilter<"DifySetting"> | number | null
    keywordFinish?: StringNullableFilter<"DifySetting"> | string | null
    delayMessage?: IntNullableFilter<"DifySetting"> | number | null
    unknownMessage?: StringNullableFilter<"DifySetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"DifySetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"DifySetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"DifySetting"> | boolean | null
    debounceTime?: IntNullableFilter<"DifySetting"> | number | null
    ignoreJids?: JsonNullableFilter<"DifySetting">
    splitMessages?: BoolNullableFilter<"DifySetting"> | boolean | null
    timePerChar?: IntNullableFilter<"DifySetting"> | number | null
    createdAt?: DateTimeNullableFilter<"DifySetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"DifySetting"> | Date | string
    difyIdFallback?: StringNullableFilter<"DifySetting"> | string | null
    Fallback?: XOR<DifyNullableScalarRelationFilter, DifyWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type DifySettingOrderByWithAggregationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    difyIdFallback?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    _count?: DifySettingCountOrderByAggregateInput
    _avg?: DifySettingAvgOrderByAggregateInput
    _max?: DifySettingMaxOrderByAggregateInput
    _min?: DifySettingMinOrderByAggregateInput
    _sum?: DifySettingSumOrderByAggregateInput
  }

  export type DifySettingScalarWhereWithAggregatesInput = {
    AND?: DifySettingScalarWhereWithAggregatesInput | DifySettingScalarWhereWithAggregatesInput[]
    OR?: DifySettingScalarWhereWithAggregatesInput[]
    NOT?: DifySettingScalarWhereWithAggregatesInput | DifySettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DifySetting"> | string
    expire?: IntNullableWithAggregatesFilter<"DifySetting"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"DifySetting"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"DifySetting"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"DifySetting"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"DifySetting"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"DifySetting"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"DifySetting"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"DifySetting"> | number | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"DifySetting">
    splitMessages?: BoolNullableWithAggregatesFilter<"DifySetting"> | boolean | null
    timePerChar?: IntNullableWithAggregatesFilter<"DifySetting"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"DifySetting"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"DifySetting"> | Date | string
    difyIdFallback?: StringNullableWithAggregatesFilter<"DifySetting"> | string | null
    instanceId?: StringWithAggregatesFilter<"DifySetting"> | string
  }

  export type EvolutionBotWhereInput = {
    AND?: EvolutionBotWhereInput | EvolutionBotWhereInput[]
    OR?: EvolutionBotWhereInput[]
    NOT?: EvolutionBotWhereInput | EvolutionBotWhereInput[]
    id?: StringFilter<"EvolutionBot"> | string
    enabled?: BoolFilter<"EvolutionBot"> | boolean
    description?: StringNullableFilter<"EvolutionBot"> | string | null
    apiUrl?: StringNullableFilter<"EvolutionBot"> | string | null
    apiKey?: StringNullableFilter<"EvolutionBot"> | string | null
    expire?: IntNullableFilter<"EvolutionBot"> | number | null
    keywordFinish?: StringNullableFilter<"EvolutionBot"> | string | null
    delayMessage?: IntNullableFilter<"EvolutionBot"> | number | null
    unknownMessage?: StringNullableFilter<"EvolutionBot"> | string | null
    listeningFromMe?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    keepOpen?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    debounceTime?: IntNullableFilter<"EvolutionBot"> | number | null
    ignoreJids?: JsonNullableFilter<"EvolutionBot">
    splitMessages?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    timePerChar?: IntNullableFilter<"EvolutionBot"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"EvolutionBot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"EvolutionBot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"EvolutionBot"> | string | null
    createdAt?: DateTimeNullableFilter<"EvolutionBot"> | Date | string | null
    updatedAt?: DateTimeFilter<"EvolutionBot"> | Date | string
    instanceId?: StringFilter<"EvolutionBot"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    EvolutionBotSetting?: EvolutionBotSettingListRelationFilter
  }

  export type EvolutionBotOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    apiUrl?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    EvolutionBotSetting?: EvolutionBotSettingOrderByRelationAggregateInput
    _relevance?: EvolutionBotOrderByRelevanceInput
  }

  export type EvolutionBotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvolutionBotWhereInput | EvolutionBotWhereInput[]
    OR?: EvolutionBotWhereInput[]
    NOT?: EvolutionBotWhereInput | EvolutionBotWhereInput[]
    enabled?: BoolFilter<"EvolutionBot"> | boolean
    description?: StringNullableFilter<"EvolutionBot"> | string | null
    apiUrl?: StringNullableFilter<"EvolutionBot"> | string | null
    apiKey?: StringNullableFilter<"EvolutionBot"> | string | null
    expire?: IntNullableFilter<"EvolutionBot"> | number | null
    keywordFinish?: StringNullableFilter<"EvolutionBot"> | string | null
    delayMessage?: IntNullableFilter<"EvolutionBot"> | number | null
    unknownMessage?: StringNullableFilter<"EvolutionBot"> | string | null
    listeningFromMe?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    keepOpen?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    debounceTime?: IntNullableFilter<"EvolutionBot"> | number | null
    ignoreJids?: JsonNullableFilter<"EvolutionBot">
    splitMessages?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    timePerChar?: IntNullableFilter<"EvolutionBot"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"EvolutionBot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"EvolutionBot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"EvolutionBot"> | string | null
    createdAt?: DateTimeNullableFilter<"EvolutionBot"> | Date | string | null
    updatedAt?: DateTimeFilter<"EvolutionBot"> | Date | string
    instanceId?: StringFilter<"EvolutionBot"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    EvolutionBotSetting?: EvolutionBotSettingListRelationFilter
  }, "id">

  export type EvolutionBotOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    apiUrl?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: EvolutionBotCountOrderByAggregateInput
    _avg?: EvolutionBotAvgOrderByAggregateInput
    _max?: EvolutionBotMaxOrderByAggregateInput
    _min?: EvolutionBotMinOrderByAggregateInput
    _sum?: EvolutionBotSumOrderByAggregateInput
  }

  export type EvolutionBotScalarWhereWithAggregatesInput = {
    AND?: EvolutionBotScalarWhereWithAggregatesInput | EvolutionBotScalarWhereWithAggregatesInput[]
    OR?: EvolutionBotScalarWhereWithAggregatesInput[]
    NOT?: EvolutionBotScalarWhereWithAggregatesInput | EvolutionBotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvolutionBot"> | string
    enabled?: BoolWithAggregatesFilter<"EvolutionBot"> | boolean
    description?: StringNullableWithAggregatesFilter<"EvolutionBot"> | string | null
    apiUrl?: StringNullableWithAggregatesFilter<"EvolutionBot"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"EvolutionBot"> | string | null
    expire?: IntNullableWithAggregatesFilter<"EvolutionBot"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"EvolutionBot"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"EvolutionBot"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"EvolutionBot"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"EvolutionBot"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"EvolutionBot"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"EvolutionBot"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"EvolutionBot"> | number | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"EvolutionBot">
    splitMessages?: BoolNullableWithAggregatesFilter<"EvolutionBot"> | boolean | null
    timePerChar?: IntNullableWithAggregatesFilter<"EvolutionBot"> | number | null
    triggerType?: EnumTriggerTypeNullableWithAggregatesFilter<"EvolutionBot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableWithAggregatesFilter<"EvolutionBot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableWithAggregatesFilter<"EvolutionBot"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"EvolutionBot"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"EvolutionBot"> | Date | string
    instanceId?: StringWithAggregatesFilter<"EvolutionBot"> | string
  }

  export type EvolutionBotSettingWhereInput = {
    AND?: EvolutionBotSettingWhereInput | EvolutionBotSettingWhereInput[]
    OR?: EvolutionBotSettingWhereInput[]
    NOT?: EvolutionBotSettingWhereInput | EvolutionBotSettingWhereInput[]
    id?: StringFilter<"EvolutionBotSetting"> | string
    expire?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    keywordFinish?: StringNullableFilter<"EvolutionBotSetting"> | string | null
    delayMessage?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    unknownMessage?: StringNullableFilter<"EvolutionBotSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    ignoreJids?: JsonNullableFilter<"EvolutionBotSetting">
    splitMessages?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    timePerChar?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    createdAt?: DateTimeNullableFilter<"EvolutionBotSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"EvolutionBotSetting"> | Date | string
    botIdFallback?: StringNullableFilter<"EvolutionBotSetting"> | string | null
    instanceId?: StringFilter<"EvolutionBotSetting"> | string
    Fallback?: XOR<EvolutionBotNullableScalarRelationFilter, EvolutionBotWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type EvolutionBotSettingOrderByWithRelationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    botIdFallback?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    Fallback?: EvolutionBotOrderByWithRelationInput
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: EvolutionBotSettingOrderByRelevanceInput
  }

  export type EvolutionBotSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: EvolutionBotSettingWhereInput | EvolutionBotSettingWhereInput[]
    OR?: EvolutionBotSettingWhereInput[]
    NOT?: EvolutionBotSettingWhereInput | EvolutionBotSettingWhereInput[]
    expire?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    keywordFinish?: StringNullableFilter<"EvolutionBotSetting"> | string | null
    delayMessage?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    unknownMessage?: StringNullableFilter<"EvolutionBotSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    ignoreJids?: JsonNullableFilter<"EvolutionBotSetting">
    splitMessages?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    timePerChar?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    createdAt?: DateTimeNullableFilter<"EvolutionBotSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"EvolutionBotSetting"> | Date | string
    botIdFallback?: StringNullableFilter<"EvolutionBotSetting"> | string | null
    Fallback?: XOR<EvolutionBotNullableScalarRelationFilter, EvolutionBotWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type EvolutionBotSettingOrderByWithAggregationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    botIdFallback?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    _count?: EvolutionBotSettingCountOrderByAggregateInput
    _avg?: EvolutionBotSettingAvgOrderByAggregateInput
    _max?: EvolutionBotSettingMaxOrderByAggregateInput
    _min?: EvolutionBotSettingMinOrderByAggregateInput
    _sum?: EvolutionBotSettingSumOrderByAggregateInput
  }

  export type EvolutionBotSettingScalarWhereWithAggregatesInput = {
    AND?: EvolutionBotSettingScalarWhereWithAggregatesInput | EvolutionBotSettingScalarWhereWithAggregatesInput[]
    OR?: EvolutionBotSettingScalarWhereWithAggregatesInput[]
    NOT?: EvolutionBotSettingScalarWhereWithAggregatesInput | EvolutionBotSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvolutionBotSetting"> | string
    expire?: IntNullableWithAggregatesFilter<"EvolutionBotSetting"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"EvolutionBotSetting"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"EvolutionBotSetting"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"EvolutionBotSetting"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"EvolutionBotSetting"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"EvolutionBotSetting"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"EvolutionBotSetting"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"EvolutionBotSetting"> | number | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"EvolutionBotSetting">
    splitMessages?: BoolNullableWithAggregatesFilter<"EvolutionBotSetting"> | boolean | null
    timePerChar?: IntNullableWithAggregatesFilter<"EvolutionBotSetting"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"EvolutionBotSetting"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"EvolutionBotSetting"> | Date | string
    botIdFallback?: StringNullableWithAggregatesFilter<"EvolutionBotSetting"> | string | null
    instanceId?: StringWithAggregatesFilter<"EvolutionBotSetting"> | string
  }

  export type FlowiseWhereInput = {
    AND?: FlowiseWhereInput | FlowiseWhereInput[]
    OR?: FlowiseWhereInput[]
    NOT?: FlowiseWhereInput | FlowiseWhereInput[]
    id?: StringFilter<"Flowise"> | string
    enabled?: BoolFilter<"Flowise"> | boolean
    description?: StringNullableFilter<"Flowise"> | string | null
    apiUrl?: StringNullableFilter<"Flowise"> | string | null
    apiKey?: StringNullableFilter<"Flowise"> | string | null
    expire?: IntNullableFilter<"Flowise"> | number | null
    keywordFinish?: StringNullableFilter<"Flowise"> | string | null
    delayMessage?: IntNullableFilter<"Flowise"> | number | null
    unknownMessage?: StringNullableFilter<"Flowise"> | string | null
    listeningFromMe?: BoolNullableFilter<"Flowise"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"Flowise"> | boolean | null
    keepOpen?: BoolNullableFilter<"Flowise"> | boolean | null
    debounceTime?: IntNullableFilter<"Flowise"> | number | null
    ignoreJids?: JsonNullableFilter<"Flowise">
    splitMessages?: BoolNullableFilter<"Flowise"> | boolean | null
    timePerChar?: IntNullableFilter<"Flowise"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"Flowise"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"Flowise"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"Flowise"> | string | null
    createdAt?: DateTimeNullableFilter<"Flowise"> | Date | string | null
    updatedAt?: DateTimeFilter<"Flowise"> | Date | string
    instanceId?: StringFilter<"Flowise"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    FlowiseSetting?: FlowiseSettingListRelationFilter
  }

  export type FlowiseOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    apiUrl?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    Instance?: InstanceOrderByWithRelationInput
    FlowiseSetting?: FlowiseSettingOrderByRelationAggregateInput
    _relevance?: FlowiseOrderByRelevanceInput
  }

  export type FlowiseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlowiseWhereInput | FlowiseWhereInput[]
    OR?: FlowiseWhereInput[]
    NOT?: FlowiseWhereInput | FlowiseWhereInput[]
    enabled?: BoolFilter<"Flowise"> | boolean
    description?: StringNullableFilter<"Flowise"> | string | null
    apiUrl?: StringNullableFilter<"Flowise"> | string | null
    apiKey?: StringNullableFilter<"Flowise"> | string | null
    expire?: IntNullableFilter<"Flowise"> | number | null
    keywordFinish?: StringNullableFilter<"Flowise"> | string | null
    delayMessage?: IntNullableFilter<"Flowise"> | number | null
    unknownMessage?: StringNullableFilter<"Flowise"> | string | null
    listeningFromMe?: BoolNullableFilter<"Flowise"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"Flowise"> | boolean | null
    keepOpen?: BoolNullableFilter<"Flowise"> | boolean | null
    debounceTime?: IntNullableFilter<"Flowise"> | number | null
    ignoreJids?: JsonNullableFilter<"Flowise">
    splitMessages?: BoolNullableFilter<"Flowise"> | boolean | null
    timePerChar?: IntNullableFilter<"Flowise"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"Flowise"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"Flowise"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"Flowise"> | string | null
    createdAt?: DateTimeNullableFilter<"Flowise"> | Date | string | null
    updatedAt?: DateTimeFilter<"Flowise"> | Date | string
    instanceId?: StringFilter<"Flowise"> | string
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
    FlowiseSetting?: FlowiseSettingListRelationFilter
  }, "id">

  export type FlowiseOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrderInput | SortOrder
    apiUrl?: SortOrderInput | SortOrder
    apiKey?: SortOrderInput | SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    triggerType?: SortOrderInput | SortOrder
    triggerOperator?: SortOrderInput | SortOrder
    triggerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    _count?: FlowiseCountOrderByAggregateInput
    _avg?: FlowiseAvgOrderByAggregateInput
    _max?: FlowiseMaxOrderByAggregateInput
    _min?: FlowiseMinOrderByAggregateInput
    _sum?: FlowiseSumOrderByAggregateInput
  }

  export type FlowiseScalarWhereWithAggregatesInput = {
    AND?: FlowiseScalarWhereWithAggregatesInput | FlowiseScalarWhereWithAggregatesInput[]
    OR?: FlowiseScalarWhereWithAggregatesInput[]
    NOT?: FlowiseScalarWhereWithAggregatesInput | FlowiseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Flowise"> | string
    enabled?: BoolWithAggregatesFilter<"Flowise"> | boolean
    description?: StringNullableWithAggregatesFilter<"Flowise"> | string | null
    apiUrl?: StringNullableWithAggregatesFilter<"Flowise"> | string | null
    apiKey?: StringNullableWithAggregatesFilter<"Flowise"> | string | null
    expire?: IntNullableWithAggregatesFilter<"Flowise"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"Flowise"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"Flowise"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"Flowise"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"Flowise"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"Flowise"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"Flowise"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"Flowise"> | number | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"Flowise">
    splitMessages?: BoolNullableWithAggregatesFilter<"Flowise"> | boolean | null
    timePerChar?: IntNullableWithAggregatesFilter<"Flowise"> | number | null
    triggerType?: EnumTriggerTypeNullableWithAggregatesFilter<"Flowise"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableWithAggregatesFilter<"Flowise"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableWithAggregatesFilter<"Flowise"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Flowise"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Flowise"> | Date | string
    instanceId?: StringWithAggregatesFilter<"Flowise"> | string
  }

  export type FlowiseSettingWhereInput = {
    AND?: FlowiseSettingWhereInput | FlowiseSettingWhereInput[]
    OR?: FlowiseSettingWhereInput[]
    NOT?: FlowiseSettingWhereInput | FlowiseSettingWhereInput[]
    id?: StringFilter<"FlowiseSetting"> | string
    expire?: IntNullableFilter<"FlowiseSetting"> | number | null
    keywordFinish?: StringNullableFilter<"FlowiseSetting"> | string | null
    delayMessage?: IntNullableFilter<"FlowiseSetting"> | number | null
    unknownMessage?: StringNullableFilter<"FlowiseSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"FlowiseSetting"> | number | null
    ignoreJids?: JsonNullableFilter<"FlowiseSetting">
    splitMessages?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    timePerChar?: IntNullableFilter<"FlowiseSetting"> | number | null
    createdAt?: DateTimeNullableFilter<"FlowiseSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"FlowiseSetting"> | Date | string
    flowiseIdFallback?: StringNullableFilter<"FlowiseSetting"> | string | null
    instanceId?: StringFilter<"FlowiseSetting"> | string
    Fallback?: XOR<FlowiseNullableScalarRelationFilter, FlowiseWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }

  export type FlowiseSettingOrderByWithRelationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    flowiseIdFallback?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    Fallback?: FlowiseOrderByWithRelationInput
    Instance?: InstanceOrderByWithRelationInput
    _relevance?: FlowiseSettingOrderByRelevanceInput
  }

  export type FlowiseSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    instanceId?: string
    AND?: FlowiseSettingWhereInput | FlowiseSettingWhereInput[]
    OR?: FlowiseSettingWhereInput[]
    NOT?: FlowiseSettingWhereInput | FlowiseSettingWhereInput[]
    expire?: IntNullableFilter<"FlowiseSetting"> | number | null
    keywordFinish?: StringNullableFilter<"FlowiseSetting"> | string | null
    delayMessage?: IntNullableFilter<"FlowiseSetting"> | number | null
    unknownMessage?: StringNullableFilter<"FlowiseSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"FlowiseSetting"> | number | null
    ignoreJids?: JsonNullableFilter<"FlowiseSetting">
    splitMessages?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    timePerChar?: IntNullableFilter<"FlowiseSetting"> | number | null
    createdAt?: DateTimeNullableFilter<"FlowiseSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"FlowiseSetting"> | Date | string
    flowiseIdFallback?: StringNullableFilter<"FlowiseSetting"> | string | null
    Fallback?: XOR<FlowiseNullableScalarRelationFilter, FlowiseWhereInput> | null
    Instance?: XOR<InstanceScalarRelationFilter, InstanceWhereInput>
  }, "id" | "instanceId">

  export type FlowiseSettingOrderByWithAggregationInput = {
    id?: SortOrder
    expire?: SortOrderInput | SortOrder
    keywordFinish?: SortOrderInput | SortOrder
    delayMessage?: SortOrderInput | SortOrder
    unknownMessage?: SortOrderInput | SortOrder
    listeningFromMe?: SortOrderInput | SortOrder
    stopBotFromMe?: SortOrderInput | SortOrder
    keepOpen?: SortOrderInput | SortOrder
    debounceTime?: SortOrderInput | SortOrder
    ignoreJids?: SortOrderInput | SortOrder
    splitMessages?: SortOrderInput | SortOrder
    timePerChar?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    flowiseIdFallback?: SortOrderInput | SortOrder
    instanceId?: SortOrder
    _count?: FlowiseSettingCountOrderByAggregateInput
    _avg?: FlowiseSettingAvgOrderByAggregateInput
    _max?: FlowiseSettingMaxOrderByAggregateInput
    _min?: FlowiseSettingMinOrderByAggregateInput
    _sum?: FlowiseSettingSumOrderByAggregateInput
  }

  export type FlowiseSettingScalarWhereWithAggregatesInput = {
    AND?: FlowiseSettingScalarWhereWithAggregatesInput | FlowiseSettingScalarWhereWithAggregatesInput[]
    OR?: FlowiseSettingScalarWhereWithAggregatesInput[]
    NOT?: FlowiseSettingScalarWhereWithAggregatesInput | FlowiseSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlowiseSetting"> | string
    expire?: IntNullableWithAggregatesFilter<"FlowiseSetting"> | number | null
    keywordFinish?: StringNullableWithAggregatesFilter<"FlowiseSetting"> | string | null
    delayMessage?: IntNullableWithAggregatesFilter<"FlowiseSetting"> | number | null
    unknownMessage?: StringNullableWithAggregatesFilter<"FlowiseSetting"> | string | null
    listeningFromMe?: BoolNullableWithAggregatesFilter<"FlowiseSetting"> | boolean | null
    stopBotFromMe?: BoolNullableWithAggregatesFilter<"FlowiseSetting"> | boolean | null
    keepOpen?: BoolNullableWithAggregatesFilter<"FlowiseSetting"> | boolean | null
    debounceTime?: IntNullableWithAggregatesFilter<"FlowiseSetting"> | number | null
    ignoreJids?: JsonNullableWithAggregatesFilter<"FlowiseSetting">
    splitMessages?: BoolNullableWithAggregatesFilter<"FlowiseSetting"> | boolean | null
    timePerChar?: IntNullableWithAggregatesFilter<"FlowiseSetting"> | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"FlowiseSetting"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"FlowiseSetting"> | Date | string
    flowiseIdFallback?: StringNullableWithAggregatesFilter<"FlowiseSetting"> | string | null
    instanceId?: StringWithAggregatesFilter<"FlowiseSetting"> | string
  }

  export type IsOnWhatsappWhereInput = {
    AND?: IsOnWhatsappWhereInput | IsOnWhatsappWhereInput[]
    OR?: IsOnWhatsappWhereInput[]
    NOT?: IsOnWhatsappWhereInput | IsOnWhatsappWhereInput[]
    id?: StringFilter<"IsOnWhatsapp"> | string
    remoteJid?: StringFilter<"IsOnWhatsapp"> | string
    jidOptions?: StringFilter<"IsOnWhatsapp"> | string
    createdAt?: DateTimeFilter<"IsOnWhatsapp"> | Date | string
    updatedAt?: DateTimeFilter<"IsOnWhatsapp"> | Date | string
  }

  export type IsOnWhatsappOrderByWithRelationInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    jidOptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: IsOnWhatsappOrderByRelevanceInput
  }

  export type IsOnWhatsappWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    remoteJid?: string
    AND?: IsOnWhatsappWhereInput | IsOnWhatsappWhereInput[]
    OR?: IsOnWhatsappWhereInput[]
    NOT?: IsOnWhatsappWhereInput | IsOnWhatsappWhereInput[]
    jidOptions?: StringFilter<"IsOnWhatsapp"> | string
    createdAt?: DateTimeFilter<"IsOnWhatsapp"> | Date | string
    updatedAt?: DateTimeFilter<"IsOnWhatsapp"> | Date | string
  }, "id" | "remoteJid">

  export type IsOnWhatsappOrderByWithAggregationInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    jidOptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IsOnWhatsappCountOrderByAggregateInput
    _max?: IsOnWhatsappMaxOrderByAggregateInput
    _min?: IsOnWhatsappMinOrderByAggregateInput
  }

  export type IsOnWhatsappScalarWhereWithAggregatesInput = {
    AND?: IsOnWhatsappScalarWhereWithAggregatesInput | IsOnWhatsappScalarWhereWithAggregatesInput[]
    OR?: IsOnWhatsappScalarWhereWithAggregatesInput[]
    NOT?: IsOnWhatsappScalarWhereWithAggregatesInput | IsOnWhatsappScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IsOnWhatsapp"> | string
    remoteJid?: StringWithAggregatesFilter<"IsOnWhatsapp"> | string
    jidOptions?: StringWithAggregatesFilter<"IsOnWhatsapp"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IsOnWhatsapp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IsOnWhatsapp"> | Date | string
  }

  export type InstanceCreateInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateManyInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type InstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    creds?: string | null
    createdAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionId: string
    creds?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creds?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    creds?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionId: string
    creds?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creds?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    creds?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    remoteJid: string
    name?: string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    unreadMessages?: number
    Instance: InstanceCreateNestedOneWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    remoteJid: string
    name?: string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instanceId: string
    unreadMessages?: number
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadMessages?: IntFieldUpdateOperationsInput | number
    Instance?: InstanceUpdateOneRequiredWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    unreadMessages?: IntFieldUpdateOperationsInput | number
  }

  export type ChatCreateManyInput = {
    id?: string
    remoteJid: string
    name?: string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instanceId: string
    unreadMessages?: number
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadMessages?: IntFieldUpdateOperationsInput | number
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    unreadMessages?: IntFieldUpdateOperationsInput | number
  }

  export type ContactCreateInput = {
    id?: string
    remoteJid: string
    pushName?: string | null
    profilePicUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Instance: InstanceCreateNestedOneWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    remoteJid: string
    pushName?: string | null
    profilePicUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instanceId: string
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Instance?: InstanceUpdateOneRequiredWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateManyInput = {
    id?: string
    remoteJid: string
    pushName?: string | null
    profilePicUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    instanceId: string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    Instance: InstanceCreateNestedOneWithoutMessageInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutMessageInput
    Media?: MediaCreateNestedOneWithoutMessageInput
    session?: IntegrationSessionCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    instanceId: string
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    sessionId?: string | null
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutMessageInput
    Media?: MediaUncheckedCreateNestedOneWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    Instance?: InstanceUpdateOneRequiredWithoutMessageNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutMessageNestedInput
    Media?: MediaUpdateOneWithoutMessageNestedInput
    session?: IntegrationSessionUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    instanceId?: StringFieldUpdateOperationsInput | string
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutMessageNestedInput
    Media?: MediaUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    instanceId: string
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    sessionId?: string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    instanceId?: StringFieldUpdateOperationsInput | string
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateCreateInput = {
    id?: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant?: string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status: string
    Message: MessageCreateNestedOneWithoutMessageUpdateInput
    Instance: InstanceCreateNestedOneWithoutMessageUpdateInput
  }

  export type MessageUpdateUncheckedCreateInput = {
    id?: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant?: string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status: string
    messageId: string
    instanceId: string
  }

  export type MessageUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    Message?: MessageUpdateOneRequiredWithoutMessageUpdateNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutMessageUpdateNestedInput
  }

  export type MessageUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateCreateManyInput = {
    id?: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant?: string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status: string
    messageId: string
    instanceId: string
  }

  export type MessageUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookCreateInput = {
    id?: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: boolean | null
    webhookBase64?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutWebhookInput
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: boolean | null
    webhookBase64?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    webhookBase64?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutWebhookNestedInput
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    webhookBase64?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type WebhookCreateManyInput = {
    id?: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: boolean | null
    webhookBase64?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    webhookBase64?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    webhookBase64?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatwootCreateInput = {
    id?: string
    enabled?: boolean | null
    accountId?: string | null
    token?: string | null
    url?: string | null
    nameInbox?: string | null
    signMsg?: boolean | null
    signDelimiter?: string | null
    number?: string | null
    reopenConversation?: boolean | null
    conversationPending?: boolean | null
    mergeBrazilContacts?: boolean | null
    importContacts?: boolean | null
    importMessages?: boolean | null
    daysLimitImportMessages?: number | null
    organization?: string | null
    logo?: string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutChatwootInput
  }

  export type ChatwootUncheckedCreateInput = {
    id?: string
    enabled?: boolean | null
    accountId?: string | null
    token?: string | null
    url?: string | null
    nameInbox?: string | null
    signMsg?: boolean | null
    signDelimiter?: string | null
    number?: string | null
    reopenConversation?: boolean | null
    conversationPending?: boolean | null
    mergeBrazilContacts?: boolean | null
    importContacts?: boolean | null
    importMessages?: boolean | null
    daysLimitImportMessages?: number | null
    organization?: string | null
    logo?: string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type ChatwootUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    nameInbox?: NullableStringFieldUpdateOperationsInput | string | null
    signMsg?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signDelimiter?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    reopenConversation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversationPending?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mergeBrazilContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysLimitImportMessages?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutChatwootNestedInput
  }

  export type ChatwootUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    nameInbox?: NullableStringFieldUpdateOperationsInput | string | null
    signMsg?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signDelimiter?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    reopenConversation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversationPending?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mergeBrazilContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysLimitImportMessages?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatwootCreateManyInput = {
    id?: string
    enabled?: boolean | null
    accountId?: string | null
    token?: string | null
    url?: string | null
    nameInbox?: string | null
    signMsg?: boolean | null
    signDelimiter?: string | null
    number?: string | null
    reopenConversation?: boolean | null
    conversationPending?: boolean | null
    mergeBrazilContacts?: boolean | null
    importContacts?: boolean | null
    importMessages?: boolean | null
    daysLimitImportMessages?: number | null
    organization?: string | null
    logo?: string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type ChatwootUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    nameInbox?: NullableStringFieldUpdateOperationsInput | string | null
    signMsg?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signDelimiter?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    reopenConversation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversationPending?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mergeBrazilContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysLimitImportMessages?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatwootUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    nameInbox?: NullableStringFieldUpdateOperationsInput | string | null
    signMsg?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signDelimiter?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    reopenConversation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversationPending?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mergeBrazilContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysLimitImportMessages?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type LabelCreateInput = {
    id?: string
    labelId?: string | null
    name: string
    color: string
    predefinedId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutLabelInput
  }

  export type LabelUncheckedCreateInput = {
    id?: string
    labelId?: string | null
    name: string
    color: string
    predefinedId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type LabelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    predefinedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutLabelNestedInput
  }

  export type LabelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    predefinedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type LabelCreateManyInput = {
    id?: string
    labelId?: string | null
    name: string
    color: string
    predefinedId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type LabelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    predefinedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    predefinedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyCreateInput = {
    id?: string
    enabled?: boolean
    host: string
    port: string
    protocol: string
    username: string
    password: string
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutProxyInput
  }

  export type ProxyUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    host: string
    port: string
    protocol: string
    username: string
    password: string
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type ProxyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    protocol?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutProxyNestedInput
  }

  export type ProxyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    protocol?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type ProxyCreateManyInput = {
    id?: string
    enabled?: boolean
    host: string
    port: string
    protocol: string
    username: string
    password: string
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type ProxyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    protocol?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    protocol?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type SettingCreateInput = {
    id?: string
    rejectCall?: boolean
    msgCall?: string | null
    groupsIgnore?: boolean
    alwaysOnline?: boolean
    readMessages?: boolean
    readStatus?: boolean
    syncFullHistory?: boolean
    wavoipToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutSettingInput
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    rejectCall?: boolean
    msgCall?: string | null
    groupsIgnore?: boolean
    alwaysOnline?: boolean
    readMessages?: boolean
    readStatus?: boolean
    syncFullHistory?: boolean
    wavoipToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rejectCall?: BoolFieldUpdateOperationsInput | boolean
    msgCall?: NullableStringFieldUpdateOperationsInput | string | null
    groupsIgnore?: BoolFieldUpdateOperationsInput | boolean
    alwaysOnline?: BoolFieldUpdateOperationsInput | boolean
    readMessages?: BoolFieldUpdateOperationsInput | boolean
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    syncFullHistory?: BoolFieldUpdateOperationsInput | boolean
    wavoipToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutSettingNestedInput
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rejectCall?: BoolFieldUpdateOperationsInput | boolean
    msgCall?: NullableStringFieldUpdateOperationsInput | string | null
    groupsIgnore?: BoolFieldUpdateOperationsInput | boolean
    alwaysOnline?: BoolFieldUpdateOperationsInput | boolean
    readMessages?: BoolFieldUpdateOperationsInput | boolean
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    syncFullHistory?: BoolFieldUpdateOperationsInput | boolean
    wavoipToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type SettingCreateManyInput = {
    id?: string
    rejectCall?: boolean
    msgCall?: string | null
    groupsIgnore?: boolean
    alwaysOnline?: boolean
    readMessages?: boolean
    readStatus?: boolean
    syncFullHistory?: boolean
    wavoipToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rejectCall?: BoolFieldUpdateOperationsInput | boolean
    msgCall?: NullableStringFieldUpdateOperationsInput | string | null
    groupsIgnore?: BoolFieldUpdateOperationsInput | boolean
    alwaysOnline?: BoolFieldUpdateOperationsInput | boolean
    readMessages?: BoolFieldUpdateOperationsInput | boolean
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    syncFullHistory?: BoolFieldUpdateOperationsInput | boolean
    wavoipToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rejectCall?: BoolFieldUpdateOperationsInput | boolean
    msgCall?: NullableStringFieldUpdateOperationsInput | string | null
    groupsIgnore?: BoolFieldUpdateOperationsInput | boolean
    alwaysOnline?: BoolFieldUpdateOperationsInput | boolean
    readMessages?: BoolFieldUpdateOperationsInput | boolean
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    syncFullHistory?: BoolFieldUpdateOperationsInput | boolean
    wavoipToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type RabbitmqCreateInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutRabbitmqInput
  }

  export type RabbitmqUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type RabbitmqUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutRabbitmqNestedInput
  }

  export type RabbitmqUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type RabbitmqCreateManyInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type RabbitmqUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RabbitmqUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type SqsCreateInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutSqsInput
  }

  export type SqsUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type SqsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutSqsNestedInput
  }

  export type SqsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type SqsCreateManyInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type SqsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SqsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type WebsocketCreateInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutWebsocketInput
  }

  export type WebsocketUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type WebsocketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutWebsocketNestedInput
  }

  export type WebsocketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type WebsocketCreateManyInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type WebsocketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsocketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type PusherCreateInput = {
    id?: string
    enabled?: boolean
    appId: string
    key: string
    secret: string
    cluster: string
    useTLS?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutPusherInput
  }

  export type PusherUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    appId: string
    key: string
    secret: string
    cluster: string
    useTLS?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type PusherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    cluster?: StringFieldUpdateOperationsInput | string
    useTLS?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutPusherNestedInput
  }

  export type PusherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    cluster?: StringFieldUpdateOperationsInput | string
    useTLS?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type PusherCreateManyInput = {
    id?: string
    enabled?: boolean
    appId: string
    key: string
    secret: string
    cluster: string
    useTLS?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type PusherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    cluster?: StringFieldUpdateOperationsInput | string
    useTLS?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PusherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    cluster?: StringFieldUpdateOperationsInput | string
    useTLS?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type TypebotCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    url: string
    typebot: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    Instance: InstanceCreateNestedOneWithoutTypebotInput
    TypebotSetting?: TypebotSettingCreateNestedManyWithoutFallbackInput
  }

  export type TypebotUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    url: string
    typebot: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    instanceId: string
    TypebotSetting?: TypebotSettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type TypebotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    typebot?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    Instance?: InstanceUpdateOneRequiredWithoutTypebotNestedInput
    TypebotSetting?: TypebotSettingUpdateManyWithoutFallbackNestedInput
  }

  export type TypebotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    typebot?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
    TypebotSetting?: TypebotSettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type TypebotCreateManyInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    url: string
    typebot: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    instanceId: string
  }

  export type TypebotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    typebot?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TypebotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    typebot?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type TypebotSettingCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Fallback?: TypebotCreateNestedOneWithoutTypebotSettingInput
    Instance: InstanceCreateNestedOneWithoutTypebotSettingInput
  }

  export type TypebotSettingUncheckedCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    typebotIdFallback?: string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type TypebotSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fallback?: TypebotUpdateOneWithoutTypebotSettingNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutTypebotSettingNestedInput
  }

  export type TypebotSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    typebotIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type TypebotSettingCreateManyInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    typebotIdFallback?: string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type TypebotSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypebotSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    typebotIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type IntegrationSessionCreateInput = {
    id?: string
    sessionId: string
    remoteJid: string
    pushName?: string | null
    status: $Enums.SessionStatus
    awaitUser?: boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: string | null
    Message?: MessageCreateNestedManyWithoutSessionInput
    Instance: InstanceCreateNestedOneWithoutIntegrationSessionsInput
  }

  export type IntegrationSessionUncheckedCreateInput = {
    id?: string
    sessionId: string
    remoteJid: string
    pushName?: string | null
    status: $Enums.SessionStatus
    awaitUser?: boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: string | null
    Message?: MessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type IntegrationSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    awaitUser?: BoolFieldUpdateOperationsInput | boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: MessageUpdateManyWithoutSessionNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutIntegrationSessionsNestedInput
  }

  export type IntegrationSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    awaitUser?: BoolFieldUpdateOperationsInput | boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: MessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type IntegrationSessionCreateManyInput = {
    id?: string
    sessionId: string
    remoteJid: string
    pushName?: string | null
    status: $Enums.SessionStatus
    awaitUser?: boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: string | null
  }

  export type IntegrationSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    awaitUser?: BoolFieldUpdateOperationsInput | boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntegrationSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    awaitUser?: BoolFieldUpdateOperationsInput | boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaCreateInput = {
    id?: string
    fileName: string
    type: string
    mimetype: string
    createdAt?: Date | string | null
    Message: MessageCreateNestedOneWithoutMediaInput
    Instance: InstanceCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    fileName: string
    type: string
    mimetype: string
    createdAt?: Date | string | null
    messageId: string
    instanceId: string
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Message?: MessageUpdateOneRequiredWithoutMediaNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateManyInput = {
    id?: string
    fileName: string
    type: string
    mimetype: string
    createdAt?: Date | string | null
    messageId: string
    instanceId: string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messageId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenaiCredsCreateInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutOpenaiCredsInput
    OpenaiAssistant?: OpenaiBotCreateNestedManyWithoutOpenaiCredsInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutOpenaiCredsInput
  }

  export type OpenaiCredsUncheckedCreateInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    OpenaiAssistant?: OpenaiBotUncheckedCreateNestedManyWithoutOpenaiCredsInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutOpenaiCredsInput
  }

  export type OpenaiCredsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutOpenaiCredsNestedInput
    OpenaiAssistant?: OpenaiBotUpdateManyWithoutOpenaiCredsNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutOpenaiCredsNestedInput
  }

  export type OpenaiCredsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    OpenaiAssistant?: OpenaiBotUncheckedUpdateManyWithoutOpenaiCredsNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutOpenaiCredsNestedInput
  }

  export type OpenaiCredsCreateManyInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type OpenaiCredsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenaiCredsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenaiBotCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    OpenaiCreds: OpenaiCredsCreateNestedOneWithoutOpenaiAssistantInput
    Instance: InstanceCreateNestedOneWithoutOpenaiBotInput
    OpenaiSetting?: OpenaiSettingCreateNestedManyWithoutFallbackInput
  }

  export type OpenaiBotUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
    instanceId: string
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type OpenaiBotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OpenaiCreds?: OpenaiCredsUpdateOneRequiredWithoutOpenaiAssistantNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutOpenaiBotNestedInput
    OpenaiSetting?: OpenaiSettingUpdateManyWithoutFallbackNestedInput
  }

  export type OpenaiBotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
    OpenaiSetting?: OpenaiSettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type OpenaiBotCreateManyInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
    instanceId: string
  }

  export type OpenaiBotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenaiBotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenaiSettingCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    OpenaiCreds?: OpenaiCredsCreateNestedOneWithoutOpenaiSettingInput
    Fallback?: OpenaiBotCreateNestedOneWithoutOpenaiSettingInput
    Instance: InstanceCreateNestedOneWithoutOpenaiSettingInput
  }

  export type OpenaiSettingUncheckedCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
    openaiIdFallback?: string | null
    instanceId: string
  }

  export type OpenaiSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OpenaiCreds?: OpenaiCredsUpdateOneWithoutOpenaiSettingNestedInput
    Fallback?: OpenaiBotUpdateOneWithoutOpenaiSettingNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutOpenaiSettingNestedInput
  }

  export type OpenaiSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
    openaiIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenaiSettingCreateManyInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
    openaiIdFallback?: string | null
    instanceId: string
  }

  export type OpenaiSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenaiSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
    openaiIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateCreateInput = {
    id?: string
    templateId: string
    name: string
    template: JsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutTemplateInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: string
    templateId: string
    name: string
    template: JsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type TemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateCreateManyInput = {
    id?: string
    templateId: string
    name: string
    template: JsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type TemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type DifyCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.DifyBotType
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutDifyInput
    DifySetting?: DifySettingCreateNestedManyWithoutFallbackInput
  }

  export type DifyUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.DifyBotType
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    DifySetting?: DifySettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type DifyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumDifyBotTypeFieldUpdateOperationsInput | $Enums.DifyBotType
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutDifyNestedInput
    DifySetting?: DifySettingUpdateManyWithoutFallbackNestedInput
  }

  export type DifyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumDifyBotTypeFieldUpdateOperationsInput | $Enums.DifyBotType
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    DifySetting?: DifySettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type DifyCreateManyInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.DifyBotType
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type DifyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumDifyBotTypeFieldUpdateOperationsInput | $Enums.DifyBotType
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DifyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumDifyBotTypeFieldUpdateOperationsInput | $Enums.DifyBotType
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type DifySettingCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Fallback?: DifyCreateNestedOneWithoutDifySettingInput
    Instance: InstanceCreateNestedOneWithoutDifySettingInput
  }

  export type DifySettingUncheckedCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    difyIdFallback?: string | null
    instanceId: string
  }

  export type DifySettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fallback?: DifyUpdateOneWithoutDifySettingNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutDifySettingNestedInput
  }

  export type DifySettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difyIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type DifySettingCreateManyInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    difyIdFallback?: string | null
    instanceId: string
  }

  export type DifySettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DifySettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difyIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type EvolutionBotCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutEvolutionBotInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedManyWithoutFallbackInput
  }

  export type EvolutionBotUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type EvolutionBotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutEvolutionBotNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateManyWithoutFallbackNestedInput
  }

  export type EvolutionBotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type EvolutionBotCreateManyInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type EvolutionBotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvolutionBotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type EvolutionBotSettingCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Fallback?: EvolutionBotCreateNestedOneWithoutEvolutionBotSettingInput
    Instance: InstanceCreateNestedOneWithoutEvolutionBotSettingInput
  }

  export type EvolutionBotSettingUncheckedCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    botIdFallback?: string | null
    instanceId: string
  }

  export type EvolutionBotSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fallback?: EvolutionBotUpdateOneWithoutEvolutionBotSettingNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutEvolutionBotSettingNestedInput
  }

  export type EvolutionBotSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    botIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type EvolutionBotSettingCreateManyInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    botIdFallback?: string | null
    instanceId: string
  }

  export type EvolutionBotSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvolutionBotSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    botIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type FlowiseCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutFlowiseInput
    FlowiseSetting?: FlowiseSettingCreateNestedManyWithoutFallbackInput
  }

  export type FlowiseUncheckedCreateInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type FlowiseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutFlowiseNestedInput
    FlowiseSetting?: FlowiseSettingUpdateManyWithoutFallbackNestedInput
  }

  export type FlowiseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    FlowiseSetting?: FlowiseSettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type FlowiseCreateManyInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type FlowiseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowiseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type FlowiseSettingCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Fallback?: FlowiseCreateNestedOneWithoutFlowiseSettingInput
    Instance: InstanceCreateNestedOneWithoutFlowiseSettingInput
  }

  export type FlowiseSettingUncheckedCreateInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    flowiseIdFallback?: string | null
    instanceId: string
  }

  export type FlowiseSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fallback?: FlowiseUpdateOneWithoutFlowiseSettingNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutFlowiseSettingNestedInput
  }

  export type FlowiseSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flowiseIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type FlowiseSettingCreateManyInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    flowiseIdFallback?: string | null
    instanceId: string
  }

  export type FlowiseSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowiseSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flowiseIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type IsOnWhatsappCreateInput = {
    id?: string
    remoteJid: string
    jidOptions: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IsOnWhatsappUncheckedCreateInput = {
    id?: string
    remoteJid: string
    jidOptions: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IsOnWhatsappUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    jidOptions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IsOnWhatsappUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    jidOptions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IsOnWhatsappCreateManyInput = {
    id?: string
    remoteJid: string
    jidOptions: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IsOnWhatsappUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    jidOptions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IsOnWhatsappUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    jidOptions?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumInstanceConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstanceConnectionStatus | EnumInstanceConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstanceConnectionStatus[]
    notIn?: $Enums.InstanceConnectionStatus[]
    not?: NestedEnumInstanceConnectionStatusFilter<$PrismaModel> | $Enums.InstanceConnectionStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type WebhookNullableScalarRelationFilter = {
    is?: WebhookWhereInput | null
    isNot?: WebhookWhereInput | null
  }

  export type ChatwootNullableScalarRelationFilter = {
    is?: ChatwootWhereInput | null
    isNot?: ChatwootWhereInput | null
  }

  export type LabelListRelationFilter = {
    every?: LabelWhereInput
    some?: LabelWhereInput
    none?: LabelWhereInput
  }

  export type ProxyNullableScalarRelationFilter = {
    is?: ProxyWhereInput | null
    isNot?: ProxyWhereInput | null
  }

  export type SettingNullableScalarRelationFilter = {
    is?: SettingWhereInput | null
    isNot?: SettingWhereInput | null
  }

  export type RabbitmqNullableScalarRelationFilter = {
    is?: RabbitmqWhereInput | null
    isNot?: RabbitmqWhereInput | null
  }

  export type SqsNullableScalarRelationFilter = {
    is?: SqsWhereInput | null
    isNot?: SqsWhereInput | null
  }

  export type WebsocketNullableScalarRelationFilter = {
    is?: WebsocketWhereInput | null
    isNot?: WebsocketWhereInput | null
  }

  export type TypebotListRelationFilter = {
    every?: TypebotWhereInput
    some?: TypebotWhereInput
    none?: TypebotWhereInput
  }

  export type SessionNullableScalarRelationFilter = {
    is?: SessionWhereInput | null
    isNot?: SessionWhereInput | null
  }

  export type MessageUpdateListRelationFilter = {
    every?: MessageUpdateWhereInput
    some?: MessageUpdateWhereInput
    none?: MessageUpdateWhereInput
  }

  export type TypebotSettingNullableScalarRelationFilter = {
    is?: TypebotSettingWhereInput | null
    isNot?: TypebotSettingWhereInput | null
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type OpenaiCredsListRelationFilter = {
    every?: OpenaiCredsWhereInput
    some?: OpenaiCredsWhereInput
    none?: OpenaiCredsWhereInput
  }

  export type OpenaiBotListRelationFilter = {
    every?: OpenaiBotWhereInput
    some?: OpenaiBotWhereInput
    none?: OpenaiBotWhereInput
  }

  export type OpenaiSettingNullableScalarRelationFilter = {
    is?: OpenaiSettingWhereInput | null
    isNot?: OpenaiSettingWhereInput | null
  }

  export type TemplateListRelationFilter = {
    every?: TemplateWhereInput
    some?: TemplateWhereInput
    none?: TemplateWhereInput
  }

  export type DifyListRelationFilter = {
    every?: DifyWhereInput
    some?: DifyWhereInput
    none?: DifyWhereInput
  }

  export type DifySettingNullableScalarRelationFilter = {
    is?: DifySettingWhereInput | null
    isNot?: DifySettingWhereInput | null
  }

  export type IntegrationSessionListRelationFilter = {
    every?: IntegrationSessionWhereInput
    some?: IntegrationSessionWhereInput
    none?: IntegrationSessionWhereInput
  }

  export type EvolutionBotListRelationFilter = {
    every?: EvolutionBotWhereInput
    some?: EvolutionBotWhereInput
    none?: EvolutionBotWhereInput
  }

  export type EvolutionBotSettingNullableScalarRelationFilter = {
    is?: EvolutionBotSettingWhereInput | null
    isNot?: EvolutionBotSettingWhereInput | null
  }

  export type FlowiseListRelationFilter = {
    every?: FlowiseWhereInput
    some?: FlowiseWhereInput
    none?: FlowiseWhereInput
  }

  export type FlowiseSettingNullableScalarRelationFilter = {
    is?: FlowiseSettingWhereInput | null
    isNot?: FlowiseSettingWhereInput | null
  }

  export type PusherNullableScalarRelationFilter = {
    is?: PusherWhereInput | null
    isNot?: PusherWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TypebotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpenaiCredsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpenaiBotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DifyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvolutionBotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowiseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstanceOrderByRelevanceInput = {
    fields: InstanceOrderByRelevanceFieldEnum | InstanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InstanceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    connectionStatus?: SortOrder
    ownerJid?: SortOrder
    profileName?: SortOrder
    profilePicUrl?: SortOrder
    integration?: SortOrder
    number?: SortOrder
    businessId?: SortOrder
    token?: SortOrder
    clientName?: SortOrder
    disconnectionReasonCode?: SortOrder
    disconnectionObject?: SortOrder
    disconnectionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceAvgOrderByAggregateInput = {
    disconnectionReasonCode?: SortOrder
  }

  export type InstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    connectionStatus?: SortOrder
    ownerJid?: SortOrder
    profileName?: SortOrder
    profilePicUrl?: SortOrder
    integration?: SortOrder
    number?: SortOrder
    businessId?: SortOrder
    token?: SortOrder
    clientName?: SortOrder
    disconnectionReasonCode?: SortOrder
    disconnectionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    connectionStatus?: SortOrder
    ownerJid?: SortOrder
    profileName?: SortOrder
    profilePicUrl?: SortOrder
    integration?: SortOrder
    number?: SortOrder
    businessId?: SortOrder
    token?: SortOrder
    clientName?: SortOrder
    disconnectionReasonCode?: SortOrder
    disconnectionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstanceSumOrderByAggregateInput = {
    disconnectionReasonCode?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumInstanceConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstanceConnectionStatus | EnumInstanceConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstanceConnectionStatus[]
    notIn?: $Enums.InstanceConnectionStatus[]
    not?: NestedEnumInstanceConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstanceConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstanceConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumInstanceConnectionStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type InstanceScalarRelationFilter = {
    is?: InstanceWhereInput
    isNot?: InstanceWhereInput
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    creds?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    creds?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    creds?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ChatOrderByRelevanceInput = {
    fields: ChatOrderByRelevanceFieldEnum | ChatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChatInstanceIdRemoteJidCompoundUniqueInput = {
    instanceId: string
    remoteJid: string
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    name?: SortOrder
    labels?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    unreadMessages?: SortOrder
  }

  export type ChatAvgOrderByAggregateInput = {
    unreadMessages?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    unreadMessages?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    unreadMessages?: SortOrder
  }

  export type ChatSumOrderByAggregateInput = {
    unreadMessages?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ContactOrderByRelevanceInput = {
    fields: ContactOrderByRelevanceFieldEnum | ContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactRemoteJidInstanceIdCompoundUniqueInput = {
    remoteJid: string
    instanceId: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrder
    profilePicUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrder
    profilePicUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrder
    profilePicUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumDeviceMessageFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceMessage | EnumDeviceMessageFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceMessage[]
    notIn?: $Enums.DeviceMessage[]
    not?: NestedEnumDeviceMessageFilter<$PrismaModel> | $Enums.DeviceMessage
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type MediaNullableScalarRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type IntegrationSessionNullableScalarRelationFilter = {
    is?: IntegrationSessionWhereInput | null
    isNot?: IntegrationSessionWhereInput | null
  }

  export type MessageOrderByRelevanceInput = {
    fields: MessageOrderByRelevanceFieldEnum | MessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    pushName?: SortOrder
    participant?: SortOrder
    messageType?: SortOrder
    message?: SortOrder
    contextInfo?: SortOrder
    source?: SortOrder
    messageTimestamp?: SortOrder
    chatwootMessageId?: SortOrder
    chatwootInboxId?: SortOrder
    chatwootConversationId?: SortOrder
    chatwootContactInboxSourceId?: SortOrder
    chatwootIsRead?: SortOrder
    instanceId?: SortOrder
    typebotSessionId?: SortOrder
    webhookUrl?: SortOrder
    status?: SortOrder
    sessionId?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    messageTimestamp?: SortOrder
    chatwootMessageId?: SortOrder
    chatwootInboxId?: SortOrder
    chatwootConversationId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    pushName?: SortOrder
    participant?: SortOrder
    messageType?: SortOrder
    source?: SortOrder
    messageTimestamp?: SortOrder
    chatwootMessageId?: SortOrder
    chatwootInboxId?: SortOrder
    chatwootConversationId?: SortOrder
    chatwootContactInboxSourceId?: SortOrder
    chatwootIsRead?: SortOrder
    instanceId?: SortOrder
    typebotSessionId?: SortOrder
    webhookUrl?: SortOrder
    status?: SortOrder
    sessionId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    pushName?: SortOrder
    participant?: SortOrder
    messageType?: SortOrder
    source?: SortOrder
    messageTimestamp?: SortOrder
    chatwootMessageId?: SortOrder
    chatwootInboxId?: SortOrder
    chatwootConversationId?: SortOrder
    chatwootContactInboxSourceId?: SortOrder
    chatwootIsRead?: SortOrder
    instanceId?: SortOrder
    typebotSessionId?: SortOrder
    webhookUrl?: SortOrder
    status?: SortOrder
    sessionId?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    messageTimestamp?: SortOrder
    chatwootMessageId?: SortOrder
    chatwootInboxId?: SortOrder
    chatwootConversationId?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumDeviceMessageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceMessage | EnumDeviceMessageFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceMessage[]
    notIn?: $Enums.DeviceMessage[]
    not?: NestedEnumDeviceMessageWithAggregatesFilter<$PrismaModel> | $Enums.DeviceMessage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceMessageFilter<$PrismaModel>
    _max?: NestedEnumDeviceMessageFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageUpdateOrderByRelevanceInput = {
    fields: MessageUpdateOrderByRelevanceFieldEnum | MessageUpdateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    keyId?: SortOrder
    remoteJid?: SortOrder
    fromMe?: SortOrder
    participant?: SortOrder
    pollUpdates?: SortOrder
    status?: SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
  }

  export type MessageUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    keyId?: SortOrder
    remoteJid?: SortOrder
    fromMe?: SortOrder
    participant?: SortOrder
    status?: SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
  }

  export type MessageUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    keyId?: SortOrder
    remoteJid?: SortOrder
    fromMe?: SortOrder
    participant?: SortOrder
    status?: SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type WebhookOrderByRelevanceInput = {
    fields: WebhookOrderByRelevanceFieldEnum | WebhookOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    headers?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    webhookByEvents?: SortOrder
    webhookBase64?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    enabled?: SortOrder
    webhookByEvents?: SortOrder
    webhookBase64?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    enabled?: SortOrder
    webhookByEvents?: SortOrder
    webhookBase64?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type ChatwootOrderByRelevanceInput = {
    fields: ChatwootOrderByRelevanceFieldEnum | ChatwootOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChatwootCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    url?: SortOrder
    nameInbox?: SortOrder
    signMsg?: SortOrder
    signDelimiter?: SortOrder
    number?: SortOrder
    reopenConversation?: SortOrder
    conversationPending?: SortOrder
    mergeBrazilContacts?: SortOrder
    importContacts?: SortOrder
    importMessages?: SortOrder
    daysLimitImportMessages?: SortOrder
    organization?: SortOrder
    logo?: SortOrder
    ignoreJids?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type ChatwootAvgOrderByAggregateInput = {
    daysLimitImportMessages?: SortOrder
  }

  export type ChatwootMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    url?: SortOrder
    nameInbox?: SortOrder
    signMsg?: SortOrder
    signDelimiter?: SortOrder
    number?: SortOrder
    reopenConversation?: SortOrder
    conversationPending?: SortOrder
    mergeBrazilContacts?: SortOrder
    importContacts?: SortOrder
    importMessages?: SortOrder
    daysLimitImportMessages?: SortOrder
    organization?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type ChatwootMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    url?: SortOrder
    nameInbox?: SortOrder
    signMsg?: SortOrder
    signDelimiter?: SortOrder
    number?: SortOrder
    reopenConversation?: SortOrder
    conversationPending?: SortOrder
    mergeBrazilContacts?: SortOrder
    importContacts?: SortOrder
    importMessages?: SortOrder
    daysLimitImportMessages?: SortOrder
    organization?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type ChatwootSumOrderByAggregateInput = {
    daysLimitImportMessages?: SortOrder
  }

  export type LabelOrderByRelevanceInput = {
    fields: LabelOrderByRelevanceFieldEnum | LabelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LabelCountOrderByAggregateInput = {
    id?: SortOrder
    labelId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    predefinedId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type LabelMaxOrderByAggregateInput = {
    id?: SortOrder
    labelId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    predefinedId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type LabelMinOrderByAggregateInput = {
    id?: SortOrder
    labelId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    predefinedId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type ProxyOrderByRelevanceInput = {
    fields: ProxyOrderByRelevanceFieldEnum | ProxyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProxyCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    host?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type ProxyMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    host?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type ProxyMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    host?: SortOrder
    port?: SortOrder
    protocol?: SortOrder
    username?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type SettingOrderByRelevanceInput = {
    fields: SettingOrderByRelevanceFieldEnum | SettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    rejectCall?: SortOrder
    msgCall?: SortOrder
    groupsIgnore?: SortOrder
    alwaysOnline?: SortOrder
    readMessages?: SortOrder
    readStatus?: SortOrder
    syncFullHistory?: SortOrder
    wavoipToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    rejectCall?: SortOrder
    msgCall?: SortOrder
    groupsIgnore?: SortOrder
    alwaysOnline?: SortOrder
    readMessages?: SortOrder
    readStatus?: SortOrder
    syncFullHistory?: SortOrder
    wavoipToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    rejectCall?: SortOrder
    msgCall?: SortOrder
    groupsIgnore?: SortOrder
    alwaysOnline?: SortOrder
    readMessages?: SortOrder
    readStatus?: SortOrder
    syncFullHistory?: SortOrder
    wavoipToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type RabbitmqOrderByRelevanceInput = {
    fields: RabbitmqOrderByRelevanceFieldEnum | RabbitmqOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RabbitmqCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type RabbitmqMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type RabbitmqMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type SqsOrderByRelevanceInput = {
    fields: SqsOrderByRelevanceFieldEnum | SqsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SqsCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type SqsMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type SqsMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type WebsocketOrderByRelevanceInput = {
    fields: WebsocketOrderByRelevanceFieldEnum | WebsocketOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type WebsocketCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    events?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type WebsocketMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type WebsocketMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type PusherOrderByRelevanceInput = {
    fields: PusherOrderByRelevanceFieldEnum | PusherOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PusherCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    appId?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    cluster?: SortOrder
    useTLS?: SortOrder
    events?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type PusherMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    appId?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    cluster?: SortOrder
    useTLS?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type PusherMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    appId?: SortOrder
    key?: SortOrder
    secret?: SortOrder
    cluster?: SortOrder
    useTLS?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type EnumTriggerTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerType[] | null
    notIn?: $Enums.TriggerType[] | null
    not?: NestedEnumTriggerTypeNullableFilter<$PrismaModel> | $Enums.TriggerType | null
  }

  export type EnumTriggerOperatorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerOperator | EnumTriggerOperatorFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerOperator[] | null
    notIn?: $Enums.TriggerOperator[] | null
    not?: NestedEnumTriggerOperatorNullableFilter<$PrismaModel> | $Enums.TriggerOperator | null
  }

  export type TypebotSettingListRelationFilter = {
    every?: TypebotSettingWhereInput
    some?: TypebotSettingWhereInput
    none?: TypebotSettingWhereInput
  }

  export type TypebotSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TypebotOrderByRelevanceInput = {
    fields: TypebotOrderByRelevanceFieldEnum | TypebotOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TypebotCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    url?: SortOrder
    typebot?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ignoreJids?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    instanceId?: SortOrder
  }

  export type TypebotAvgOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
  }

  export type TypebotMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    url?: SortOrder
    typebot?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    instanceId?: SortOrder
  }

  export type TypebotMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    url?: SortOrder
    typebot?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    instanceId?: SortOrder
  }

  export type TypebotSumOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
  }

  export type EnumTriggerTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerType[] | null
    notIn?: $Enums.TriggerType[] | null
    not?: NestedEnumTriggerTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TriggerType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypeNullableFilter<$PrismaModel>
  }

  export type EnumTriggerOperatorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerOperator | EnumTriggerOperatorFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerOperator[] | null
    notIn?: $Enums.TriggerOperator[] | null
    not?: NestedEnumTriggerOperatorNullableWithAggregatesFilter<$PrismaModel> | $Enums.TriggerOperator | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTriggerOperatorNullableFilter<$PrismaModel>
    _max?: NestedEnumTriggerOperatorNullableFilter<$PrismaModel>
  }

  export type TypebotNullableScalarRelationFilter = {
    is?: TypebotWhereInput | null
    isNot?: TypebotWhereInput | null
  }

  export type TypebotSettingOrderByRelevanceInput = {
    fields: TypebotSettingOrderByRelevanceFieldEnum | TypebotSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TypebotSettingCountOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    typebotIdFallback?: SortOrder
    ignoreJids?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type TypebotSettingAvgOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
  }

  export type TypebotSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    typebotIdFallback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type TypebotSettingMinOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    typebotIdFallback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type TypebotSettingSumOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[]
    notIn?: $Enums.SessionStatus[]
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type IntegrationSessionOrderByRelevanceInput = {
    fields: IntegrationSessionOrderByRelevanceFieldEnum | IntegrationSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type IntegrationSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrder
    status?: SortOrder
    awaitUser?: SortOrder
    context?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    parameters?: SortOrder
    botId?: SortOrder
  }

  export type IntegrationSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrder
    status?: SortOrder
    awaitUser?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    botId?: SortOrder
  }

  export type IntegrationSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    remoteJid?: SortOrder
    pushName?: SortOrder
    status?: SortOrder
    awaitUser?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
    botId?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[]
    notIn?: $Enums.SessionStatus[]
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type MediaOrderByRelevanceInput = {
    fields: MediaOrderByRelevanceFieldEnum | MediaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    mimetype?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    mimetype?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    type?: SortOrder
    mimetype?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    instanceId?: SortOrder
  }

  export type OpenaiCredsOrderByRelevanceInput = {
    fields: OpenaiCredsOrderByRelevanceFieldEnum | OpenaiCredsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OpenaiCredsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type OpenaiCredsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type OpenaiCredsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    apiKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type EnumOpenaiBotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OpenaiBotType | EnumOpenaiBotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpenaiBotType[]
    notIn?: $Enums.OpenaiBotType[]
    not?: NestedEnumOpenaiBotTypeFilter<$PrismaModel> | $Enums.OpenaiBotType
  }

  export type OpenaiCredsScalarRelationFilter = {
    is?: OpenaiCredsWhereInput
    isNot?: OpenaiCredsWhereInput
  }

  export type OpenaiSettingListRelationFilter = {
    every?: OpenaiSettingWhereInput
    some?: OpenaiSettingWhereInput
    none?: OpenaiSettingWhereInput
  }

  export type OpenaiSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpenaiBotOrderByRelevanceInput = {
    fields: OpenaiBotOrderByRelevanceFieldEnum | OpenaiBotOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OpenaiBotCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    botType?: SortOrder
    assistantId?: SortOrder
    functionUrl?: SortOrder
    model?: SortOrder
    systemMessages?: SortOrder
    assistantMessages?: SortOrder
    userMessages?: SortOrder
    maxTokens?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    ignoreJids?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    instanceId?: SortOrder
  }

  export type OpenaiBotAvgOrderByAggregateInput = {
    maxTokens?: SortOrder
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type OpenaiBotMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    botType?: SortOrder
    assistantId?: SortOrder
    functionUrl?: SortOrder
    model?: SortOrder
    maxTokens?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    instanceId?: SortOrder
  }

  export type OpenaiBotMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    botType?: SortOrder
    assistantId?: SortOrder
    functionUrl?: SortOrder
    model?: SortOrder
    maxTokens?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    instanceId?: SortOrder
  }

  export type OpenaiBotSumOrderByAggregateInput = {
    maxTokens?: SortOrder
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type EnumOpenaiBotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpenaiBotType | EnumOpenaiBotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpenaiBotType[]
    notIn?: $Enums.OpenaiBotType[]
    not?: NestedEnumOpenaiBotTypeWithAggregatesFilter<$PrismaModel> | $Enums.OpenaiBotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpenaiBotTypeFilter<$PrismaModel>
    _max?: NestedEnumOpenaiBotTypeFilter<$PrismaModel>
  }

  export type OpenaiCredsNullableScalarRelationFilter = {
    is?: OpenaiCredsWhereInput | null
    isNot?: OpenaiCredsWhereInput | null
  }

  export type OpenaiBotNullableScalarRelationFilter = {
    is?: OpenaiBotWhereInput | null
    isNot?: OpenaiBotWhereInput | null
  }

  export type OpenaiSettingOrderByRelevanceInput = {
    fields: OpenaiSettingOrderByRelevanceFieldEnum | OpenaiSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OpenaiSettingCountOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    ignoreJids?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    speechToText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    openaiIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type OpenaiSettingAvgOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type OpenaiSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    speechToText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    openaiIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type OpenaiSettingMinOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    speechToText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    openaiCredsId?: SortOrder
    openaiIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type OpenaiSettingSumOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type TemplateOrderByRelevanceInput = {
    fields: TemplateOrderByRelevanceFieldEnum | TemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    name?: SortOrder
    template?: SortOrder
    webhookUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    name?: SortOrder
    webhookUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    name?: SortOrder
    webhookUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type EnumDifyBotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DifyBotType | EnumDifyBotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DifyBotType[]
    notIn?: $Enums.DifyBotType[]
    not?: NestedEnumDifyBotTypeFilter<$PrismaModel> | $Enums.DifyBotType
  }

  export type DifySettingListRelationFilter = {
    every?: DifySettingWhereInput
    some?: DifySettingWhereInput
    none?: DifySettingWhereInput
  }

  export type DifySettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DifyOrderByRelevanceInput = {
    fields: DifyOrderByRelevanceFieldEnum | DifyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DifyCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    botType?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    ignoreJids?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type DifyAvgOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type DifyMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    botType?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type DifyMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    botType?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type DifySumOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type EnumDifyBotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifyBotType | EnumDifyBotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DifyBotType[]
    notIn?: $Enums.DifyBotType[]
    not?: NestedEnumDifyBotTypeWithAggregatesFilter<$PrismaModel> | $Enums.DifyBotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifyBotTypeFilter<$PrismaModel>
    _max?: NestedEnumDifyBotTypeFilter<$PrismaModel>
  }

  export type DifyNullableScalarRelationFilter = {
    is?: DifyWhereInput | null
    isNot?: DifyWhereInput | null
  }

  export type DifySettingOrderByRelevanceInput = {
    fields: DifySettingOrderByRelevanceFieldEnum | DifySettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DifySettingCountOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    ignoreJids?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    difyIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type DifySettingAvgOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type DifySettingMaxOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    difyIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type DifySettingMinOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    difyIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type DifySettingSumOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type EvolutionBotSettingListRelationFilter = {
    every?: EvolutionBotSettingWhereInput
    some?: EvolutionBotSettingWhereInput
    none?: EvolutionBotSettingWhereInput
  }

  export type EvolutionBotSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvolutionBotOrderByRelevanceInput = {
    fields: EvolutionBotOrderByRelevanceFieldEnum | EvolutionBotOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EvolutionBotCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    ignoreJids?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type EvolutionBotAvgOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type EvolutionBotMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type EvolutionBotMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type EvolutionBotSumOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type EvolutionBotNullableScalarRelationFilter = {
    is?: EvolutionBotWhereInput | null
    isNot?: EvolutionBotWhereInput | null
  }

  export type EvolutionBotSettingOrderByRelevanceInput = {
    fields: EvolutionBotSettingOrderByRelevanceFieldEnum | EvolutionBotSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EvolutionBotSettingCountOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    ignoreJids?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    botIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type EvolutionBotSettingAvgOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type EvolutionBotSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    botIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type EvolutionBotSettingMinOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    botIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type EvolutionBotSettingSumOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type FlowiseSettingListRelationFilter = {
    every?: FlowiseSettingWhereInput
    some?: FlowiseSettingWhereInput
    none?: FlowiseSettingWhereInput
  }

  export type FlowiseSettingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlowiseOrderByRelevanceInput = {
    fields: FlowiseOrderByRelevanceFieldEnum | FlowiseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FlowiseCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    ignoreJids?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type FlowiseAvgOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type FlowiseMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type FlowiseMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    description?: SortOrder
    apiUrl?: SortOrder
    apiKey?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    triggerType?: SortOrder
    triggerOperator?: SortOrder
    triggerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instanceId?: SortOrder
  }

  export type FlowiseSumOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type FlowiseNullableScalarRelationFilter = {
    is?: FlowiseWhereInput | null
    isNot?: FlowiseWhereInput | null
  }

  export type FlowiseSettingOrderByRelevanceInput = {
    fields: FlowiseSettingOrderByRelevanceFieldEnum | FlowiseSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FlowiseSettingCountOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    ignoreJids?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    flowiseIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type FlowiseSettingAvgOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type FlowiseSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    flowiseIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type FlowiseSettingMinOrderByAggregateInput = {
    id?: SortOrder
    expire?: SortOrder
    keywordFinish?: SortOrder
    delayMessage?: SortOrder
    unknownMessage?: SortOrder
    listeningFromMe?: SortOrder
    stopBotFromMe?: SortOrder
    keepOpen?: SortOrder
    debounceTime?: SortOrder
    splitMessages?: SortOrder
    timePerChar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    flowiseIdFallback?: SortOrder
    instanceId?: SortOrder
  }

  export type FlowiseSettingSumOrderByAggregateInput = {
    expire?: SortOrder
    delayMessage?: SortOrder
    debounceTime?: SortOrder
    timePerChar?: SortOrder
  }

  export type IsOnWhatsappOrderByRelevanceInput = {
    fields: IsOnWhatsappOrderByRelevanceFieldEnum | IsOnWhatsappOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type IsOnWhatsappCountOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    jidOptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IsOnWhatsappMaxOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    jidOptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IsOnWhatsappMinOrderByAggregateInput = {
    id?: SortOrder
    remoteJid?: SortOrder
    jidOptions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ChatCreateWithoutInstanceInput, ChatUncheckedCreateWithoutInstanceInput> | ChatCreateWithoutInstanceInput[] | ChatUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutInstanceInput | ChatCreateOrConnectWithoutInstanceInput[]
    createMany?: ChatCreateManyInstanceInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ContactCreateWithoutInstanceInput, ContactUncheckedCreateWithoutInstanceInput> | ContactCreateWithoutInstanceInput[] | ContactUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutInstanceInput | ContactCreateOrConnectWithoutInstanceInput[]
    createMany?: ContactCreateManyInstanceInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MessageCreateWithoutInstanceInput, MessageUncheckedCreateWithoutInstanceInput> | MessageCreateWithoutInstanceInput[] | MessageUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutInstanceInput | MessageCreateOrConnectWithoutInstanceInput[]
    createMany?: MessageCreateManyInstanceInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type WebhookCreateNestedOneWithoutInstanceInput = {
    create?: XOR<WebhookCreateWithoutInstanceInput, WebhookUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutInstanceInput
    connect?: WebhookWhereUniqueInput
  }

  export type ChatwootCreateNestedOneWithoutInstanceInput = {
    create?: XOR<ChatwootCreateWithoutInstanceInput, ChatwootUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: ChatwootCreateOrConnectWithoutInstanceInput
    connect?: ChatwootWhereUniqueInput
  }

  export type LabelCreateNestedManyWithoutInstanceInput = {
    create?: XOR<LabelCreateWithoutInstanceInput, LabelUncheckedCreateWithoutInstanceInput> | LabelCreateWithoutInstanceInput[] | LabelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutInstanceInput | LabelCreateOrConnectWithoutInstanceInput[]
    createMany?: LabelCreateManyInstanceInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type ProxyCreateNestedOneWithoutInstanceInput = {
    create?: XOR<ProxyCreateWithoutInstanceInput, ProxyUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutInstanceInput
    connect?: ProxyWhereUniqueInput
  }

  export type SettingCreateNestedOneWithoutInstanceInput = {
    create?: XOR<SettingCreateWithoutInstanceInput, SettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SettingCreateOrConnectWithoutInstanceInput
    connect?: SettingWhereUniqueInput
  }

  export type RabbitmqCreateNestedOneWithoutInstanceInput = {
    create?: XOR<RabbitmqCreateWithoutInstanceInput, RabbitmqUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: RabbitmqCreateOrConnectWithoutInstanceInput
    connect?: RabbitmqWhereUniqueInput
  }

  export type SqsCreateNestedOneWithoutInstanceInput = {
    create?: XOR<SqsCreateWithoutInstanceInput, SqsUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SqsCreateOrConnectWithoutInstanceInput
    connect?: SqsWhereUniqueInput
  }

  export type WebsocketCreateNestedOneWithoutInstanceInput = {
    create?: XOR<WebsocketCreateWithoutInstanceInput, WebsocketUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WebsocketCreateOrConnectWithoutInstanceInput
    connect?: WebsocketWhereUniqueInput
  }

  export type TypebotCreateNestedManyWithoutInstanceInput = {
    create?: XOR<TypebotCreateWithoutInstanceInput, TypebotUncheckedCreateWithoutInstanceInput> | TypebotCreateWithoutInstanceInput[] | TypebotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TypebotCreateOrConnectWithoutInstanceInput | TypebotCreateOrConnectWithoutInstanceInput[]
    createMany?: TypebotCreateManyInstanceInputEnvelope
    connect?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
  }

  export type SessionCreateNestedOneWithoutInstanceInput = {
    create?: XOR<SessionCreateWithoutInstanceInput, SessionUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SessionCreateOrConnectWithoutInstanceInput
    connect?: SessionWhereUniqueInput
  }

  export type MessageUpdateCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MessageUpdateCreateWithoutInstanceInput, MessageUpdateUncheckedCreateWithoutInstanceInput> | MessageUpdateCreateWithoutInstanceInput[] | MessageUpdateUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MessageUpdateCreateOrConnectWithoutInstanceInput | MessageUpdateCreateOrConnectWithoutInstanceInput[]
    createMany?: MessageUpdateCreateManyInstanceInputEnvelope
    connect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
  }

  export type TypebotSettingCreateNestedOneWithoutInstanceInput = {
    create?: XOR<TypebotSettingCreateWithoutInstanceInput, TypebotSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: TypebotSettingCreateOrConnectWithoutInstanceInput
    connect?: TypebotSettingWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MediaCreateWithoutInstanceInput, MediaUncheckedCreateWithoutInstanceInput> | MediaCreateWithoutInstanceInput[] | MediaUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutInstanceInput | MediaCreateOrConnectWithoutInstanceInput[]
    createMany?: MediaCreateManyInstanceInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type OpenaiCredsCreateNestedManyWithoutInstanceInput = {
    create?: XOR<OpenaiCredsCreateWithoutInstanceInput, OpenaiCredsUncheckedCreateWithoutInstanceInput> | OpenaiCredsCreateWithoutInstanceInput[] | OpenaiCredsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: OpenaiCredsCreateOrConnectWithoutInstanceInput | OpenaiCredsCreateOrConnectWithoutInstanceInput[]
    createMany?: OpenaiCredsCreateManyInstanceInputEnvelope
    connect?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
  }

  export type OpenaiBotCreateNestedManyWithoutInstanceInput = {
    create?: XOR<OpenaiBotCreateWithoutInstanceInput, OpenaiBotUncheckedCreateWithoutInstanceInput> | OpenaiBotCreateWithoutInstanceInput[] | OpenaiBotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutInstanceInput | OpenaiBotCreateOrConnectWithoutInstanceInput[]
    createMany?: OpenaiBotCreateManyInstanceInputEnvelope
    connect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
  }

  export type OpenaiSettingCreateNestedOneWithoutInstanceInput = {
    create?: XOR<OpenaiSettingCreateWithoutInstanceInput, OpenaiSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutInstanceInput
    connect?: OpenaiSettingWhereUniqueInput
  }

  export type TemplateCreateNestedManyWithoutInstanceInput = {
    create?: XOR<TemplateCreateWithoutInstanceInput, TemplateUncheckedCreateWithoutInstanceInput> | TemplateCreateWithoutInstanceInput[] | TemplateUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutInstanceInput | TemplateCreateOrConnectWithoutInstanceInput[]
    createMany?: TemplateCreateManyInstanceInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type DifyCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DifyCreateWithoutInstanceInput, DifyUncheckedCreateWithoutInstanceInput> | DifyCreateWithoutInstanceInput[] | DifyUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DifyCreateOrConnectWithoutInstanceInput | DifyCreateOrConnectWithoutInstanceInput[]
    createMany?: DifyCreateManyInstanceInputEnvelope
    connect?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
  }

  export type DifySettingCreateNestedOneWithoutInstanceInput = {
    create?: XOR<DifySettingCreateWithoutInstanceInput, DifySettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: DifySettingCreateOrConnectWithoutInstanceInput
    connect?: DifySettingWhereUniqueInput
  }

  export type IntegrationSessionCreateNestedManyWithoutInstanceInput = {
    create?: XOR<IntegrationSessionCreateWithoutInstanceInput, IntegrationSessionUncheckedCreateWithoutInstanceInput> | IntegrationSessionCreateWithoutInstanceInput[] | IntegrationSessionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: IntegrationSessionCreateOrConnectWithoutInstanceInput | IntegrationSessionCreateOrConnectWithoutInstanceInput[]
    createMany?: IntegrationSessionCreateManyInstanceInputEnvelope
    connect?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
  }

  export type EvolutionBotCreateNestedManyWithoutInstanceInput = {
    create?: XOR<EvolutionBotCreateWithoutInstanceInput, EvolutionBotUncheckedCreateWithoutInstanceInput> | EvolutionBotCreateWithoutInstanceInput[] | EvolutionBotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: EvolutionBotCreateOrConnectWithoutInstanceInput | EvolutionBotCreateOrConnectWithoutInstanceInput[]
    createMany?: EvolutionBotCreateManyInstanceInputEnvelope
    connect?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
  }

  export type EvolutionBotSettingCreateNestedOneWithoutInstanceInput = {
    create?: XOR<EvolutionBotSettingCreateWithoutInstanceInput, EvolutionBotSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: EvolutionBotSettingCreateOrConnectWithoutInstanceInput
    connect?: EvolutionBotSettingWhereUniqueInput
  }

  export type FlowiseCreateNestedManyWithoutInstanceInput = {
    create?: XOR<FlowiseCreateWithoutInstanceInput, FlowiseUncheckedCreateWithoutInstanceInput> | FlowiseCreateWithoutInstanceInput[] | FlowiseUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: FlowiseCreateOrConnectWithoutInstanceInput | FlowiseCreateOrConnectWithoutInstanceInput[]
    createMany?: FlowiseCreateManyInstanceInputEnvelope
    connect?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
  }

  export type FlowiseSettingCreateNestedOneWithoutInstanceInput = {
    create?: XOR<FlowiseSettingCreateWithoutInstanceInput, FlowiseSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: FlowiseSettingCreateOrConnectWithoutInstanceInput
    connect?: FlowiseSettingWhereUniqueInput
  }

  export type PusherCreateNestedOneWithoutInstanceInput = {
    create?: XOR<PusherCreateWithoutInstanceInput, PusherUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: PusherCreateOrConnectWithoutInstanceInput
    connect?: PusherWhereUniqueInput
  }

  export type ChatUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ChatCreateWithoutInstanceInput, ChatUncheckedCreateWithoutInstanceInput> | ChatCreateWithoutInstanceInput[] | ChatUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutInstanceInput | ChatCreateOrConnectWithoutInstanceInput[]
    createMany?: ChatCreateManyInstanceInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<ContactCreateWithoutInstanceInput, ContactUncheckedCreateWithoutInstanceInput> | ContactCreateWithoutInstanceInput[] | ContactUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutInstanceInput | ContactCreateOrConnectWithoutInstanceInput[]
    createMany?: ContactCreateManyInstanceInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MessageCreateWithoutInstanceInput, MessageUncheckedCreateWithoutInstanceInput> | MessageCreateWithoutInstanceInput[] | MessageUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutInstanceInput | MessageCreateOrConnectWithoutInstanceInput[]
    createMany?: MessageCreateManyInstanceInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type WebhookUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<WebhookCreateWithoutInstanceInput, WebhookUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutInstanceInput
    connect?: WebhookWhereUniqueInput
  }

  export type ChatwootUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<ChatwootCreateWithoutInstanceInput, ChatwootUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: ChatwootCreateOrConnectWithoutInstanceInput
    connect?: ChatwootWhereUniqueInput
  }

  export type LabelUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<LabelCreateWithoutInstanceInput, LabelUncheckedCreateWithoutInstanceInput> | LabelCreateWithoutInstanceInput[] | LabelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutInstanceInput | LabelCreateOrConnectWithoutInstanceInput[]
    createMany?: LabelCreateManyInstanceInputEnvelope
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
  }

  export type ProxyUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<ProxyCreateWithoutInstanceInput, ProxyUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutInstanceInput
    connect?: ProxyWhereUniqueInput
  }

  export type SettingUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<SettingCreateWithoutInstanceInput, SettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SettingCreateOrConnectWithoutInstanceInput
    connect?: SettingWhereUniqueInput
  }

  export type RabbitmqUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<RabbitmqCreateWithoutInstanceInput, RabbitmqUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: RabbitmqCreateOrConnectWithoutInstanceInput
    connect?: RabbitmqWhereUniqueInput
  }

  export type SqsUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<SqsCreateWithoutInstanceInput, SqsUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SqsCreateOrConnectWithoutInstanceInput
    connect?: SqsWhereUniqueInput
  }

  export type WebsocketUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<WebsocketCreateWithoutInstanceInput, WebsocketUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WebsocketCreateOrConnectWithoutInstanceInput
    connect?: WebsocketWhereUniqueInput
  }

  export type TypebotUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<TypebotCreateWithoutInstanceInput, TypebotUncheckedCreateWithoutInstanceInput> | TypebotCreateWithoutInstanceInput[] | TypebotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TypebotCreateOrConnectWithoutInstanceInput | TypebotCreateOrConnectWithoutInstanceInput[]
    createMany?: TypebotCreateManyInstanceInputEnvelope
    connect?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<SessionCreateWithoutInstanceInput, SessionUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SessionCreateOrConnectWithoutInstanceInput
    connect?: SessionWhereUniqueInput
  }

  export type MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MessageUpdateCreateWithoutInstanceInput, MessageUpdateUncheckedCreateWithoutInstanceInput> | MessageUpdateCreateWithoutInstanceInput[] | MessageUpdateUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MessageUpdateCreateOrConnectWithoutInstanceInput | MessageUpdateCreateOrConnectWithoutInstanceInput[]
    createMany?: MessageUpdateCreateManyInstanceInputEnvelope
    connect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
  }

  export type TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<TypebotSettingCreateWithoutInstanceInput, TypebotSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: TypebotSettingCreateOrConnectWithoutInstanceInput
    connect?: TypebotSettingWhereUniqueInput
  }

  export type MediaUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<MediaCreateWithoutInstanceInput, MediaUncheckedCreateWithoutInstanceInput> | MediaCreateWithoutInstanceInput[] | MediaUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutInstanceInput | MediaCreateOrConnectWithoutInstanceInput[]
    createMany?: MediaCreateManyInstanceInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<OpenaiCredsCreateWithoutInstanceInput, OpenaiCredsUncheckedCreateWithoutInstanceInput> | OpenaiCredsCreateWithoutInstanceInput[] | OpenaiCredsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: OpenaiCredsCreateOrConnectWithoutInstanceInput | OpenaiCredsCreateOrConnectWithoutInstanceInput[]
    createMany?: OpenaiCredsCreateManyInstanceInputEnvelope
    connect?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
  }

  export type OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<OpenaiBotCreateWithoutInstanceInput, OpenaiBotUncheckedCreateWithoutInstanceInput> | OpenaiBotCreateWithoutInstanceInput[] | OpenaiBotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutInstanceInput | OpenaiBotCreateOrConnectWithoutInstanceInput[]
    createMany?: OpenaiBotCreateManyInstanceInputEnvelope
    connect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
  }

  export type OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<OpenaiSettingCreateWithoutInstanceInput, OpenaiSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutInstanceInput
    connect?: OpenaiSettingWhereUniqueInput
  }

  export type TemplateUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<TemplateCreateWithoutInstanceInput, TemplateUncheckedCreateWithoutInstanceInput> | TemplateCreateWithoutInstanceInput[] | TemplateUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutInstanceInput | TemplateCreateOrConnectWithoutInstanceInput[]
    createMany?: TemplateCreateManyInstanceInputEnvelope
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
  }

  export type DifyUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<DifyCreateWithoutInstanceInput, DifyUncheckedCreateWithoutInstanceInput> | DifyCreateWithoutInstanceInput[] | DifyUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DifyCreateOrConnectWithoutInstanceInput | DifyCreateOrConnectWithoutInstanceInput[]
    createMany?: DifyCreateManyInstanceInputEnvelope
    connect?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
  }

  export type DifySettingUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<DifySettingCreateWithoutInstanceInput, DifySettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: DifySettingCreateOrConnectWithoutInstanceInput
    connect?: DifySettingWhereUniqueInput
  }

  export type IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<IntegrationSessionCreateWithoutInstanceInput, IntegrationSessionUncheckedCreateWithoutInstanceInput> | IntegrationSessionCreateWithoutInstanceInput[] | IntegrationSessionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: IntegrationSessionCreateOrConnectWithoutInstanceInput | IntegrationSessionCreateOrConnectWithoutInstanceInput[]
    createMany?: IntegrationSessionCreateManyInstanceInputEnvelope
    connect?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
  }

  export type EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<EvolutionBotCreateWithoutInstanceInput, EvolutionBotUncheckedCreateWithoutInstanceInput> | EvolutionBotCreateWithoutInstanceInput[] | EvolutionBotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: EvolutionBotCreateOrConnectWithoutInstanceInput | EvolutionBotCreateOrConnectWithoutInstanceInput[]
    createMany?: EvolutionBotCreateManyInstanceInputEnvelope
    connect?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
  }

  export type EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<EvolutionBotSettingCreateWithoutInstanceInput, EvolutionBotSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: EvolutionBotSettingCreateOrConnectWithoutInstanceInput
    connect?: EvolutionBotSettingWhereUniqueInput
  }

  export type FlowiseUncheckedCreateNestedManyWithoutInstanceInput = {
    create?: XOR<FlowiseCreateWithoutInstanceInput, FlowiseUncheckedCreateWithoutInstanceInput> | FlowiseCreateWithoutInstanceInput[] | FlowiseUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: FlowiseCreateOrConnectWithoutInstanceInput | FlowiseCreateOrConnectWithoutInstanceInput[]
    createMany?: FlowiseCreateManyInstanceInputEnvelope
    connect?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
  }

  export type FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<FlowiseSettingCreateWithoutInstanceInput, FlowiseSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: FlowiseSettingCreateOrConnectWithoutInstanceInput
    connect?: FlowiseSettingWhereUniqueInput
  }

  export type PusherUncheckedCreateNestedOneWithoutInstanceInput = {
    create?: XOR<PusherCreateWithoutInstanceInput, PusherUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: PusherCreateOrConnectWithoutInstanceInput
    connect?: PusherWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumInstanceConnectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.InstanceConnectionStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ChatUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ChatCreateWithoutInstanceInput, ChatUncheckedCreateWithoutInstanceInput> | ChatCreateWithoutInstanceInput[] | ChatUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutInstanceInput | ChatCreateOrConnectWithoutInstanceInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutInstanceInput | ChatUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ChatCreateManyInstanceInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutInstanceInput | ChatUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutInstanceInput | ChatUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ContactCreateWithoutInstanceInput, ContactUncheckedCreateWithoutInstanceInput> | ContactCreateWithoutInstanceInput[] | ContactUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutInstanceInput | ContactCreateOrConnectWithoutInstanceInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutInstanceInput | ContactUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ContactCreateManyInstanceInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutInstanceInput | ContactUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutInstanceInput | ContactUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MessageCreateWithoutInstanceInput, MessageUncheckedCreateWithoutInstanceInput> | MessageCreateWithoutInstanceInput[] | MessageUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutInstanceInput | MessageCreateOrConnectWithoutInstanceInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutInstanceInput | MessageUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MessageCreateManyInstanceInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutInstanceInput | MessageUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutInstanceInput | MessageUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type WebhookUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<WebhookCreateWithoutInstanceInput, WebhookUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutInstanceInput
    upsert?: WebhookUpsertWithoutInstanceInput
    disconnect?: WebhookWhereInput | boolean
    delete?: WebhookWhereInput | boolean
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutInstanceInput, WebhookUpdateWithoutInstanceInput>, WebhookUncheckedUpdateWithoutInstanceInput>
  }

  export type ChatwootUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<ChatwootCreateWithoutInstanceInput, ChatwootUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: ChatwootCreateOrConnectWithoutInstanceInput
    upsert?: ChatwootUpsertWithoutInstanceInput
    disconnect?: ChatwootWhereInput | boolean
    delete?: ChatwootWhereInput | boolean
    connect?: ChatwootWhereUniqueInput
    update?: XOR<XOR<ChatwootUpdateToOneWithWhereWithoutInstanceInput, ChatwootUpdateWithoutInstanceInput>, ChatwootUncheckedUpdateWithoutInstanceInput>
  }

  export type LabelUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<LabelCreateWithoutInstanceInput, LabelUncheckedCreateWithoutInstanceInput> | LabelCreateWithoutInstanceInput[] | LabelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutInstanceInput | LabelCreateOrConnectWithoutInstanceInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutInstanceInput | LabelUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: LabelCreateManyInstanceInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutInstanceInput | LabelUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutInstanceInput | LabelUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type ProxyUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<ProxyCreateWithoutInstanceInput, ProxyUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutInstanceInput
    upsert?: ProxyUpsertWithoutInstanceInput
    disconnect?: ProxyWhereInput | boolean
    delete?: ProxyWhereInput | boolean
    connect?: ProxyWhereUniqueInput
    update?: XOR<XOR<ProxyUpdateToOneWithWhereWithoutInstanceInput, ProxyUpdateWithoutInstanceInput>, ProxyUncheckedUpdateWithoutInstanceInput>
  }

  export type SettingUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<SettingCreateWithoutInstanceInput, SettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SettingCreateOrConnectWithoutInstanceInput
    upsert?: SettingUpsertWithoutInstanceInput
    disconnect?: SettingWhereInput | boolean
    delete?: SettingWhereInput | boolean
    connect?: SettingWhereUniqueInput
    update?: XOR<XOR<SettingUpdateToOneWithWhereWithoutInstanceInput, SettingUpdateWithoutInstanceInput>, SettingUncheckedUpdateWithoutInstanceInput>
  }

  export type RabbitmqUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<RabbitmqCreateWithoutInstanceInput, RabbitmqUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: RabbitmqCreateOrConnectWithoutInstanceInput
    upsert?: RabbitmqUpsertWithoutInstanceInput
    disconnect?: RabbitmqWhereInput | boolean
    delete?: RabbitmqWhereInput | boolean
    connect?: RabbitmqWhereUniqueInput
    update?: XOR<XOR<RabbitmqUpdateToOneWithWhereWithoutInstanceInput, RabbitmqUpdateWithoutInstanceInput>, RabbitmqUncheckedUpdateWithoutInstanceInput>
  }

  export type SqsUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<SqsCreateWithoutInstanceInput, SqsUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SqsCreateOrConnectWithoutInstanceInput
    upsert?: SqsUpsertWithoutInstanceInput
    disconnect?: SqsWhereInput | boolean
    delete?: SqsWhereInput | boolean
    connect?: SqsWhereUniqueInput
    update?: XOR<XOR<SqsUpdateToOneWithWhereWithoutInstanceInput, SqsUpdateWithoutInstanceInput>, SqsUncheckedUpdateWithoutInstanceInput>
  }

  export type WebsocketUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<WebsocketCreateWithoutInstanceInput, WebsocketUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WebsocketCreateOrConnectWithoutInstanceInput
    upsert?: WebsocketUpsertWithoutInstanceInput
    disconnect?: WebsocketWhereInput | boolean
    delete?: WebsocketWhereInput | boolean
    connect?: WebsocketWhereUniqueInput
    update?: XOR<XOR<WebsocketUpdateToOneWithWhereWithoutInstanceInput, WebsocketUpdateWithoutInstanceInput>, WebsocketUncheckedUpdateWithoutInstanceInput>
  }

  export type TypebotUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<TypebotCreateWithoutInstanceInput, TypebotUncheckedCreateWithoutInstanceInput> | TypebotCreateWithoutInstanceInput[] | TypebotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TypebotCreateOrConnectWithoutInstanceInput | TypebotCreateOrConnectWithoutInstanceInput[]
    upsert?: TypebotUpsertWithWhereUniqueWithoutInstanceInput | TypebotUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: TypebotCreateManyInstanceInputEnvelope
    set?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
    disconnect?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
    delete?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
    connect?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
    update?: TypebotUpdateWithWhereUniqueWithoutInstanceInput | TypebotUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: TypebotUpdateManyWithWhereWithoutInstanceInput | TypebotUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: TypebotScalarWhereInput | TypebotScalarWhereInput[]
  }

  export type SessionUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<SessionCreateWithoutInstanceInput, SessionUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SessionCreateOrConnectWithoutInstanceInput
    upsert?: SessionUpsertWithoutInstanceInput
    disconnect?: SessionWhereInput | boolean
    delete?: SessionWhereInput | boolean
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutInstanceInput, SessionUpdateWithoutInstanceInput>, SessionUncheckedUpdateWithoutInstanceInput>
  }

  export type MessageUpdateUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MessageUpdateCreateWithoutInstanceInput, MessageUpdateUncheckedCreateWithoutInstanceInput> | MessageUpdateCreateWithoutInstanceInput[] | MessageUpdateUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MessageUpdateCreateOrConnectWithoutInstanceInput | MessageUpdateCreateOrConnectWithoutInstanceInput[]
    upsert?: MessageUpdateUpsertWithWhereUniqueWithoutInstanceInput | MessageUpdateUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MessageUpdateCreateManyInstanceInputEnvelope
    set?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    disconnect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    delete?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    connect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    update?: MessageUpdateUpdateWithWhereUniqueWithoutInstanceInput | MessageUpdateUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MessageUpdateUpdateManyWithWhereWithoutInstanceInput | MessageUpdateUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MessageUpdateScalarWhereInput | MessageUpdateScalarWhereInput[]
  }

  export type TypebotSettingUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<TypebotSettingCreateWithoutInstanceInput, TypebotSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: TypebotSettingCreateOrConnectWithoutInstanceInput
    upsert?: TypebotSettingUpsertWithoutInstanceInput
    disconnect?: TypebotSettingWhereInput | boolean
    delete?: TypebotSettingWhereInput | boolean
    connect?: TypebotSettingWhereUniqueInput
    update?: XOR<XOR<TypebotSettingUpdateToOneWithWhereWithoutInstanceInput, TypebotSettingUpdateWithoutInstanceInput>, TypebotSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type MediaUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MediaCreateWithoutInstanceInput, MediaUncheckedCreateWithoutInstanceInput> | MediaCreateWithoutInstanceInput[] | MediaUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutInstanceInput | MediaCreateOrConnectWithoutInstanceInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutInstanceInput | MediaUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MediaCreateManyInstanceInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutInstanceInput | MediaUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutInstanceInput | MediaUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type OpenaiCredsUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<OpenaiCredsCreateWithoutInstanceInput, OpenaiCredsUncheckedCreateWithoutInstanceInput> | OpenaiCredsCreateWithoutInstanceInput[] | OpenaiCredsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: OpenaiCredsCreateOrConnectWithoutInstanceInput | OpenaiCredsCreateOrConnectWithoutInstanceInput[]
    upsert?: OpenaiCredsUpsertWithWhereUniqueWithoutInstanceInput | OpenaiCredsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: OpenaiCredsCreateManyInstanceInputEnvelope
    set?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
    disconnect?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
    delete?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
    connect?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
    update?: OpenaiCredsUpdateWithWhereUniqueWithoutInstanceInput | OpenaiCredsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: OpenaiCredsUpdateManyWithWhereWithoutInstanceInput | OpenaiCredsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: OpenaiCredsScalarWhereInput | OpenaiCredsScalarWhereInput[]
  }

  export type OpenaiBotUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<OpenaiBotCreateWithoutInstanceInput, OpenaiBotUncheckedCreateWithoutInstanceInput> | OpenaiBotCreateWithoutInstanceInput[] | OpenaiBotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutInstanceInput | OpenaiBotCreateOrConnectWithoutInstanceInput[]
    upsert?: OpenaiBotUpsertWithWhereUniqueWithoutInstanceInput | OpenaiBotUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: OpenaiBotCreateManyInstanceInputEnvelope
    set?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    disconnect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    delete?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    connect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    update?: OpenaiBotUpdateWithWhereUniqueWithoutInstanceInput | OpenaiBotUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: OpenaiBotUpdateManyWithWhereWithoutInstanceInput | OpenaiBotUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: OpenaiBotScalarWhereInput | OpenaiBotScalarWhereInput[]
  }

  export type OpenaiSettingUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<OpenaiSettingCreateWithoutInstanceInput, OpenaiSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutInstanceInput
    upsert?: OpenaiSettingUpsertWithoutInstanceInput
    disconnect?: OpenaiSettingWhereInput | boolean
    delete?: OpenaiSettingWhereInput | boolean
    connect?: OpenaiSettingWhereUniqueInput
    update?: XOR<XOR<OpenaiSettingUpdateToOneWithWhereWithoutInstanceInput, OpenaiSettingUpdateWithoutInstanceInput>, OpenaiSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type TemplateUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<TemplateCreateWithoutInstanceInput, TemplateUncheckedCreateWithoutInstanceInput> | TemplateCreateWithoutInstanceInput[] | TemplateUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutInstanceInput | TemplateCreateOrConnectWithoutInstanceInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutInstanceInput | TemplateUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: TemplateCreateManyInstanceInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutInstanceInput | TemplateUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutInstanceInput | TemplateUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type DifyUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DifyCreateWithoutInstanceInput, DifyUncheckedCreateWithoutInstanceInput> | DifyCreateWithoutInstanceInput[] | DifyUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DifyCreateOrConnectWithoutInstanceInput | DifyCreateOrConnectWithoutInstanceInput[]
    upsert?: DifyUpsertWithWhereUniqueWithoutInstanceInput | DifyUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DifyCreateManyInstanceInputEnvelope
    set?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
    disconnect?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
    delete?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
    connect?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
    update?: DifyUpdateWithWhereUniqueWithoutInstanceInput | DifyUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DifyUpdateManyWithWhereWithoutInstanceInput | DifyUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DifyScalarWhereInput | DifyScalarWhereInput[]
  }

  export type DifySettingUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<DifySettingCreateWithoutInstanceInput, DifySettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: DifySettingCreateOrConnectWithoutInstanceInput
    upsert?: DifySettingUpsertWithoutInstanceInput
    disconnect?: DifySettingWhereInput | boolean
    delete?: DifySettingWhereInput | boolean
    connect?: DifySettingWhereUniqueInput
    update?: XOR<XOR<DifySettingUpdateToOneWithWhereWithoutInstanceInput, DifySettingUpdateWithoutInstanceInput>, DifySettingUncheckedUpdateWithoutInstanceInput>
  }

  export type IntegrationSessionUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<IntegrationSessionCreateWithoutInstanceInput, IntegrationSessionUncheckedCreateWithoutInstanceInput> | IntegrationSessionCreateWithoutInstanceInput[] | IntegrationSessionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: IntegrationSessionCreateOrConnectWithoutInstanceInput | IntegrationSessionCreateOrConnectWithoutInstanceInput[]
    upsert?: IntegrationSessionUpsertWithWhereUniqueWithoutInstanceInput | IntegrationSessionUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: IntegrationSessionCreateManyInstanceInputEnvelope
    set?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
    disconnect?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
    delete?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
    connect?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
    update?: IntegrationSessionUpdateWithWhereUniqueWithoutInstanceInput | IntegrationSessionUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: IntegrationSessionUpdateManyWithWhereWithoutInstanceInput | IntegrationSessionUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: IntegrationSessionScalarWhereInput | IntegrationSessionScalarWhereInput[]
  }

  export type EvolutionBotUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<EvolutionBotCreateWithoutInstanceInput, EvolutionBotUncheckedCreateWithoutInstanceInput> | EvolutionBotCreateWithoutInstanceInput[] | EvolutionBotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: EvolutionBotCreateOrConnectWithoutInstanceInput | EvolutionBotCreateOrConnectWithoutInstanceInput[]
    upsert?: EvolutionBotUpsertWithWhereUniqueWithoutInstanceInput | EvolutionBotUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: EvolutionBotCreateManyInstanceInputEnvelope
    set?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
    disconnect?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
    delete?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
    connect?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
    update?: EvolutionBotUpdateWithWhereUniqueWithoutInstanceInput | EvolutionBotUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: EvolutionBotUpdateManyWithWhereWithoutInstanceInput | EvolutionBotUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: EvolutionBotScalarWhereInput | EvolutionBotScalarWhereInput[]
  }

  export type EvolutionBotSettingUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<EvolutionBotSettingCreateWithoutInstanceInput, EvolutionBotSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: EvolutionBotSettingCreateOrConnectWithoutInstanceInput
    upsert?: EvolutionBotSettingUpsertWithoutInstanceInput
    disconnect?: EvolutionBotSettingWhereInput | boolean
    delete?: EvolutionBotSettingWhereInput | boolean
    connect?: EvolutionBotSettingWhereUniqueInput
    update?: XOR<XOR<EvolutionBotSettingUpdateToOneWithWhereWithoutInstanceInput, EvolutionBotSettingUpdateWithoutInstanceInput>, EvolutionBotSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type FlowiseUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<FlowiseCreateWithoutInstanceInput, FlowiseUncheckedCreateWithoutInstanceInput> | FlowiseCreateWithoutInstanceInput[] | FlowiseUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: FlowiseCreateOrConnectWithoutInstanceInput | FlowiseCreateOrConnectWithoutInstanceInput[]
    upsert?: FlowiseUpsertWithWhereUniqueWithoutInstanceInput | FlowiseUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: FlowiseCreateManyInstanceInputEnvelope
    set?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
    disconnect?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
    delete?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
    connect?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
    update?: FlowiseUpdateWithWhereUniqueWithoutInstanceInput | FlowiseUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: FlowiseUpdateManyWithWhereWithoutInstanceInput | FlowiseUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: FlowiseScalarWhereInput | FlowiseScalarWhereInput[]
  }

  export type FlowiseSettingUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<FlowiseSettingCreateWithoutInstanceInput, FlowiseSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: FlowiseSettingCreateOrConnectWithoutInstanceInput
    upsert?: FlowiseSettingUpsertWithoutInstanceInput
    disconnect?: FlowiseSettingWhereInput | boolean
    delete?: FlowiseSettingWhereInput | boolean
    connect?: FlowiseSettingWhereUniqueInput
    update?: XOR<XOR<FlowiseSettingUpdateToOneWithWhereWithoutInstanceInput, FlowiseSettingUpdateWithoutInstanceInput>, FlowiseSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type PusherUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<PusherCreateWithoutInstanceInput, PusherUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: PusherCreateOrConnectWithoutInstanceInput
    upsert?: PusherUpsertWithoutInstanceInput
    disconnect?: PusherWhereInput | boolean
    delete?: PusherWhereInput | boolean
    connect?: PusherWhereUniqueInput
    update?: XOR<XOR<PusherUpdateToOneWithWhereWithoutInstanceInput, PusherUpdateWithoutInstanceInput>, PusherUncheckedUpdateWithoutInstanceInput>
  }

  export type ChatUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ChatCreateWithoutInstanceInput, ChatUncheckedCreateWithoutInstanceInput> | ChatCreateWithoutInstanceInput[] | ChatUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutInstanceInput | ChatCreateOrConnectWithoutInstanceInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutInstanceInput | ChatUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ChatCreateManyInstanceInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutInstanceInput | ChatUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutInstanceInput | ChatUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<ContactCreateWithoutInstanceInput, ContactUncheckedCreateWithoutInstanceInput> | ContactCreateWithoutInstanceInput[] | ContactUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutInstanceInput | ContactCreateOrConnectWithoutInstanceInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutInstanceInput | ContactUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: ContactCreateManyInstanceInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutInstanceInput | ContactUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutInstanceInput | ContactUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MessageCreateWithoutInstanceInput, MessageUncheckedCreateWithoutInstanceInput> | MessageCreateWithoutInstanceInput[] | MessageUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutInstanceInput | MessageCreateOrConnectWithoutInstanceInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutInstanceInput | MessageUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MessageCreateManyInstanceInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutInstanceInput | MessageUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutInstanceInput | MessageUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type WebhookUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<WebhookCreateWithoutInstanceInput, WebhookUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WebhookCreateOrConnectWithoutInstanceInput
    upsert?: WebhookUpsertWithoutInstanceInput
    disconnect?: WebhookWhereInput | boolean
    delete?: WebhookWhereInput | boolean
    connect?: WebhookWhereUniqueInput
    update?: XOR<XOR<WebhookUpdateToOneWithWhereWithoutInstanceInput, WebhookUpdateWithoutInstanceInput>, WebhookUncheckedUpdateWithoutInstanceInput>
  }

  export type ChatwootUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<ChatwootCreateWithoutInstanceInput, ChatwootUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: ChatwootCreateOrConnectWithoutInstanceInput
    upsert?: ChatwootUpsertWithoutInstanceInput
    disconnect?: ChatwootWhereInput | boolean
    delete?: ChatwootWhereInput | boolean
    connect?: ChatwootWhereUniqueInput
    update?: XOR<XOR<ChatwootUpdateToOneWithWhereWithoutInstanceInput, ChatwootUpdateWithoutInstanceInput>, ChatwootUncheckedUpdateWithoutInstanceInput>
  }

  export type LabelUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<LabelCreateWithoutInstanceInput, LabelUncheckedCreateWithoutInstanceInput> | LabelCreateWithoutInstanceInput[] | LabelUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: LabelCreateOrConnectWithoutInstanceInput | LabelCreateOrConnectWithoutInstanceInput[]
    upsert?: LabelUpsertWithWhereUniqueWithoutInstanceInput | LabelUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: LabelCreateManyInstanceInputEnvelope
    set?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    disconnect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    delete?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    connect?: LabelWhereUniqueInput | LabelWhereUniqueInput[]
    update?: LabelUpdateWithWhereUniqueWithoutInstanceInput | LabelUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: LabelUpdateManyWithWhereWithoutInstanceInput | LabelUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: LabelScalarWhereInput | LabelScalarWhereInput[]
  }

  export type ProxyUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<ProxyCreateWithoutInstanceInput, ProxyUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutInstanceInput
    upsert?: ProxyUpsertWithoutInstanceInput
    disconnect?: ProxyWhereInput | boolean
    delete?: ProxyWhereInput | boolean
    connect?: ProxyWhereUniqueInput
    update?: XOR<XOR<ProxyUpdateToOneWithWhereWithoutInstanceInput, ProxyUpdateWithoutInstanceInput>, ProxyUncheckedUpdateWithoutInstanceInput>
  }

  export type SettingUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<SettingCreateWithoutInstanceInput, SettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SettingCreateOrConnectWithoutInstanceInput
    upsert?: SettingUpsertWithoutInstanceInput
    disconnect?: SettingWhereInput | boolean
    delete?: SettingWhereInput | boolean
    connect?: SettingWhereUniqueInput
    update?: XOR<XOR<SettingUpdateToOneWithWhereWithoutInstanceInput, SettingUpdateWithoutInstanceInput>, SettingUncheckedUpdateWithoutInstanceInput>
  }

  export type RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<RabbitmqCreateWithoutInstanceInput, RabbitmqUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: RabbitmqCreateOrConnectWithoutInstanceInput
    upsert?: RabbitmqUpsertWithoutInstanceInput
    disconnect?: RabbitmqWhereInput | boolean
    delete?: RabbitmqWhereInput | boolean
    connect?: RabbitmqWhereUniqueInput
    update?: XOR<XOR<RabbitmqUpdateToOneWithWhereWithoutInstanceInput, RabbitmqUpdateWithoutInstanceInput>, RabbitmqUncheckedUpdateWithoutInstanceInput>
  }

  export type SqsUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<SqsCreateWithoutInstanceInput, SqsUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SqsCreateOrConnectWithoutInstanceInput
    upsert?: SqsUpsertWithoutInstanceInput
    disconnect?: SqsWhereInput | boolean
    delete?: SqsWhereInput | boolean
    connect?: SqsWhereUniqueInput
    update?: XOR<XOR<SqsUpdateToOneWithWhereWithoutInstanceInput, SqsUpdateWithoutInstanceInput>, SqsUncheckedUpdateWithoutInstanceInput>
  }

  export type WebsocketUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<WebsocketCreateWithoutInstanceInput, WebsocketUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: WebsocketCreateOrConnectWithoutInstanceInput
    upsert?: WebsocketUpsertWithoutInstanceInput
    disconnect?: WebsocketWhereInput | boolean
    delete?: WebsocketWhereInput | boolean
    connect?: WebsocketWhereUniqueInput
    update?: XOR<XOR<WebsocketUpdateToOneWithWhereWithoutInstanceInput, WebsocketUpdateWithoutInstanceInput>, WebsocketUncheckedUpdateWithoutInstanceInput>
  }

  export type TypebotUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<TypebotCreateWithoutInstanceInput, TypebotUncheckedCreateWithoutInstanceInput> | TypebotCreateWithoutInstanceInput[] | TypebotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TypebotCreateOrConnectWithoutInstanceInput | TypebotCreateOrConnectWithoutInstanceInput[]
    upsert?: TypebotUpsertWithWhereUniqueWithoutInstanceInput | TypebotUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: TypebotCreateManyInstanceInputEnvelope
    set?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
    disconnect?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
    delete?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
    connect?: TypebotWhereUniqueInput | TypebotWhereUniqueInput[]
    update?: TypebotUpdateWithWhereUniqueWithoutInstanceInput | TypebotUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: TypebotUpdateManyWithWhereWithoutInstanceInput | TypebotUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: TypebotScalarWhereInput | TypebotScalarWhereInput[]
  }

  export type SessionUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<SessionCreateWithoutInstanceInput, SessionUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: SessionCreateOrConnectWithoutInstanceInput
    upsert?: SessionUpsertWithoutInstanceInput
    disconnect?: SessionWhereInput | boolean
    delete?: SessionWhereInput | boolean
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutInstanceInput, SessionUpdateWithoutInstanceInput>, SessionUncheckedUpdateWithoutInstanceInput>
  }

  export type MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MessageUpdateCreateWithoutInstanceInput, MessageUpdateUncheckedCreateWithoutInstanceInput> | MessageUpdateCreateWithoutInstanceInput[] | MessageUpdateUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MessageUpdateCreateOrConnectWithoutInstanceInput | MessageUpdateCreateOrConnectWithoutInstanceInput[]
    upsert?: MessageUpdateUpsertWithWhereUniqueWithoutInstanceInput | MessageUpdateUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MessageUpdateCreateManyInstanceInputEnvelope
    set?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    disconnect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    delete?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    connect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    update?: MessageUpdateUpdateWithWhereUniqueWithoutInstanceInput | MessageUpdateUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MessageUpdateUpdateManyWithWhereWithoutInstanceInput | MessageUpdateUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MessageUpdateScalarWhereInput | MessageUpdateScalarWhereInput[]
  }

  export type TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<TypebotSettingCreateWithoutInstanceInput, TypebotSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: TypebotSettingCreateOrConnectWithoutInstanceInput
    upsert?: TypebotSettingUpsertWithoutInstanceInput
    disconnect?: TypebotSettingWhereInput | boolean
    delete?: TypebotSettingWhereInput | boolean
    connect?: TypebotSettingWhereUniqueInput
    update?: XOR<XOR<TypebotSettingUpdateToOneWithWhereWithoutInstanceInput, TypebotSettingUpdateWithoutInstanceInput>, TypebotSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type MediaUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<MediaCreateWithoutInstanceInput, MediaUncheckedCreateWithoutInstanceInput> | MediaCreateWithoutInstanceInput[] | MediaUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutInstanceInput | MediaCreateOrConnectWithoutInstanceInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutInstanceInput | MediaUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: MediaCreateManyInstanceInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutInstanceInput | MediaUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutInstanceInput | MediaUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<OpenaiCredsCreateWithoutInstanceInput, OpenaiCredsUncheckedCreateWithoutInstanceInput> | OpenaiCredsCreateWithoutInstanceInput[] | OpenaiCredsUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: OpenaiCredsCreateOrConnectWithoutInstanceInput | OpenaiCredsCreateOrConnectWithoutInstanceInput[]
    upsert?: OpenaiCredsUpsertWithWhereUniqueWithoutInstanceInput | OpenaiCredsUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: OpenaiCredsCreateManyInstanceInputEnvelope
    set?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
    disconnect?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
    delete?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
    connect?: OpenaiCredsWhereUniqueInput | OpenaiCredsWhereUniqueInput[]
    update?: OpenaiCredsUpdateWithWhereUniqueWithoutInstanceInput | OpenaiCredsUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: OpenaiCredsUpdateManyWithWhereWithoutInstanceInput | OpenaiCredsUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: OpenaiCredsScalarWhereInput | OpenaiCredsScalarWhereInput[]
  }

  export type OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<OpenaiBotCreateWithoutInstanceInput, OpenaiBotUncheckedCreateWithoutInstanceInput> | OpenaiBotCreateWithoutInstanceInput[] | OpenaiBotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutInstanceInput | OpenaiBotCreateOrConnectWithoutInstanceInput[]
    upsert?: OpenaiBotUpsertWithWhereUniqueWithoutInstanceInput | OpenaiBotUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: OpenaiBotCreateManyInstanceInputEnvelope
    set?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    disconnect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    delete?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    connect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    update?: OpenaiBotUpdateWithWhereUniqueWithoutInstanceInput | OpenaiBotUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: OpenaiBotUpdateManyWithWhereWithoutInstanceInput | OpenaiBotUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: OpenaiBotScalarWhereInput | OpenaiBotScalarWhereInput[]
  }

  export type OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<OpenaiSettingCreateWithoutInstanceInput, OpenaiSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutInstanceInput
    upsert?: OpenaiSettingUpsertWithoutInstanceInput
    disconnect?: OpenaiSettingWhereInput | boolean
    delete?: OpenaiSettingWhereInput | boolean
    connect?: OpenaiSettingWhereUniqueInput
    update?: XOR<XOR<OpenaiSettingUpdateToOneWithWhereWithoutInstanceInput, OpenaiSettingUpdateWithoutInstanceInput>, OpenaiSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type TemplateUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<TemplateCreateWithoutInstanceInput, TemplateUncheckedCreateWithoutInstanceInput> | TemplateCreateWithoutInstanceInput[] | TemplateUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: TemplateCreateOrConnectWithoutInstanceInput | TemplateCreateOrConnectWithoutInstanceInput[]
    upsert?: TemplateUpsertWithWhereUniqueWithoutInstanceInput | TemplateUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: TemplateCreateManyInstanceInputEnvelope
    set?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    disconnect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    delete?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    connect?: TemplateWhereUniqueInput | TemplateWhereUniqueInput[]
    update?: TemplateUpdateWithWhereUniqueWithoutInstanceInput | TemplateUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: TemplateUpdateManyWithWhereWithoutInstanceInput | TemplateUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
  }

  export type DifyUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<DifyCreateWithoutInstanceInput, DifyUncheckedCreateWithoutInstanceInput> | DifyCreateWithoutInstanceInput[] | DifyUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: DifyCreateOrConnectWithoutInstanceInput | DifyCreateOrConnectWithoutInstanceInput[]
    upsert?: DifyUpsertWithWhereUniqueWithoutInstanceInput | DifyUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: DifyCreateManyInstanceInputEnvelope
    set?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
    disconnect?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
    delete?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
    connect?: DifyWhereUniqueInput | DifyWhereUniqueInput[]
    update?: DifyUpdateWithWhereUniqueWithoutInstanceInput | DifyUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: DifyUpdateManyWithWhereWithoutInstanceInput | DifyUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: DifyScalarWhereInput | DifyScalarWhereInput[]
  }

  export type DifySettingUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<DifySettingCreateWithoutInstanceInput, DifySettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: DifySettingCreateOrConnectWithoutInstanceInput
    upsert?: DifySettingUpsertWithoutInstanceInput
    disconnect?: DifySettingWhereInput | boolean
    delete?: DifySettingWhereInput | boolean
    connect?: DifySettingWhereUniqueInput
    update?: XOR<XOR<DifySettingUpdateToOneWithWhereWithoutInstanceInput, DifySettingUpdateWithoutInstanceInput>, DifySettingUncheckedUpdateWithoutInstanceInput>
  }

  export type IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<IntegrationSessionCreateWithoutInstanceInput, IntegrationSessionUncheckedCreateWithoutInstanceInput> | IntegrationSessionCreateWithoutInstanceInput[] | IntegrationSessionUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: IntegrationSessionCreateOrConnectWithoutInstanceInput | IntegrationSessionCreateOrConnectWithoutInstanceInput[]
    upsert?: IntegrationSessionUpsertWithWhereUniqueWithoutInstanceInput | IntegrationSessionUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: IntegrationSessionCreateManyInstanceInputEnvelope
    set?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
    disconnect?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
    delete?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
    connect?: IntegrationSessionWhereUniqueInput | IntegrationSessionWhereUniqueInput[]
    update?: IntegrationSessionUpdateWithWhereUniqueWithoutInstanceInput | IntegrationSessionUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: IntegrationSessionUpdateManyWithWhereWithoutInstanceInput | IntegrationSessionUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: IntegrationSessionScalarWhereInput | IntegrationSessionScalarWhereInput[]
  }

  export type EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<EvolutionBotCreateWithoutInstanceInput, EvolutionBotUncheckedCreateWithoutInstanceInput> | EvolutionBotCreateWithoutInstanceInput[] | EvolutionBotUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: EvolutionBotCreateOrConnectWithoutInstanceInput | EvolutionBotCreateOrConnectWithoutInstanceInput[]
    upsert?: EvolutionBotUpsertWithWhereUniqueWithoutInstanceInput | EvolutionBotUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: EvolutionBotCreateManyInstanceInputEnvelope
    set?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
    disconnect?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
    delete?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
    connect?: EvolutionBotWhereUniqueInput | EvolutionBotWhereUniqueInput[]
    update?: EvolutionBotUpdateWithWhereUniqueWithoutInstanceInput | EvolutionBotUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: EvolutionBotUpdateManyWithWhereWithoutInstanceInput | EvolutionBotUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: EvolutionBotScalarWhereInput | EvolutionBotScalarWhereInput[]
  }

  export type EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<EvolutionBotSettingCreateWithoutInstanceInput, EvolutionBotSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: EvolutionBotSettingCreateOrConnectWithoutInstanceInput
    upsert?: EvolutionBotSettingUpsertWithoutInstanceInput
    disconnect?: EvolutionBotSettingWhereInput | boolean
    delete?: EvolutionBotSettingWhereInput | boolean
    connect?: EvolutionBotSettingWhereUniqueInput
    update?: XOR<XOR<EvolutionBotSettingUpdateToOneWithWhereWithoutInstanceInput, EvolutionBotSettingUpdateWithoutInstanceInput>, EvolutionBotSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type FlowiseUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?: XOR<FlowiseCreateWithoutInstanceInput, FlowiseUncheckedCreateWithoutInstanceInput> | FlowiseCreateWithoutInstanceInput[] | FlowiseUncheckedCreateWithoutInstanceInput[]
    connectOrCreate?: FlowiseCreateOrConnectWithoutInstanceInput | FlowiseCreateOrConnectWithoutInstanceInput[]
    upsert?: FlowiseUpsertWithWhereUniqueWithoutInstanceInput | FlowiseUpsertWithWhereUniqueWithoutInstanceInput[]
    createMany?: FlowiseCreateManyInstanceInputEnvelope
    set?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
    disconnect?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
    delete?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
    connect?: FlowiseWhereUniqueInput | FlowiseWhereUniqueInput[]
    update?: FlowiseUpdateWithWhereUniqueWithoutInstanceInput | FlowiseUpdateWithWhereUniqueWithoutInstanceInput[]
    updateMany?: FlowiseUpdateManyWithWhereWithoutInstanceInput | FlowiseUpdateManyWithWhereWithoutInstanceInput[]
    deleteMany?: FlowiseScalarWhereInput | FlowiseScalarWhereInput[]
  }

  export type FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<FlowiseSettingCreateWithoutInstanceInput, FlowiseSettingUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: FlowiseSettingCreateOrConnectWithoutInstanceInput
    upsert?: FlowiseSettingUpsertWithoutInstanceInput
    disconnect?: FlowiseSettingWhereInput | boolean
    delete?: FlowiseSettingWhereInput | boolean
    connect?: FlowiseSettingWhereUniqueInput
    update?: XOR<XOR<FlowiseSettingUpdateToOneWithWhereWithoutInstanceInput, FlowiseSettingUpdateWithoutInstanceInput>, FlowiseSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type PusherUncheckedUpdateOneWithoutInstanceNestedInput = {
    create?: XOR<PusherCreateWithoutInstanceInput, PusherUncheckedCreateWithoutInstanceInput>
    connectOrCreate?: PusherCreateOrConnectWithoutInstanceInput
    upsert?: PusherUpsertWithoutInstanceInput
    disconnect?: PusherWhereInput | boolean
    delete?: PusherWhereInput | boolean
    connect?: PusherWhereUniqueInput
    update?: XOR<XOR<PusherUpdateToOneWithWhereWithoutInstanceInput, PusherUpdateWithoutInstanceInput>, PusherUncheckedUpdateWithoutInstanceInput>
  }

  export type InstanceCreateNestedOneWithoutSessionInput = {
    create?: XOR<InstanceCreateWithoutSessionInput, InstanceUncheckedCreateWithoutSessionInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutSessionInput
    connect?: InstanceWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type InstanceUpdateOneRequiredWithoutSessionNestedInput = {
    create?: XOR<InstanceCreateWithoutSessionInput, InstanceUncheckedCreateWithoutSessionInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutSessionInput
    upsert?: InstanceUpsertWithoutSessionInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutSessionInput, InstanceUpdateWithoutSessionInput>, InstanceUncheckedUpdateWithoutSessionInput>
  }

  export type InstanceCreateNestedOneWithoutChatInput = {
    create?: XOR<InstanceCreateWithoutChatInput, InstanceUncheckedCreateWithoutChatInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutChatInput
    connect?: InstanceWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InstanceUpdateOneRequiredWithoutChatNestedInput = {
    create?: XOR<InstanceCreateWithoutChatInput, InstanceUncheckedCreateWithoutChatInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutChatInput
    upsert?: InstanceUpsertWithoutChatInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutChatInput, InstanceUpdateWithoutChatInput>, InstanceUncheckedUpdateWithoutChatInput>
  }

  export type InstanceCreateNestedOneWithoutContactInput = {
    create?: XOR<InstanceCreateWithoutContactInput, InstanceUncheckedCreateWithoutContactInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutContactInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutContactNestedInput = {
    create?: XOR<InstanceCreateWithoutContactInput, InstanceUncheckedCreateWithoutContactInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutContactInput
    upsert?: InstanceUpsertWithoutContactInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutContactInput, InstanceUpdateWithoutContactInput>, InstanceUncheckedUpdateWithoutContactInput>
  }

  export type InstanceCreateNestedOneWithoutMessageInput = {
    create?: XOR<InstanceCreateWithoutMessageInput, InstanceUncheckedCreateWithoutMessageInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMessageInput
    connect?: InstanceWhereUniqueInput
  }

  export type MessageUpdateCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageUpdateCreateWithoutMessageInput, MessageUpdateUncheckedCreateWithoutMessageInput> | MessageUpdateCreateWithoutMessageInput[] | MessageUpdateUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageUpdateCreateOrConnectWithoutMessageInput | MessageUpdateCreateOrConnectWithoutMessageInput[]
    createMany?: MessageUpdateCreateManyMessageInputEnvelope
    connect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
  }

  export type MediaCreateNestedOneWithoutMessageInput = {
    create?: XOR<MediaCreateWithoutMessageInput, MediaUncheckedCreateWithoutMessageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMessageInput
    connect?: MediaWhereUniqueInput
  }

  export type IntegrationSessionCreateNestedOneWithoutMessageInput = {
    create?: XOR<IntegrationSessionCreateWithoutMessageInput, IntegrationSessionUncheckedCreateWithoutMessageInput>
    connectOrCreate?: IntegrationSessionCreateOrConnectWithoutMessageInput
    connect?: IntegrationSessionWhereUniqueInput
  }

  export type MessageUpdateUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageUpdateCreateWithoutMessageInput, MessageUpdateUncheckedCreateWithoutMessageInput> | MessageUpdateCreateWithoutMessageInput[] | MessageUpdateUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageUpdateCreateOrConnectWithoutMessageInput | MessageUpdateCreateOrConnectWithoutMessageInput[]
    createMany?: MessageUpdateCreateManyMessageInputEnvelope
    connect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedOneWithoutMessageInput = {
    create?: XOR<MediaCreateWithoutMessageInput, MediaUncheckedCreateWithoutMessageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMessageInput
    connect?: MediaWhereUniqueInput
  }

  export type EnumDeviceMessageFieldUpdateOperationsInput = {
    set?: $Enums.DeviceMessage
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type InstanceUpdateOneRequiredWithoutMessageNestedInput = {
    create?: XOR<InstanceCreateWithoutMessageInput, InstanceUncheckedCreateWithoutMessageInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMessageInput
    upsert?: InstanceUpsertWithoutMessageInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutMessageInput, InstanceUpdateWithoutMessageInput>, InstanceUncheckedUpdateWithoutMessageInput>
  }

  export type MessageUpdateUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageUpdateCreateWithoutMessageInput, MessageUpdateUncheckedCreateWithoutMessageInput> | MessageUpdateCreateWithoutMessageInput[] | MessageUpdateUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageUpdateCreateOrConnectWithoutMessageInput | MessageUpdateCreateOrConnectWithoutMessageInput[]
    upsert?: MessageUpdateUpsertWithWhereUniqueWithoutMessageInput | MessageUpdateUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageUpdateCreateManyMessageInputEnvelope
    set?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    disconnect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    delete?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    connect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    update?: MessageUpdateUpdateWithWhereUniqueWithoutMessageInput | MessageUpdateUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageUpdateUpdateManyWithWhereWithoutMessageInput | MessageUpdateUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageUpdateScalarWhereInput | MessageUpdateScalarWhereInput[]
  }

  export type MediaUpdateOneWithoutMessageNestedInput = {
    create?: XOR<MediaCreateWithoutMessageInput, MediaUncheckedCreateWithoutMessageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMessageInput
    upsert?: MediaUpsertWithoutMessageInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutMessageInput, MediaUpdateWithoutMessageInput>, MediaUncheckedUpdateWithoutMessageInput>
  }

  export type IntegrationSessionUpdateOneWithoutMessageNestedInput = {
    create?: XOR<IntegrationSessionCreateWithoutMessageInput, IntegrationSessionUncheckedCreateWithoutMessageInput>
    connectOrCreate?: IntegrationSessionCreateOrConnectWithoutMessageInput
    upsert?: IntegrationSessionUpsertWithoutMessageInput
    disconnect?: IntegrationSessionWhereInput | boolean
    delete?: IntegrationSessionWhereInput | boolean
    connect?: IntegrationSessionWhereUniqueInput
    update?: XOR<XOR<IntegrationSessionUpdateToOneWithWhereWithoutMessageInput, IntegrationSessionUpdateWithoutMessageInput>, IntegrationSessionUncheckedUpdateWithoutMessageInput>
  }

  export type MessageUpdateUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageUpdateCreateWithoutMessageInput, MessageUpdateUncheckedCreateWithoutMessageInput> | MessageUpdateCreateWithoutMessageInput[] | MessageUpdateUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageUpdateCreateOrConnectWithoutMessageInput | MessageUpdateCreateOrConnectWithoutMessageInput[]
    upsert?: MessageUpdateUpsertWithWhereUniqueWithoutMessageInput | MessageUpdateUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageUpdateCreateManyMessageInputEnvelope
    set?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    disconnect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    delete?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    connect?: MessageUpdateWhereUniqueInput | MessageUpdateWhereUniqueInput[]
    update?: MessageUpdateUpdateWithWhereUniqueWithoutMessageInput | MessageUpdateUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageUpdateUpdateManyWithWhereWithoutMessageInput | MessageUpdateUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageUpdateScalarWhereInput | MessageUpdateScalarWhereInput[]
  }

  export type MediaUncheckedUpdateOneWithoutMessageNestedInput = {
    create?: XOR<MediaCreateWithoutMessageInput, MediaUncheckedCreateWithoutMessageInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMessageInput
    upsert?: MediaUpsertWithoutMessageInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutMessageInput, MediaUpdateWithoutMessageInput>, MediaUncheckedUpdateWithoutMessageInput>
  }

  export type MessageCreateNestedOneWithoutMessageUpdateInput = {
    create?: XOR<MessageCreateWithoutMessageUpdateInput, MessageUncheckedCreateWithoutMessageUpdateInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMessageUpdateInput
    connect?: MessageWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutMessageUpdateInput = {
    create?: XOR<InstanceCreateWithoutMessageUpdateInput, InstanceUncheckedCreateWithoutMessageUpdateInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMessageUpdateInput
    connect?: InstanceWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MessageUpdateOneRequiredWithoutMessageUpdateNestedInput = {
    create?: XOR<MessageCreateWithoutMessageUpdateInput, MessageUncheckedCreateWithoutMessageUpdateInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMessageUpdateInput
    upsert?: MessageUpsertWithoutMessageUpdateInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutMessageUpdateInput, MessageUpdateWithoutMessageUpdateInput>, MessageUncheckedUpdateWithoutMessageUpdateInput>
  }

  export type InstanceUpdateOneRequiredWithoutMessageUpdateNestedInput = {
    create?: XOR<InstanceCreateWithoutMessageUpdateInput, InstanceUncheckedCreateWithoutMessageUpdateInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMessageUpdateInput
    upsert?: InstanceUpsertWithoutMessageUpdateInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutMessageUpdateInput, InstanceUpdateWithoutMessageUpdateInput>, InstanceUncheckedUpdateWithoutMessageUpdateInput>
  }

  export type InstanceCreateNestedOneWithoutWebhookInput = {
    create?: XOR<InstanceCreateWithoutWebhookInput, InstanceUncheckedCreateWithoutWebhookInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutWebhookInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutWebhookNestedInput = {
    create?: XOR<InstanceCreateWithoutWebhookInput, InstanceUncheckedCreateWithoutWebhookInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutWebhookInput
    upsert?: InstanceUpsertWithoutWebhookInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutWebhookInput, InstanceUpdateWithoutWebhookInput>, InstanceUncheckedUpdateWithoutWebhookInput>
  }

  export type InstanceCreateNestedOneWithoutChatwootInput = {
    create?: XOR<InstanceCreateWithoutChatwootInput, InstanceUncheckedCreateWithoutChatwootInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutChatwootInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutChatwootNestedInput = {
    create?: XOR<InstanceCreateWithoutChatwootInput, InstanceUncheckedCreateWithoutChatwootInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutChatwootInput
    upsert?: InstanceUpsertWithoutChatwootInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutChatwootInput, InstanceUpdateWithoutChatwootInput>, InstanceUncheckedUpdateWithoutChatwootInput>
  }

  export type InstanceCreateNestedOneWithoutLabelInput = {
    create?: XOR<InstanceCreateWithoutLabelInput, InstanceUncheckedCreateWithoutLabelInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutLabelInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutLabelNestedInput = {
    create?: XOR<InstanceCreateWithoutLabelInput, InstanceUncheckedCreateWithoutLabelInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutLabelInput
    upsert?: InstanceUpsertWithoutLabelInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutLabelInput, InstanceUpdateWithoutLabelInput>, InstanceUncheckedUpdateWithoutLabelInput>
  }

  export type InstanceCreateNestedOneWithoutProxyInput = {
    create?: XOR<InstanceCreateWithoutProxyInput, InstanceUncheckedCreateWithoutProxyInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutProxyInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutProxyNestedInput = {
    create?: XOR<InstanceCreateWithoutProxyInput, InstanceUncheckedCreateWithoutProxyInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutProxyInput
    upsert?: InstanceUpsertWithoutProxyInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutProxyInput, InstanceUpdateWithoutProxyInput>, InstanceUncheckedUpdateWithoutProxyInput>
  }

  export type InstanceCreateNestedOneWithoutSettingInput = {
    create?: XOR<InstanceCreateWithoutSettingInput, InstanceUncheckedCreateWithoutSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutSettingInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutSettingNestedInput = {
    create?: XOR<InstanceCreateWithoutSettingInput, InstanceUncheckedCreateWithoutSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutSettingInput
    upsert?: InstanceUpsertWithoutSettingInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutSettingInput, InstanceUpdateWithoutSettingInput>, InstanceUncheckedUpdateWithoutSettingInput>
  }

  export type InstanceCreateNestedOneWithoutRabbitmqInput = {
    create?: XOR<InstanceCreateWithoutRabbitmqInput, InstanceUncheckedCreateWithoutRabbitmqInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutRabbitmqInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutRabbitmqNestedInput = {
    create?: XOR<InstanceCreateWithoutRabbitmqInput, InstanceUncheckedCreateWithoutRabbitmqInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutRabbitmqInput
    upsert?: InstanceUpsertWithoutRabbitmqInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutRabbitmqInput, InstanceUpdateWithoutRabbitmqInput>, InstanceUncheckedUpdateWithoutRabbitmqInput>
  }

  export type InstanceCreateNestedOneWithoutSqsInput = {
    create?: XOR<InstanceCreateWithoutSqsInput, InstanceUncheckedCreateWithoutSqsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutSqsInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutSqsNestedInput = {
    create?: XOR<InstanceCreateWithoutSqsInput, InstanceUncheckedCreateWithoutSqsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutSqsInput
    upsert?: InstanceUpsertWithoutSqsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutSqsInput, InstanceUpdateWithoutSqsInput>, InstanceUncheckedUpdateWithoutSqsInput>
  }

  export type InstanceCreateNestedOneWithoutWebsocketInput = {
    create?: XOR<InstanceCreateWithoutWebsocketInput, InstanceUncheckedCreateWithoutWebsocketInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutWebsocketInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutWebsocketNestedInput = {
    create?: XOR<InstanceCreateWithoutWebsocketInput, InstanceUncheckedCreateWithoutWebsocketInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutWebsocketInput
    upsert?: InstanceUpsertWithoutWebsocketInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutWebsocketInput, InstanceUpdateWithoutWebsocketInput>, InstanceUncheckedUpdateWithoutWebsocketInput>
  }

  export type InstanceCreateNestedOneWithoutPusherInput = {
    create?: XOR<InstanceCreateWithoutPusherInput, InstanceUncheckedCreateWithoutPusherInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutPusherInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutPusherNestedInput = {
    create?: XOR<InstanceCreateWithoutPusherInput, InstanceUncheckedCreateWithoutPusherInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutPusherInput
    upsert?: InstanceUpsertWithoutPusherInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutPusherInput, InstanceUpdateWithoutPusherInput>, InstanceUncheckedUpdateWithoutPusherInput>
  }

  export type InstanceCreateNestedOneWithoutTypebotInput = {
    create?: XOR<InstanceCreateWithoutTypebotInput, InstanceUncheckedCreateWithoutTypebotInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTypebotInput
    connect?: InstanceWhereUniqueInput
  }

  export type TypebotSettingCreateNestedManyWithoutFallbackInput = {
    create?: XOR<TypebotSettingCreateWithoutFallbackInput, TypebotSettingUncheckedCreateWithoutFallbackInput> | TypebotSettingCreateWithoutFallbackInput[] | TypebotSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: TypebotSettingCreateOrConnectWithoutFallbackInput | TypebotSettingCreateOrConnectWithoutFallbackInput[]
    createMany?: TypebotSettingCreateManyFallbackInputEnvelope
    connect?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
  }

  export type TypebotSettingUncheckedCreateNestedManyWithoutFallbackInput = {
    create?: XOR<TypebotSettingCreateWithoutFallbackInput, TypebotSettingUncheckedCreateWithoutFallbackInput> | TypebotSettingCreateWithoutFallbackInput[] | TypebotSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: TypebotSettingCreateOrConnectWithoutFallbackInput | TypebotSettingCreateOrConnectWithoutFallbackInput[]
    createMany?: TypebotSettingCreateManyFallbackInputEnvelope
    connect?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
  }

  export type NullableEnumTriggerTypeFieldUpdateOperationsInput = {
    set?: $Enums.TriggerType | null
  }

  export type NullableEnumTriggerOperatorFieldUpdateOperationsInput = {
    set?: $Enums.TriggerOperator | null
  }

  export type InstanceUpdateOneRequiredWithoutTypebotNestedInput = {
    create?: XOR<InstanceCreateWithoutTypebotInput, InstanceUncheckedCreateWithoutTypebotInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTypebotInput
    upsert?: InstanceUpsertWithoutTypebotInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutTypebotInput, InstanceUpdateWithoutTypebotInput>, InstanceUncheckedUpdateWithoutTypebotInput>
  }

  export type TypebotSettingUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<TypebotSettingCreateWithoutFallbackInput, TypebotSettingUncheckedCreateWithoutFallbackInput> | TypebotSettingCreateWithoutFallbackInput[] | TypebotSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: TypebotSettingCreateOrConnectWithoutFallbackInput | TypebotSettingCreateOrConnectWithoutFallbackInput[]
    upsert?: TypebotSettingUpsertWithWhereUniqueWithoutFallbackInput | TypebotSettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: TypebotSettingCreateManyFallbackInputEnvelope
    set?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
    disconnect?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
    delete?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
    connect?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
    update?: TypebotSettingUpdateWithWhereUniqueWithoutFallbackInput | TypebotSettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: TypebotSettingUpdateManyWithWhereWithoutFallbackInput | TypebotSettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: TypebotSettingScalarWhereInput | TypebotSettingScalarWhereInput[]
  }

  export type TypebotSettingUncheckedUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<TypebotSettingCreateWithoutFallbackInput, TypebotSettingUncheckedCreateWithoutFallbackInput> | TypebotSettingCreateWithoutFallbackInput[] | TypebotSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: TypebotSettingCreateOrConnectWithoutFallbackInput | TypebotSettingCreateOrConnectWithoutFallbackInput[]
    upsert?: TypebotSettingUpsertWithWhereUniqueWithoutFallbackInput | TypebotSettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: TypebotSettingCreateManyFallbackInputEnvelope
    set?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
    disconnect?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
    delete?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
    connect?: TypebotSettingWhereUniqueInput | TypebotSettingWhereUniqueInput[]
    update?: TypebotSettingUpdateWithWhereUniqueWithoutFallbackInput | TypebotSettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: TypebotSettingUpdateManyWithWhereWithoutFallbackInput | TypebotSettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: TypebotSettingScalarWhereInput | TypebotSettingScalarWhereInput[]
  }

  export type TypebotCreateNestedOneWithoutTypebotSettingInput = {
    create?: XOR<TypebotCreateWithoutTypebotSettingInput, TypebotUncheckedCreateWithoutTypebotSettingInput>
    connectOrCreate?: TypebotCreateOrConnectWithoutTypebotSettingInput
    connect?: TypebotWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutTypebotSettingInput = {
    create?: XOR<InstanceCreateWithoutTypebotSettingInput, InstanceUncheckedCreateWithoutTypebotSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTypebotSettingInput
    connect?: InstanceWhereUniqueInput
  }

  export type TypebotUpdateOneWithoutTypebotSettingNestedInput = {
    create?: XOR<TypebotCreateWithoutTypebotSettingInput, TypebotUncheckedCreateWithoutTypebotSettingInput>
    connectOrCreate?: TypebotCreateOrConnectWithoutTypebotSettingInput
    upsert?: TypebotUpsertWithoutTypebotSettingInput
    disconnect?: TypebotWhereInput | boolean
    delete?: TypebotWhereInput | boolean
    connect?: TypebotWhereUniqueInput
    update?: XOR<XOR<TypebotUpdateToOneWithWhereWithoutTypebotSettingInput, TypebotUpdateWithoutTypebotSettingInput>, TypebotUncheckedUpdateWithoutTypebotSettingInput>
  }

  export type InstanceUpdateOneRequiredWithoutTypebotSettingNestedInput = {
    create?: XOR<InstanceCreateWithoutTypebotSettingInput, InstanceUncheckedCreateWithoutTypebotSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTypebotSettingInput
    upsert?: InstanceUpsertWithoutTypebotSettingInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutTypebotSettingInput, InstanceUpdateWithoutTypebotSettingInput>, InstanceUncheckedUpdateWithoutTypebotSettingInput>
  }

  export type MessageCreateNestedManyWithoutSessionInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type InstanceCreateNestedOneWithoutIntegrationSessionsInput = {
    create?: XOR<InstanceCreateWithoutIntegrationSessionsInput, InstanceUncheckedCreateWithoutIntegrationSessionsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutIntegrationSessionsInput
    connect?: InstanceWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type MessageUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSessionInput | MessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSessionInput | MessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSessionInput | MessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type InstanceUpdateOneRequiredWithoutIntegrationSessionsNestedInput = {
    create?: XOR<InstanceCreateWithoutIntegrationSessionsInput, InstanceUncheckedCreateWithoutIntegrationSessionsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutIntegrationSessionsInput
    upsert?: InstanceUpsertWithoutIntegrationSessionsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutIntegrationSessionsInput, InstanceUpdateWithoutIntegrationSessionsInput>, InstanceUncheckedUpdateWithoutIntegrationSessionsInput>
  }

  export type MessageUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput> | MessageCreateWithoutSessionInput[] | MessageUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSessionInput | MessageCreateOrConnectWithoutSessionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSessionInput | MessageUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MessageCreateManySessionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSessionInput | MessageUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSessionInput | MessageUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutMediaInput = {
    create?: XOR<MessageCreateWithoutMediaInput, MessageUncheckedCreateWithoutMediaInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMediaInput
    connect?: MessageWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutMediaInput = {
    create?: XOR<InstanceCreateWithoutMediaInput, InstanceUncheckedCreateWithoutMediaInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMediaInput
    connect?: InstanceWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<MessageCreateWithoutMediaInput, MessageUncheckedCreateWithoutMediaInput>
    connectOrCreate?: MessageCreateOrConnectWithoutMediaInput
    upsert?: MessageUpsertWithoutMediaInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutMediaInput, MessageUpdateWithoutMediaInput>, MessageUncheckedUpdateWithoutMediaInput>
  }

  export type InstanceUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<InstanceCreateWithoutMediaInput, InstanceUncheckedCreateWithoutMediaInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutMediaInput
    upsert?: InstanceUpsertWithoutMediaInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutMediaInput, InstanceUpdateWithoutMediaInput>, InstanceUncheckedUpdateWithoutMediaInput>
  }

  export type InstanceCreateNestedOneWithoutOpenaiCredsInput = {
    create?: XOR<InstanceCreateWithoutOpenaiCredsInput, InstanceUncheckedCreateWithoutOpenaiCredsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutOpenaiCredsInput
    connect?: InstanceWhereUniqueInput
  }

  export type OpenaiBotCreateNestedManyWithoutOpenaiCredsInput = {
    create?: XOR<OpenaiBotCreateWithoutOpenaiCredsInput, OpenaiBotUncheckedCreateWithoutOpenaiCredsInput> | OpenaiBotCreateWithoutOpenaiCredsInput[] | OpenaiBotUncheckedCreateWithoutOpenaiCredsInput[]
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutOpenaiCredsInput | OpenaiBotCreateOrConnectWithoutOpenaiCredsInput[]
    createMany?: OpenaiBotCreateManyOpenaiCredsInputEnvelope
    connect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
  }

  export type OpenaiSettingCreateNestedOneWithoutOpenaiCredsInput = {
    create?: XOR<OpenaiSettingCreateWithoutOpenaiCredsInput, OpenaiSettingUncheckedCreateWithoutOpenaiCredsInput>
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutOpenaiCredsInput
    connect?: OpenaiSettingWhereUniqueInput
  }

  export type OpenaiBotUncheckedCreateNestedManyWithoutOpenaiCredsInput = {
    create?: XOR<OpenaiBotCreateWithoutOpenaiCredsInput, OpenaiBotUncheckedCreateWithoutOpenaiCredsInput> | OpenaiBotCreateWithoutOpenaiCredsInput[] | OpenaiBotUncheckedCreateWithoutOpenaiCredsInput[]
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutOpenaiCredsInput | OpenaiBotCreateOrConnectWithoutOpenaiCredsInput[]
    createMany?: OpenaiBotCreateManyOpenaiCredsInputEnvelope
    connect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
  }

  export type OpenaiSettingUncheckedCreateNestedOneWithoutOpenaiCredsInput = {
    create?: XOR<OpenaiSettingCreateWithoutOpenaiCredsInput, OpenaiSettingUncheckedCreateWithoutOpenaiCredsInput>
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutOpenaiCredsInput
    connect?: OpenaiSettingWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutOpenaiCredsNestedInput = {
    create?: XOR<InstanceCreateWithoutOpenaiCredsInput, InstanceUncheckedCreateWithoutOpenaiCredsInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutOpenaiCredsInput
    upsert?: InstanceUpsertWithoutOpenaiCredsInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutOpenaiCredsInput, InstanceUpdateWithoutOpenaiCredsInput>, InstanceUncheckedUpdateWithoutOpenaiCredsInput>
  }

  export type OpenaiBotUpdateManyWithoutOpenaiCredsNestedInput = {
    create?: XOR<OpenaiBotCreateWithoutOpenaiCredsInput, OpenaiBotUncheckedCreateWithoutOpenaiCredsInput> | OpenaiBotCreateWithoutOpenaiCredsInput[] | OpenaiBotUncheckedCreateWithoutOpenaiCredsInput[]
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutOpenaiCredsInput | OpenaiBotCreateOrConnectWithoutOpenaiCredsInput[]
    upsert?: OpenaiBotUpsertWithWhereUniqueWithoutOpenaiCredsInput | OpenaiBotUpsertWithWhereUniqueWithoutOpenaiCredsInput[]
    createMany?: OpenaiBotCreateManyOpenaiCredsInputEnvelope
    set?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    disconnect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    delete?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    connect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    update?: OpenaiBotUpdateWithWhereUniqueWithoutOpenaiCredsInput | OpenaiBotUpdateWithWhereUniqueWithoutOpenaiCredsInput[]
    updateMany?: OpenaiBotUpdateManyWithWhereWithoutOpenaiCredsInput | OpenaiBotUpdateManyWithWhereWithoutOpenaiCredsInput[]
    deleteMany?: OpenaiBotScalarWhereInput | OpenaiBotScalarWhereInput[]
  }

  export type OpenaiSettingUpdateOneWithoutOpenaiCredsNestedInput = {
    create?: XOR<OpenaiSettingCreateWithoutOpenaiCredsInput, OpenaiSettingUncheckedCreateWithoutOpenaiCredsInput>
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutOpenaiCredsInput
    upsert?: OpenaiSettingUpsertWithoutOpenaiCredsInput
    disconnect?: OpenaiSettingWhereInput | boolean
    delete?: OpenaiSettingWhereInput | boolean
    connect?: OpenaiSettingWhereUniqueInput
    update?: XOR<XOR<OpenaiSettingUpdateToOneWithWhereWithoutOpenaiCredsInput, OpenaiSettingUpdateWithoutOpenaiCredsInput>, OpenaiSettingUncheckedUpdateWithoutOpenaiCredsInput>
  }

  export type OpenaiBotUncheckedUpdateManyWithoutOpenaiCredsNestedInput = {
    create?: XOR<OpenaiBotCreateWithoutOpenaiCredsInput, OpenaiBotUncheckedCreateWithoutOpenaiCredsInput> | OpenaiBotCreateWithoutOpenaiCredsInput[] | OpenaiBotUncheckedCreateWithoutOpenaiCredsInput[]
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutOpenaiCredsInput | OpenaiBotCreateOrConnectWithoutOpenaiCredsInput[]
    upsert?: OpenaiBotUpsertWithWhereUniqueWithoutOpenaiCredsInput | OpenaiBotUpsertWithWhereUniqueWithoutOpenaiCredsInput[]
    createMany?: OpenaiBotCreateManyOpenaiCredsInputEnvelope
    set?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    disconnect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    delete?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    connect?: OpenaiBotWhereUniqueInput | OpenaiBotWhereUniqueInput[]
    update?: OpenaiBotUpdateWithWhereUniqueWithoutOpenaiCredsInput | OpenaiBotUpdateWithWhereUniqueWithoutOpenaiCredsInput[]
    updateMany?: OpenaiBotUpdateManyWithWhereWithoutOpenaiCredsInput | OpenaiBotUpdateManyWithWhereWithoutOpenaiCredsInput[]
    deleteMany?: OpenaiBotScalarWhereInput | OpenaiBotScalarWhereInput[]
  }

  export type OpenaiSettingUncheckedUpdateOneWithoutOpenaiCredsNestedInput = {
    create?: XOR<OpenaiSettingCreateWithoutOpenaiCredsInput, OpenaiSettingUncheckedCreateWithoutOpenaiCredsInput>
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutOpenaiCredsInput
    upsert?: OpenaiSettingUpsertWithoutOpenaiCredsInput
    disconnect?: OpenaiSettingWhereInput | boolean
    delete?: OpenaiSettingWhereInput | boolean
    connect?: OpenaiSettingWhereUniqueInput
    update?: XOR<XOR<OpenaiSettingUpdateToOneWithWhereWithoutOpenaiCredsInput, OpenaiSettingUpdateWithoutOpenaiCredsInput>, OpenaiSettingUncheckedUpdateWithoutOpenaiCredsInput>
  }

  export type OpenaiCredsCreateNestedOneWithoutOpenaiAssistantInput = {
    create?: XOR<OpenaiCredsCreateWithoutOpenaiAssistantInput, OpenaiCredsUncheckedCreateWithoutOpenaiAssistantInput>
    connectOrCreate?: OpenaiCredsCreateOrConnectWithoutOpenaiAssistantInput
    connect?: OpenaiCredsWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutOpenaiBotInput = {
    create?: XOR<InstanceCreateWithoutOpenaiBotInput, InstanceUncheckedCreateWithoutOpenaiBotInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutOpenaiBotInput
    connect?: InstanceWhereUniqueInput
  }

  export type OpenaiSettingCreateNestedManyWithoutFallbackInput = {
    create?: XOR<OpenaiSettingCreateWithoutFallbackInput, OpenaiSettingUncheckedCreateWithoutFallbackInput> | OpenaiSettingCreateWithoutFallbackInput[] | OpenaiSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutFallbackInput | OpenaiSettingCreateOrConnectWithoutFallbackInput[]
    createMany?: OpenaiSettingCreateManyFallbackInputEnvelope
    connect?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
  }

  export type OpenaiSettingUncheckedCreateNestedManyWithoutFallbackInput = {
    create?: XOR<OpenaiSettingCreateWithoutFallbackInput, OpenaiSettingUncheckedCreateWithoutFallbackInput> | OpenaiSettingCreateWithoutFallbackInput[] | OpenaiSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutFallbackInput | OpenaiSettingCreateOrConnectWithoutFallbackInput[]
    createMany?: OpenaiSettingCreateManyFallbackInputEnvelope
    connect?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
  }

  export type EnumOpenaiBotTypeFieldUpdateOperationsInput = {
    set?: $Enums.OpenaiBotType
  }

  export type OpenaiCredsUpdateOneRequiredWithoutOpenaiAssistantNestedInput = {
    create?: XOR<OpenaiCredsCreateWithoutOpenaiAssistantInput, OpenaiCredsUncheckedCreateWithoutOpenaiAssistantInput>
    connectOrCreate?: OpenaiCredsCreateOrConnectWithoutOpenaiAssistantInput
    upsert?: OpenaiCredsUpsertWithoutOpenaiAssistantInput
    connect?: OpenaiCredsWhereUniqueInput
    update?: XOR<XOR<OpenaiCredsUpdateToOneWithWhereWithoutOpenaiAssistantInput, OpenaiCredsUpdateWithoutOpenaiAssistantInput>, OpenaiCredsUncheckedUpdateWithoutOpenaiAssistantInput>
  }

  export type InstanceUpdateOneRequiredWithoutOpenaiBotNestedInput = {
    create?: XOR<InstanceCreateWithoutOpenaiBotInput, InstanceUncheckedCreateWithoutOpenaiBotInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutOpenaiBotInput
    upsert?: InstanceUpsertWithoutOpenaiBotInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutOpenaiBotInput, InstanceUpdateWithoutOpenaiBotInput>, InstanceUncheckedUpdateWithoutOpenaiBotInput>
  }

  export type OpenaiSettingUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<OpenaiSettingCreateWithoutFallbackInput, OpenaiSettingUncheckedCreateWithoutFallbackInput> | OpenaiSettingCreateWithoutFallbackInput[] | OpenaiSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutFallbackInput | OpenaiSettingCreateOrConnectWithoutFallbackInput[]
    upsert?: OpenaiSettingUpsertWithWhereUniqueWithoutFallbackInput | OpenaiSettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: OpenaiSettingCreateManyFallbackInputEnvelope
    set?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
    disconnect?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
    delete?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
    connect?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
    update?: OpenaiSettingUpdateWithWhereUniqueWithoutFallbackInput | OpenaiSettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: OpenaiSettingUpdateManyWithWhereWithoutFallbackInput | OpenaiSettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: OpenaiSettingScalarWhereInput | OpenaiSettingScalarWhereInput[]
  }

  export type OpenaiSettingUncheckedUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<OpenaiSettingCreateWithoutFallbackInput, OpenaiSettingUncheckedCreateWithoutFallbackInput> | OpenaiSettingCreateWithoutFallbackInput[] | OpenaiSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: OpenaiSettingCreateOrConnectWithoutFallbackInput | OpenaiSettingCreateOrConnectWithoutFallbackInput[]
    upsert?: OpenaiSettingUpsertWithWhereUniqueWithoutFallbackInput | OpenaiSettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: OpenaiSettingCreateManyFallbackInputEnvelope
    set?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
    disconnect?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
    delete?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
    connect?: OpenaiSettingWhereUniqueInput | OpenaiSettingWhereUniqueInput[]
    update?: OpenaiSettingUpdateWithWhereUniqueWithoutFallbackInput | OpenaiSettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: OpenaiSettingUpdateManyWithWhereWithoutFallbackInput | OpenaiSettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: OpenaiSettingScalarWhereInput | OpenaiSettingScalarWhereInput[]
  }

  export type OpenaiCredsCreateNestedOneWithoutOpenaiSettingInput = {
    create?: XOR<OpenaiCredsCreateWithoutOpenaiSettingInput, OpenaiCredsUncheckedCreateWithoutOpenaiSettingInput>
    connectOrCreate?: OpenaiCredsCreateOrConnectWithoutOpenaiSettingInput
    connect?: OpenaiCredsWhereUniqueInput
  }

  export type OpenaiBotCreateNestedOneWithoutOpenaiSettingInput = {
    create?: XOR<OpenaiBotCreateWithoutOpenaiSettingInput, OpenaiBotUncheckedCreateWithoutOpenaiSettingInput>
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutOpenaiSettingInput
    connect?: OpenaiBotWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutOpenaiSettingInput = {
    create?: XOR<InstanceCreateWithoutOpenaiSettingInput, InstanceUncheckedCreateWithoutOpenaiSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutOpenaiSettingInput
    connect?: InstanceWhereUniqueInput
  }

  export type OpenaiCredsUpdateOneWithoutOpenaiSettingNestedInput = {
    create?: XOR<OpenaiCredsCreateWithoutOpenaiSettingInput, OpenaiCredsUncheckedCreateWithoutOpenaiSettingInput>
    connectOrCreate?: OpenaiCredsCreateOrConnectWithoutOpenaiSettingInput
    upsert?: OpenaiCredsUpsertWithoutOpenaiSettingInput
    disconnect?: OpenaiCredsWhereInput | boolean
    delete?: OpenaiCredsWhereInput | boolean
    connect?: OpenaiCredsWhereUniqueInput
    update?: XOR<XOR<OpenaiCredsUpdateToOneWithWhereWithoutOpenaiSettingInput, OpenaiCredsUpdateWithoutOpenaiSettingInput>, OpenaiCredsUncheckedUpdateWithoutOpenaiSettingInput>
  }

  export type OpenaiBotUpdateOneWithoutOpenaiSettingNestedInput = {
    create?: XOR<OpenaiBotCreateWithoutOpenaiSettingInput, OpenaiBotUncheckedCreateWithoutOpenaiSettingInput>
    connectOrCreate?: OpenaiBotCreateOrConnectWithoutOpenaiSettingInput
    upsert?: OpenaiBotUpsertWithoutOpenaiSettingInput
    disconnect?: OpenaiBotWhereInput | boolean
    delete?: OpenaiBotWhereInput | boolean
    connect?: OpenaiBotWhereUniqueInput
    update?: XOR<XOR<OpenaiBotUpdateToOneWithWhereWithoutOpenaiSettingInput, OpenaiBotUpdateWithoutOpenaiSettingInput>, OpenaiBotUncheckedUpdateWithoutOpenaiSettingInput>
  }

  export type InstanceUpdateOneRequiredWithoutOpenaiSettingNestedInput = {
    create?: XOR<InstanceCreateWithoutOpenaiSettingInput, InstanceUncheckedCreateWithoutOpenaiSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutOpenaiSettingInput
    upsert?: InstanceUpsertWithoutOpenaiSettingInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutOpenaiSettingInput, InstanceUpdateWithoutOpenaiSettingInput>, InstanceUncheckedUpdateWithoutOpenaiSettingInput>
  }

  export type InstanceCreateNestedOneWithoutTemplateInput = {
    create?: XOR<InstanceCreateWithoutTemplateInput, InstanceUncheckedCreateWithoutTemplateInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTemplateInput
    connect?: InstanceWhereUniqueInput
  }

  export type InstanceUpdateOneRequiredWithoutTemplateNestedInput = {
    create?: XOR<InstanceCreateWithoutTemplateInput, InstanceUncheckedCreateWithoutTemplateInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutTemplateInput
    upsert?: InstanceUpsertWithoutTemplateInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutTemplateInput, InstanceUpdateWithoutTemplateInput>, InstanceUncheckedUpdateWithoutTemplateInput>
  }

  export type InstanceCreateNestedOneWithoutDifyInput = {
    create?: XOR<InstanceCreateWithoutDifyInput, InstanceUncheckedCreateWithoutDifyInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDifyInput
    connect?: InstanceWhereUniqueInput
  }

  export type DifySettingCreateNestedManyWithoutFallbackInput = {
    create?: XOR<DifySettingCreateWithoutFallbackInput, DifySettingUncheckedCreateWithoutFallbackInput> | DifySettingCreateWithoutFallbackInput[] | DifySettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: DifySettingCreateOrConnectWithoutFallbackInput | DifySettingCreateOrConnectWithoutFallbackInput[]
    createMany?: DifySettingCreateManyFallbackInputEnvelope
    connect?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
  }

  export type DifySettingUncheckedCreateNestedManyWithoutFallbackInput = {
    create?: XOR<DifySettingCreateWithoutFallbackInput, DifySettingUncheckedCreateWithoutFallbackInput> | DifySettingCreateWithoutFallbackInput[] | DifySettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: DifySettingCreateOrConnectWithoutFallbackInput | DifySettingCreateOrConnectWithoutFallbackInput[]
    createMany?: DifySettingCreateManyFallbackInputEnvelope
    connect?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
  }

  export type EnumDifyBotTypeFieldUpdateOperationsInput = {
    set?: $Enums.DifyBotType
  }

  export type InstanceUpdateOneRequiredWithoutDifyNestedInput = {
    create?: XOR<InstanceCreateWithoutDifyInput, InstanceUncheckedCreateWithoutDifyInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDifyInput
    upsert?: InstanceUpsertWithoutDifyInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutDifyInput, InstanceUpdateWithoutDifyInput>, InstanceUncheckedUpdateWithoutDifyInput>
  }

  export type DifySettingUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<DifySettingCreateWithoutFallbackInput, DifySettingUncheckedCreateWithoutFallbackInput> | DifySettingCreateWithoutFallbackInput[] | DifySettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: DifySettingCreateOrConnectWithoutFallbackInput | DifySettingCreateOrConnectWithoutFallbackInput[]
    upsert?: DifySettingUpsertWithWhereUniqueWithoutFallbackInput | DifySettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: DifySettingCreateManyFallbackInputEnvelope
    set?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
    disconnect?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
    delete?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
    connect?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
    update?: DifySettingUpdateWithWhereUniqueWithoutFallbackInput | DifySettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: DifySettingUpdateManyWithWhereWithoutFallbackInput | DifySettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: DifySettingScalarWhereInput | DifySettingScalarWhereInput[]
  }

  export type DifySettingUncheckedUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<DifySettingCreateWithoutFallbackInput, DifySettingUncheckedCreateWithoutFallbackInput> | DifySettingCreateWithoutFallbackInput[] | DifySettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: DifySettingCreateOrConnectWithoutFallbackInput | DifySettingCreateOrConnectWithoutFallbackInput[]
    upsert?: DifySettingUpsertWithWhereUniqueWithoutFallbackInput | DifySettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: DifySettingCreateManyFallbackInputEnvelope
    set?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
    disconnect?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
    delete?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
    connect?: DifySettingWhereUniqueInput | DifySettingWhereUniqueInput[]
    update?: DifySettingUpdateWithWhereUniqueWithoutFallbackInput | DifySettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: DifySettingUpdateManyWithWhereWithoutFallbackInput | DifySettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: DifySettingScalarWhereInput | DifySettingScalarWhereInput[]
  }

  export type DifyCreateNestedOneWithoutDifySettingInput = {
    create?: XOR<DifyCreateWithoutDifySettingInput, DifyUncheckedCreateWithoutDifySettingInput>
    connectOrCreate?: DifyCreateOrConnectWithoutDifySettingInput
    connect?: DifyWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutDifySettingInput = {
    create?: XOR<InstanceCreateWithoutDifySettingInput, InstanceUncheckedCreateWithoutDifySettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDifySettingInput
    connect?: InstanceWhereUniqueInput
  }

  export type DifyUpdateOneWithoutDifySettingNestedInput = {
    create?: XOR<DifyCreateWithoutDifySettingInput, DifyUncheckedCreateWithoutDifySettingInput>
    connectOrCreate?: DifyCreateOrConnectWithoutDifySettingInput
    upsert?: DifyUpsertWithoutDifySettingInput
    disconnect?: DifyWhereInput | boolean
    delete?: DifyWhereInput | boolean
    connect?: DifyWhereUniqueInput
    update?: XOR<XOR<DifyUpdateToOneWithWhereWithoutDifySettingInput, DifyUpdateWithoutDifySettingInput>, DifyUncheckedUpdateWithoutDifySettingInput>
  }

  export type InstanceUpdateOneRequiredWithoutDifySettingNestedInput = {
    create?: XOR<InstanceCreateWithoutDifySettingInput, InstanceUncheckedCreateWithoutDifySettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutDifySettingInput
    upsert?: InstanceUpsertWithoutDifySettingInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutDifySettingInput, InstanceUpdateWithoutDifySettingInput>, InstanceUncheckedUpdateWithoutDifySettingInput>
  }

  export type InstanceCreateNestedOneWithoutEvolutionBotInput = {
    create?: XOR<InstanceCreateWithoutEvolutionBotInput, InstanceUncheckedCreateWithoutEvolutionBotInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutEvolutionBotInput
    connect?: InstanceWhereUniqueInput
  }

  export type EvolutionBotSettingCreateNestedManyWithoutFallbackInput = {
    create?: XOR<EvolutionBotSettingCreateWithoutFallbackInput, EvolutionBotSettingUncheckedCreateWithoutFallbackInput> | EvolutionBotSettingCreateWithoutFallbackInput[] | EvolutionBotSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: EvolutionBotSettingCreateOrConnectWithoutFallbackInput | EvolutionBotSettingCreateOrConnectWithoutFallbackInput[]
    createMany?: EvolutionBotSettingCreateManyFallbackInputEnvelope
    connect?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
  }

  export type EvolutionBotSettingUncheckedCreateNestedManyWithoutFallbackInput = {
    create?: XOR<EvolutionBotSettingCreateWithoutFallbackInput, EvolutionBotSettingUncheckedCreateWithoutFallbackInput> | EvolutionBotSettingCreateWithoutFallbackInput[] | EvolutionBotSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: EvolutionBotSettingCreateOrConnectWithoutFallbackInput | EvolutionBotSettingCreateOrConnectWithoutFallbackInput[]
    createMany?: EvolutionBotSettingCreateManyFallbackInputEnvelope
    connect?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutEvolutionBotNestedInput = {
    create?: XOR<InstanceCreateWithoutEvolutionBotInput, InstanceUncheckedCreateWithoutEvolutionBotInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutEvolutionBotInput
    upsert?: InstanceUpsertWithoutEvolutionBotInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutEvolutionBotInput, InstanceUpdateWithoutEvolutionBotInput>, InstanceUncheckedUpdateWithoutEvolutionBotInput>
  }

  export type EvolutionBotSettingUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<EvolutionBotSettingCreateWithoutFallbackInput, EvolutionBotSettingUncheckedCreateWithoutFallbackInput> | EvolutionBotSettingCreateWithoutFallbackInput[] | EvolutionBotSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: EvolutionBotSettingCreateOrConnectWithoutFallbackInput | EvolutionBotSettingCreateOrConnectWithoutFallbackInput[]
    upsert?: EvolutionBotSettingUpsertWithWhereUniqueWithoutFallbackInput | EvolutionBotSettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: EvolutionBotSettingCreateManyFallbackInputEnvelope
    set?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
    disconnect?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
    delete?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
    connect?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
    update?: EvolutionBotSettingUpdateWithWhereUniqueWithoutFallbackInput | EvolutionBotSettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: EvolutionBotSettingUpdateManyWithWhereWithoutFallbackInput | EvolutionBotSettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: EvolutionBotSettingScalarWhereInput | EvolutionBotSettingScalarWhereInput[]
  }

  export type EvolutionBotSettingUncheckedUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<EvolutionBotSettingCreateWithoutFallbackInput, EvolutionBotSettingUncheckedCreateWithoutFallbackInput> | EvolutionBotSettingCreateWithoutFallbackInput[] | EvolutionBotSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: EvolutionBotSettingCreateOrConnectWithoutFallbackInput | EvolutionBotSettingCreateOrConnectWithoutFallbackInput[]
    upsert?: EvolutionBotSettingUpsertWithWhereUniqueWithoutFallbackInput | EvolutionBotSettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: EvolutionBotSettingCreateManyFallbackInputEnvelope
    set?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
    disconnect?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
    delete?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
    connect?: EvolutionBotSettingWhereUniqueInput | EvolutionBotSettingWhereUniqueInput[]
    update?: EvolutionBotSettingUpdateWithWhereUniqueWithoutFallbackInput | EvolutionBotSettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: EvolutionBotSettingUpdateManyWithWhereWithoutFallbackInput | EvolutionBotSettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: EvolutionBotSettingScalarWhereInput | EvolutionBotSettingScalarWhereInput[]
  }

  export type EvolutionBotCreateNestedOneWithoutEvolutionBotSettingInput = {
    create?: XOR<EvolutionBotCreateWithoutEvolutionBotSettingInput, EvolutionBotUncheckedCreateWithoutEvolutionBotSettingInput>
    connectOrCreate?: EvolutionBotCreateOrConnectWithoutEvolutionBotSettingInput
    connect?: EvolutionBotWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutEvolutionBotSettingInput = {
    create?: XOR<InstanceCreateWithoutEvolutionBotSettingInput, InstanceUncheckedCreateWithoutEvolutionBotSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutEvolutionBotSettingInput
    connect?: InstanceWhereUniqueInput
  }

  export type EvolutionBotUpdateOneWithoutEvolutionBotSettingNestedInput = {
    create?: XOR<EvolutionBotCreateWithoutEvolutionBotSettingInput, EvolutionBotUncheckedCreateWithoutEvolutionBotSettingInput>
    connectOrCreate?: EvolutionBotCreateOrConnectWithoutEvolutionBotSettingInput
    upsert?: EvolutionBotUpsertWithoutEvolutionBotSettingInput
    disconnect?: EvolutionBotWhereInput | boolean
    delete?: EvolutionBotWhereInput | boolean
    connect?: EvolutionBotWhereUniqueInput
    update?: XOR<XOR<EvolutionBotUpdateToOneWithWhereWithoutEvolutionBotSettingInput, EvolutionBotUpdateWithoutEvolutionBotSettingInput>, EvolutionBotUncheckedUpdateWithoutEvolutionBotSettingInput>
  }

  export type InstanceUpdateOneRequiredWithoutEvolutionBotSettingNestedInput = {
    create?: XOR<InstanceCreateWithoutEvolutionBotSettingInput, InstanceUncheckedCreateWithoutEvolutionBotSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutEvolutionBotSettingInput
    upsert?: InstanceUpsertWithoutEvolutionBotSettingInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutEvolutionBotSettingInput, InstanceUpdateWithoutEvolutionBotSettingInput>, InstanceUncheckedUpdateWithoutEvolutionBotSettingInput>
  }

  export type InstanceCreateNestedOneWithoutFlowiseInput = {
    create?: XOR<InstanceCreateWithoutFlowiseInput, InstanceUncheckedCreateWithoutFlowiseInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutFlowiseInput
    connect?: InstanceWhereUniqueInput
  }

  export type FlowiseSettingCreateNestedManyWithoutFallbackInput = {
    create?: XOR<FlowiseSettingCreateWithoutFallbackInput, FlowiseSettingUncheckedCreateWithoutFallbackInput> | FlowiseSettingCreateWithoutFallbackInput[] | FlowiseSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: FlowiseSettingCreateOrConnectWithoutFallbackInput | FlowiseSettingCreateOrConnectWithoutFallbackInput[]
    createMany?: FlowiseSettingCreateManyFallbackInputEnvelope
    connect?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
  }

  export type FlowiseSettingUncheckedCreateNestedManyWithoutFallbackInput = {
    create?: XOR<FlowiseSettingCreateWithoutFallbackInput, FlowiseSettingUncheckedCreateWithoutFallbackInput> | FlowiseSettingCreateWithoutFallbackInput[] | FlowiseSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: FlowiseSettingCreateOrConnectWithoutFallbackInput | FlowiseSettingCreateOrConnectWithoutFallbackInput[]
    createMany?: FlowiseSettingCreateManyFallbackInputEnvelope
    connect?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
  }

  export type InstanceUpdateOneRequiredWithoutFlowiseNestedInput = {
    create?: XOR<InstanceCreateWithoutFlowiseInput, InstanceUncheckedCreateWithoutFlowiseInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutFlowiseInput
    upsert?: InstanceUpsertWithoutFlowiseInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutFlowiseInput, InstanceUpdateWithoutFlowiseInput>, InstanceUncheckedUpdateWithoutFlowiseInput>
  }

  export type FlowiseSettingUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<FlowiseSettingCreateWithoutFallbackInput, FlowiseSettingUncheckedCreateWithoutFallbackInput> | FlowiseSettingCreateWithoutFallbackInput[] | FlowiseSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: FlowiseSettingCreateOrConnectWithoutFallbackInput | FlowiseSettingCreateOrConnectWithoutFallbackInput[]
    upsert?: FlowiseSettingUpsertWithWhereUniqueWithoutFallbackInput | FlowiseSettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: FlowiseSettingCreateManyFallbackInputEnvelope
    set?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
    disconnect?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
    delete?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
    connect?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
    update?: FlowiseSettingUpdateWithWhereUniqueWithoutFallbackInput | FlowiseSettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: FlowiseSettingUpdateManyWithWhereWithoutFallbackInput | FlowiseSettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: FlowiseSettingScalarWhereInput | FlowiseSettingScalarWhereInput[]
  }

  export type FlowiseSettingUncheckedUpdateManyWithoutFallbackNestedInput = {
    create?: XOR<FlowiseSettingCreateWithoutFallbackInput, FlowiseSettingUncheckedCreateWithoutFallbackInput> | FlowiseSettingCreateWithoutFallbackInput[] | FlowiseSettingUncheckedCreateWithoutFallbackInput[]
    connectOrCreate?: FlowiseSettingCreateOrConnectWithoutFallbackInput | FlowiseSettingCreateOrConnectWithoutFallbackInput[]
    upsert?: FlowiseSettingUpsertWithWhereUniqueWithoutFallbackInput | FlowiseSettingUpsertWithWhereUniqueWithoutFallbackInput[]
    createMany?: FlowiseSettingCreateManyFallbackInputEnvelope
    set?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
    disconnect?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
    delete?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
    connect?: FlowiseSettingWhereUniqueInput | FlowiseSettingWhereUniqueInput[]
    update?: FlowiseSettingUpdateWithWhereUniqueWithoutFallbackInput | FlowiseSettingUpdateWithWhereUniqueWithoutFallbackInput[]
    updateMany?: FlowiseSettingUpdateManyWithWhereWithoutFallbackInput | FlowiseSettingUpdateManyWithWhereWithoutFallbackInput[]
    deleteMany?: FlowiseSettingScalarWhereInput | FlowiseSettingScalarWhereInput[]
  }

  export type FlowiseCreateNestedOneWithoutFlowiseSettingInput = {
    create?: XOR<FlowiseCreateWithoutFlowiseSettingInput, FlowiseUncheckedCreateWithoutFlowiseSettingInput>
    connectOrCreate?: FlowiseCreateOrConnectWithoutFlowiseSettingInput
    connect?: FlowiseWhereUniqueInput
  }

  export type InstanceCreateNestedOneWithoutFlowiseSettingInput = {
    create?: XOR<InstanceCreateWithoutFlowiseSettingInput, InstanceUncheckedCreateWithoutFlowiseSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutFlowiseSettingInput
    connect?: InstanceWhereUniqueInput
  }

  export type FlowiseUpdateOneWithoutFlowiseSettingNestedInput = {
    create?: XOR<FlowiseCreateWithoutFlowiseSettingInput, FlowiseUncheckedCreateWithoutFlowiseSettingInput>
    connectOrCreate?: FlowiseCreateOrConnectWithoutFlowiseSettingInput
    upsert?: FlowiseUpsertWithoutFlowiseSettingInput
    disconnect?: FlowiseWhereInput | boolean
    delete?: FlowiseWhereInput | boolean
    connect?: FlowiseWhereUniqueInput
    update?: XOR<XOR<FlowiseUpdateToOneWithWhereWithoutFlowiseSettingInput, FlowiseUpdateWithoutFlowiseSettingInput>, FlowiseUncheckedUpdateWithoutFlowiseSettingInput>
  }

  export type InstanceUpdateOneRequiredWithoutFlowiseSettingNestedInput = {
    create?: XOR<InstanceCreateWithoutFlowiseSettingInput, InstanceUncheckedCreateWithoutFlowiseSettingInput>
    connectOrCreate?: InstanceCreateOrConnectWithoutFlowiseSettingInput
    upsert?: InstanceUpsertWithoutFlowiseSettingInput
    connect?: InstanceWhereUniqueInput
    update?: XOR<XOR<InstanceUpdateToOneWithWhereWithoutFlowiseSettingInput, InstanceUpdateWithoutFlowiseSettingInput>, InstanceUncheckedUpdateWithoutFlowiseSettingInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumInstanceConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstanceConnectionStatus | EnumInstanceConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstanceConnectionStatus[]
    notIn?: $Enums.InstanceConnectionStatus[]
    not?: NestedEnumInstanceConnectionStatusFilter<$PrismaModel> | $Enums.InstanceConnectionStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumInstanceConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstanceConnectionStatus | EnumInstanceConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstanceConnectionStatus[]
    notIn?: $Enums.InstanceConnectionStatus[]
    not?: NestedEnumInstanceConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstanceConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstanceConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumInstanceConnectionStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumDeviceMessageFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceMessage | EnumDeviceMessageFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceMessage[]
    notIn?: $Enums.DeviceMessage[]
    not?: NestedEnumDeviceMessageFilter<$PrismaModel> | $Enums.DeviceMessage
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDeviceMessageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceMessage | EnumDeviceMessageFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceMessage[]
    notIn?: $Enums.DeviceMessage[]
    not?: NestedEnumDeviceMessageWithAggregatesFilter<$PrismaModel> | $Enums.DeviceMessage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceMessageFilter<$PrismaModel>
    _max?: NestedEnumDeviceMessageFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTriggerTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerType[] | null
    notIn?: $Enums.TriggerType[] | null
    not?: NestedEnumTriggerTypeNullableFilter<$PrismaModel> | $Enums.TriggerType | null
  }

  export type NestedEnumTriggerOperatorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerOperator | EnumTriggerOperatorFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerOperator[] | null
    notIn?: $Enums.TriggerOperator[] | null
    not?: NestedEnumTriggerOperatorNullableFilter<$PrismaModel> | $Enums.TriggerOperator | null
  }

  export type NestedEnumTriggerTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerType | EnumTriggerTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerType[] | null
    notIn?: $Enums.TriggerType[] | null
    not?: NestedEnumTriggerTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.TriggerType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumTriggerOperatorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerOperator | EnumTriggerOperatorFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriggerOperator[] | null
    notIn?: $Enums.TriggerOperator[] | null
    not?: NestedEnumTriggerOperatorNullableWithAggregatesFilter<$PrismaModel> | $Enums.TriggerOperator | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTriggerOperatorNullableFilter<$PrismaModel>
    _max?: NestedEnumTriggerOperatorNullableFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[]
    notIn?: $Enums.SessionStatus[]
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[]
    notIn?: $Enums.SessionStatus[]
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumOpenaiBotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OpenaiBotType | EnumOpenaiBotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpenaiBotType[]
    notIn?: $Enums.OpenaiBotType[]
    not?: NestedEnumOpenaiBotTypeFilter<$PrismaModel> | $Enums.OpenaiBotType
  }

  export type NestedEnumOpenaiBotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OpenaiBotType | EnumOpenaiBotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OpenaiBotType[]
    notIn?: $Enums.OpenaiBotType[]
    not?: NestedEnumOpenaiBotTypeWithAggregatesFilter<$PrismaModel> | $Enums.OpenaiBotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOpenaiBotTypeFilter<$PrismaModel>
    _max?: NestedEnumOpenaiBotTypeFilter<$PrismaModel>
  }

  export type NestedEnumDifyBotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DifyBotType | EnumDifyBotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DifyBotType[]
    notIn?: $Enums.DifyBotType[]
    not?: NestedEnumDifyBotTypeFilter<$PrismaModel> | $Enums.DifyBotType
  }

  export type NestedEnumDifyBotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifyBotType | EnumDifyBotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DifyBotType[]
    notIn?: $Enums.DifyBotType[]
    not?: NestedEnumDifyBotTypeWithAggregatesFilter<$PrismaModel> | $Enums.DifyBotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifyBotTypeFilter<$PrismaModel>
    _max?: NestedEnumDifyBotTypeFilter<$PrismaModel>
  }

  export type ChatCreateWithoutInstanceInput = {
    id?: string
    remoteJid: string
    name?: string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    unreadMessages?: number
  }

  export type ChatUncheckedCreateWithoutInstanceInput = {
    id?: string
    remoteJid: string
    name?: string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    unreadMessages?: number
  }

  export type ChatCreateOrConnectWithoutInstanceInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutInstanceInput, ChatUncheckedCreateWithoutInstanceInput>
  }

  export type ChatCreateManyInstanceInputEnvelope = {
    data: ChatCreateManyInstanceInput | ChatCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutInstanceInput = {
    id?: string
    remoteJid: string
    pushName?: string | null
    profilePicUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContactUncheckedCreateWithoutInstanceInput = {
    id?: string
    remoteJid: string
    pushName?: string | null
    profilePicUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type ContactCreateOrConnectWithoutInstanceInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutInstanceInput, ContactUncheckedCreateWithoutInstanceInput>
  }

  export type ContactCreateManyInstanceInputEnvelope = {
    data: ContactCreateManyInstanceInput | ContactCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutInstanceInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutMessageInput
    Media?: MediaCreateNestedOneWithoutMessageInput
    session?: IntegrationSessionCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutInstanceInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    sessionId?: string | null
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutMessageInput
    Media?: MediaUncheckedCreateNestedOneWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutInstanceInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutInstanceInput, MessageUncheckedCreateWithoutInstanceInput>
  }

  export type MessageCreateManyInstanceInputEnvelope = {
    data: MessageCreateManyInstanceInput | MessageCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type WebhookCreateWithoutInstanceInput = {
    id?: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: boolean | null
    webhookBase64?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type WebhookUncheckedCreateWithoutInstanceInput = {
    id?: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: boolean | null
    webhookBase64?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type WebhookCreateOrConnectWithoutInstanceInput = {
    where: WebhookWhereUniqueInput
    create: XOR<WebhookCreateWithoutInstanceInput, WebhookUncheckedCreateWithoutInstanceInput>
  }

  export type ChatwootCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean | null
    accountId?: string | null
    token?: string | null
    url?: string | null
    nameInbox?: string | null
    signMsg?: boolean | null
    signDelimiter?: string | null
    number?: string | null
    reopenConversation?: boolean | null
    conversationPending?: boolean | null
    mergeBrazilContacts?: boolean | null
    importContacts?: boolean | null
    importMessages?: boolean | null
    daysLimitImportMessages?: number | null
    organization?: string | null
    logo?: string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ChatwootUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean | null
    accountId?: string | null
    token?: string | null
    url?: string | null
    nameInbox?: string | null
    signMsg?: boolean | null
    signDelimiter?: string | null
    number?: string | null
    reopenConversation?: boolean | null
    conversationPending?: boolean | null
    mergeBrazilContacts?: boolean | null
    importContacts?: boolean | null
    importMessages?: boolean | null
    daysLimitImportMessages?: number | null
    organization?: string | null
    logo?: string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ChatwootCreateOrConnectWithoutInstanceInput = {
    where: ChatwootWhereUniqueInput
    create: XOR<ChatwootCreateWithoutInstanceInput, ChatwootUncheckedCreateWithoutInstanceInput>
  }

  export type LabelCreateWithoutInstanceInput = {
    id?: string
    labelId?: string | null
    name: string
    color: string
    predefinedId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type LabelUncheckedCreateWithoutInstanceInput = {
    id?: string
    labelId?: string | null
    name: string
    color: string
    predefinedId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type LabelCreateOrConnectWithoutInstanceInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutInstanceInput, LabelUncheckedCreateWithoutInstanceInput>
  }

  export type LabelCreateManyInstanceInputEnvelope = {
    data: LabelCreateManyInstanceInput | LabelCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type ProxyCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    host: string
    port: string
    protocol: string
    username: string
    password: string
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ProxyUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    host: string
    port: string
    protocol: string
    username: string
    password: string
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ProxyCreateOrConnectWithoutInstanceInput = {
    where: ProxyWhereUniqueInput
    create: XOR<ProxyCreateWithoutInstanceInput, ProxyUncheckedCreateWithoutInstanceInput>
  }

  export type SettingCreateWithoutInstanceInput = {
    id?: string
    rejectCall?: boolean
    msgCall?: string | null
    groupsIgnore?: boolean
    alwaysOnline?: boolean
    readMessages?: boolean
    readStatus?: boolean
    syncFullHistory?: boolean
    wavoipToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateWithoutInstanceInput = {
    id?: string
    rejectCall?: boolean
    msgCall?: string | null
    groupsIgnore?: boolean
    alwaysOnline?: boolean
    readMessages?: boolean
    readStatus?: boolean
    syncFullHistory?: boolean
    wavoipToken?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type SettingCreateOrConnectWithoutInstanceInput = {
    where: SettingWhereUniqueInput
    create: XOR<SettingCreateWithoutInstanceInput, SettingUncheckedCreateWithoutInstanceInput>
  }

  export type RabbitmqCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type RabbitmqUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type RabbitmqCreateOrConnectWithoutInstanceInput = {
    where: RabbitmqWhereUniqueInput
    create: XOR<RabbitmqCreateWithoutInstanceInput, RabbitmqUncheckedCreateWithoutInstanceInput>
  }

  export type SqsCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type SqsUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type SqsCreateOrConnectWithoutInstanceInput = {
    where: SqsWhereUniqueInput
    create: XOR<SqsCreateWithoutInstanceInput, SqsUncheckedCreateWithoutInstanceInput>
  }

  export type WebsocketCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type WebsocketUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type WebsocketCreateOrConnectWithoutInstanceInput = {
    where: WebsocketWhereUniqueInput
    create: XOR<WebsocketCreateWithoutInstanceInput, WebsocketUncheckedCreateWithoutInstanceInput>
  }

  export type TypebotCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    url: string
    typebot: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    TypebotSetting?: TypebotSettingCreateNestedManyWithoutFallbackInput
  }

  export type TypebotUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    url: string
    typebot: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    TypebotSetting?: TypebotSettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type TypebotCreateOrConnectWithoutInstanceInput = {
    where: TypebotWhereUniqueInput
    create: XOR<TypebotCreateWithoutInstanceInput, TypebotUncheckedCreateWithoutInstanceInput>
  }

  export type TypebotCreateManyInstanceInputEnvelope = {
    data: TypebotCreateManyInstanceInput | TypebotCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutInstanceInput = {
    id?: string
    creds?: string | null
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutInstanceInput = {
    id?: string
    creds?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutInstanceInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutInstanceInput, SessionUncheckedCreateWithoutInstanceInput>
  }

  export type MessageUpdateCreateWithoutInstanceInput = {
    id?: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant?: string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status: string
    Message: MessageCreateNestedOneWithoutMessageUpdateInput
  }

  export type MessageUpdateUncheckedCreateWithoutInstanceInput = {
    id?: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant?: string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status: string
    messageId: string
  }

  export type MessageUpdateCreateOrConnectWithoutInstanceInput = {
    where: MessageUpdateWhereUniqueInput
    create: XOR<MessageUpdateCreateWithoutInstanceInput, MessageUpdateUncheckedCreateWithoutInstanceInput>
  }

  export type MessageUpdateCreateManyInstanceInputEnvelope = {
    data: MessageUpdateCreateManyInstanceInput | MessageUpdateCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type TypebotSettingCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Fallback?: TypebotCreateNestedOneWithoutTypebotSettingInput
  }

  export type TypebotSettingUncheckedCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    typebotIdFallback?: string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TypebotSettingCreateOrConnectWithoutInstanceInput = {
    where: TypebotSettingWhereUniqueInput
    create: XOR<TypebotSettingCreateWithoutInstanceInput, TypebotSettingUncheckedCreateWithoutInstanceInput>
  }

  export type MediaCreateWithoutInstanceInput = {
    id?: string
    fileName: string
    type: string
    mimetype: string
    createdAt?: Date | string | null
    Message: MessageCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutInstanceInput = {
    id?: string
    fileName: string
    type: string
    mimetype: string
    createdAt?: Date | string | null
    messageId: string
  }

  export type MediaCreateOrConnectWithoutInstanceInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutInstanceInput, MediaUncheckedCreateWithoutInstanceInput>
  }

  export type MediaCreateManyInstanceInputEnvelope = {
    data: MediaCreateManyInstanceInput | MediaCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type OpenaiCredsCreateWithoutInstanceInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    OpenaiAssistant?: OpenaiBotCreateNestedManyWithoutOpenaiCredsInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutOpenaiCredsInput
  }

  export type OpenaiCredsUncheckedCreateWithoutInstanceInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    OpenaiAssistant?: OpenaiBotUncheckedCreateNestedManyWithoutOpenaiCredsInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutOpenaiCredsInput
  }

  export type OpenaiCredsCreateOrConnectWithoutInstanceInput = {
    where: OpenaiCredsWhereUniqueInput
    create: XOR<OpenaiCredsCreateWithoutInstanceInput, OpenaiCredsUncheckedCreateWithoutInstanceInput>
  }

  export type OpenaiCredsCreateManyInstanceInputEnvelope = {
    data: OpenaiCredsCreateManyInstanceInput | OpenaiCredsCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type OpenaiBotCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    OpenaiCreds: OpenaiCredsCreateNestedOneWithoutOpenaiAssistantInput
    OpenaiSetting?: OpenaiSettingCreateNestedManyWithoutFallbackInput
  }

  export type OpenaiBotUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type OpenaiBotCreateOrConnectWithoutInstanceInput = {
    where: OpenaiBotWhereUniqueInput
    create: XOR<OpenaiBotCreateWithoutInstanceInput, OpenaiBotUncheckedCreateWithoutInstanceInput>
  }

  export type OpenaiBotCreateManyInstanceInputEnvelope = {
    data: OpenaiBotCreateManyInstanceInput | OpenaiBotCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type OpenaiSettingCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    OpenaiCreds?: OpenaiCredsCreateNestedOneWithoutOpenaiSettingInput
    Fallback?: OpenaiBotCreateNestedOneWithoutOpenaiSettingInput
  }

  export type OpenaiSettingUncheckedCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
    openaiIdFallback?: string | null
  }

  export type OpenaiSettingCreateOrConnectWithoutInstanceInput = {
    where: OpenaiSettingWhereUniqueInput
    create: XOR<OpenaiSettingCreateWithoutInstanceInput, OpenaiSettingUncheckedCreateWithoutInstanceInput>
  }

  export type TemplateCreateWithoutInstanceInput = {
    id?: string
    templateId: string
    name: string
    template: JsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TemplateUncheckedCreateWithoutInstanceInput = {
    id?: string
    templateId: string
    name: string
    template: JsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TemplateCreateOrConnectWithoutInstanceInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutInstanceInput, TemplateUncheckedCreateWithoutInstanceInput>
  }

  export type TemplateCreateManyInstanceInputEnvelope = {
    data: TemplateCreateManyInstanceInput | TemplateCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type DifyCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.DifyBotType
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    DifySetting?: DifySettingCreateNestedManyWithoutFallbackInput
  }

  export type DifyUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.DifyBotType
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    DifySetting?: DifySettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type DifyCreateOrConnectWithoutInstanceInput = {
    where: DifyWhereUniqueInput
    create: XOR<DifyCreateWithoutInstanceInput, DifyUncheckedCreateWithoutInstanceInput>
  }

  export type DifyCreateManyInstanceInputEnvelope = {
    data: DifyCreateManyInstanceInput | DifyCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type DifySettingCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Fallback?: DifyCreateNestedOneWithoutDifySettingInput
  }

  export type DifySettingUncheckedCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    difyIdFallback?: string | null
  }

  export type DifySettingCreateOrConnectWithoutInstanceInput = {
    where: DifySettingWhereUniqueInput
    create: XOR<DifySettingCreateWithoutInstanceInput, DifySettingUncheckedCreateWithoutInstanceInput>
  }

  export type IntegrationSessionCreateWithoutInstanceInput = {
    id?: string
    sessionId: string
    remoteJid: string
    pushName?: string | null
    status: $Enums.SessionStatus
    awaitUser?: boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: string | null
    Message?: MessageCreateNestedManyWithoutSessionInput
  }

  export type IntegrationSessionUncheckedCreateWithoutInstanceInput = {
    id?: string
    sessionId: string
    remoteJid: string
    pushName?: string | null
    status: $Enums.SessionStatus
    awaitUser?: boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: string | null
    Message?: MessageUncheckedCreateNestedManyWithoutSessionInput
  }

  export type IntegrationSessionCreateOrConnectWithoutInstanceInput = {
    where: IntegrationSessionWhereUniqueInput
    create: XOR<IntegrationSessionCreateWithoutInstanceInput, IntegrationSessionUncheckedCreateWithoutInstanceInput>
  }

  export type IntegrationSessionCreateManyInstanceInputEnvelope = {
    data: IntegrationSessionCreateManyInstanceInput | IntegrationSessionCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type EvolutionBotCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedManyWithoutFallbackInput
  }

  export type EvolutionBotUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type EvolutionBotCreateOrConnectWithoutInstanceInput = {
    where: EvolutionBotWhereUniqueInput
    create: XOR<EvolutionBotCreateWithoutInstanceInput, EvolutionBotUncheckedCreateWithoutInstanceInput>
  }

  export type EvolutionBotCreateManyInstanceInputEnvelope = {
    data: EvolutionBotCreateManyInstanceInput | EvolutionBotCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type EvolutionBotSettingCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Fallback?: EvolutionBotCreateNestedOneWithoutEvolutionBotSettingInput
  }

  export type EvolutionBotSettingUncheckedCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    botIdFallback?: string | null
  }

  export type EvolutionBotSettingCreateOrConnectWithoutInstanceInput = {
    where: EvolutionBotSettingWhereUniqueInput
    create: XOR<EvolutionBotSettingCreateWithoutInstanceInput, EvolutionBotSettingUncheckedCreateWithoutInstanceInput>
  }

  export type FlowiseCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    FlowiseSetting?: FlowiseSettingCreateNestedManyWithoutFallbackInput
  }

  export type FlowiseUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type FlowiseCreateOrConnectWithoutInstanceInput = {
    where: FlowiseWhereUniqueInput
    create: XOR<FlowiseCreateWithoutInstanceInput, FlowiseUncheckedCreateWithoutInstanceInput>
  }

  export type FlowiseCreateManyInstanceInputEnvelope = {
    data: FlowiseCreateManyInstanceInput | FlowiseCreateManyInstanceInput[]
    skipDuplicates?: boolean
  }

  export type FlowiseSettingCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Fallback?: FlowiseCreateNestedOneWithoutFlowiseSettingInput
  }

  export type FlowiseSettingUncheckedCreateWithoutInstanceInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    flowiseIdFallback?: string | null
  }

  export type FlowiseSettingCreateOrConnectWithoutInstanceInput = {
    where: FlowiseSettingWhereUniqueInput
    create: XOR<FlowiseSettingCreateWithoutInstanceInput, FlowiseSettingUncheckedCreateWithoutInstanceInput>
  }

  export type PusherCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    appId: string
    key: string
    secret: string
    cluster: string
    useTLS?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type PusherUncheckedCreateWithoutInstanceInput = {
    id?: string
    enabled?: boolean
    appId: string
    key: string
    secret: string
    cluster: string
    useTLS?: boolean
    events: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type PusherCreateOrConnectWithoutInstanceInput = {
    where: PusherWhereUniqueInput
    create: XOR<PusherCreateWithoutInstanceInput, PusherUncheckedCreateWithoutInstanceInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutInstanceInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutInstanceInput, ChatUncheckedUpdateWithoutInstanceInput>
    create: XOR<ChatCreateWithoutInstanceInput, ChatUncheckedCreateWithoutInstanceInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutInstanceInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutInstanceInput, ChatUncheckedUpdateWithoutInstanceInput>
  }

  export type ChatUpdateManyWithWhereWithoutInstanceInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutInstanceInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    remoteJid?: StringFilter<"Chat"> | string
    name?: StringNullableFilter<"Chat"> | string | null
    labels?: JsonNullableFilter<"Chat">
    createdAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    instanceId?: StringFilter<"Chat"> | string
    unreadMessages?: IntFilter<"Chat"> | number
  }

  export type ContactUpsertWithWhereUniqueWithoutInstanceInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutInstanceInput, ContactUncheckedUpdateWithoutInstanceInput>
    create: XOR<ContactCreateWithoutInstanceInput, ContactUncheckedCreateWithoutInstanceInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutInstanceInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutInstanceInput, ContactUncheckedUpdateWithoutInstanceInput>
  }

  export type ContactUpdateManyWithWhereWithoutInstanceInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutInstanceInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    remoteJid?: StringFilter<"Contact"> | string
    pushName?: StringNullableFilter<"Contact"> | string | null
    profilePicUrl?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    instanceId?: StringFilter<"Contact"> | string
  }

  export type MessageUpsertWithWhereUniqueWithoutInstanceInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutInstanceInput, MessageUncheckedUpdateWithoutInstanceInput>
    create: XOR<MessageCreateWithoutInstanceInput, MessageUncheckedCreateWithoutInstanceInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutInstanceInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutInstanceInput, MessageUncheckedUpdateWithoutInstanceInput>
  }

  export type MessageUpdateManyWithWhereWithoutInstanceInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutInstanceInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    key?: JsonFilter<"Message">
    pushName?: StringNullableFilter<"Message"> | string | null
    participant?: StringNullableFilter<"Message"> | string | null
    messageType?: StringFilter<"Message"> | string
    message?: JsonFilter<"Message">
    contextInfo?: JsonNullableFilter<"Message">
    source?: EnumDeviceMessageFilter<"Message"> | $Enums.DeviceMessage
    messageTimestamp?: IntFilter<"Message"> | number
    chatwootMessageId?: IntNullableFilter<"Message"> | number | null
    chatwootInboxId?: IntNullableFilter<"Message"> | number | null
    chatwootConversationId?: IntNullableFilter<"Message"> | number | null
    chatwootContactInboxSourceId?: StringNullableFilter<"Message"> | string | null
    chatwootIsRead?: BoolNullableFilter<"Message"> | boolean | null
    instanceId?: StringFilter<"Message"> | string
    typebotSessionId?: StringNullableFilter<"Message"> | string | null
    webhookUrl?: StringNullableFilter<"Message"> | string | null
    status?: StringNullableFilter<"Message"> | string | null
    sessionId?: StringNullableFilter<"Message"> | string | null
  }

  export type WebhookUpsertWithoutInstanceInput = {
    update: XOR<WebhookUpdateWithoutInstanceInput, WebhookUncheckedUpdateWithoutInstanceInput>
    create: XOR<WebhookCreateWithoutInstanceInput, WebhookUncheckedCreateWithoutInstanceInput>
    where?: WebhookWhereInput
  }

  export type WebhookUpdateToOneWithWhereWithoutInstanceInput = {
    where?: WebhookWhereInput
    data: XOR<WebhookUpdateWithoutInstanceInput, WebhookUncheckedUpdateWithoutInstanceInput>
  }

  export type WebhookUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    webhookBase64?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    events?: NullableJsonNullValueInput | InputJsonValue
    webhookByEvents?: NullableBoolFieldUpdateOperationsInput | boolean | null
    webhookBase64?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatwootUpsertWithoutInstanceInput = {
    update: XOR<ChatwootUpdateWithoutInstanceInput, ChatwootUncheckedUpdateWithoutInstanceInput>
    create: XOR<ChatwootCreateWithoutInstanceInput, ChatwootUncheckedCreateWithoutInstanceInput>
    where?: ChatwootWhereInput
  }

  export type ChatwootUpdateToOneWithWhereWithoutInstanceInput = {
    where?: ChatwootWhereInput
    data: XOR<ChatwootUpdateWithoutInstanceInput, ChatwootUncheckedUpdateWithoutInstanceInput>
  }

  export type ChatwootUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    nameInbox?: NullableStringFieldUpdateOperationsInput | string | null
    signMsg?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signDelimiter?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    reopenConversation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversationPending?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mergeBrazilContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysLimitImportMessages?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatwootUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    nameInbox?: NullableStringFieldUpdateOperationsInput | string | null
    signMsg?: NullableBoolFieldUpdateOperationsInput | boolean | null
    signDelimiter?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    reopenConversation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    conversationPending?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mergeBrazilContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importContacts?: NullableBoolFieldUpdateOperationsInput | boolean | null
    importMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    daysLimitImportMessages?: NullableIntFieldUpdateOperationsInput | number | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUpsertWithWhereUniqueWithoutInstanceInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutInstanceInput, LabelUncheckedUpdateWithoutInstanceInput>
    create: XOR<LabelCreateWithoutInstanceInput, LabelUncheckedCreateWithoutInstanceInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutInstanceInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutInstanceInput, LabelUncheckedUpdateWithoutInstanceInput>
  }

  export type LabelUpdateManyWithWhereWithoutInstanceInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutInstanceInput>
  }

  export type LabelScalarWhereInput = {
    AND?: LabelScalarWhereInput | LabelScalarWhereInput[]
    OR?: LabelScalarWhereInput[]
    NOT?: LabelScalarWhereInput | LabelScalarWhereInput[]
    id?: StringFilter<"Label"> | string
    labelId?: StringNullableFilter<"Label"> | string | null
    name?: StringFilter<"Label"> | string
    color?: StringFilter<"Label"> | string
    predefinedId?: StringNullableFilter<"Label"> | string | null
    createdAt?: DateTimeNullableFilter<"Label"> | Date | string | null
    updatedAt?: DateTimeFilter<"Label"> | Date | string
    instanceId?: StringFilter<"Label"> | string
  }

  export type ProxyUpsertWithoutInstanceInput = {
    update: XOR<ProxyUpdateWithoutInstanceInput, ProxyUncheckedUpdateWithoutInstanceInput>
    create: XOR<ProxyCreateWithoutInstanceInput, ProxyUncheckedCreateWithoutInstanceInput>
    where?: ProxyWhereInput
  }

  export type ProxyUpdateToOneWithWhereWithoutInstanceInput = {
    where?: ProxyWhereInput
    data: XOR<ProxyUpdateWithoutInstanceInput, ProxyUncheckedUpdateWithoutInstanceInput>
  }

  export type ProxyUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    protocol?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    host?: StringFieldUpdateOperationsInput | string
    port?: StringFieldUpdateOperationsInput | string
    protocol?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUpsertWithoutInstanceInput = {
    update: XOR<SettingUpdateWithoutInstanceInput, SettingUncheckedUpdateWithoutInstanceInput>
    create: XOR<SettingCreateWithoutInstanceInput, SettingUncheckedCreateWithoutInstanceInput>
    where?: SettingWhereInput
  }

  export type SettingUpdateToOneWithWhereWithoutInstanceInput = {
    where?: SettingWhereInput
    data: XOR<SettingUpdateWithoutInstanceInput, SettingUncheckedUpdateWithoutInstanceInput>
  }

  export type SettingUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    rejectCall?: BoolFieldUpdateOperationsInput | boolean
    msgCall?: NullableStringFieldUpdateOperationsInput | string | null
    groupsIgnore?: BoolFieldUpdateOperationsInput | boolean
    alwaysOnline?: BoolFieldUpdateOperationsInput | boolean
    readMessages?: BoolFieldUpdateOperationsInput | boolean
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    syncFullHistory?: BoolFieldUpdateOperationsInput | boolean
    wavoipToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    rejectCall?: BoolFieldUpdateOperationsInput | boolean
    msgCall?: NullableStringFieldUpdateOperationsInput | string | null
    groupsIgnore?: BoolFieldUpdateOperationsInput | boolean
    alwaysOnline?: BoolFieldUpdateOperationsInput | boolean
    readMessages?: BoolFieldUpdateOperationsInput | boolean
    readStatus?: BoolFieldUpdateOperationsInput | boolean
    syncFullHistory?: BoolFieldUpdateOperationsInput | boolean
    wavoipToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RabbitmqUpsertWithoutInstanceInput = {
    update: XOR<RabbitmqUpdateWithoutInstanceInput, RabbitmqUncheckedUpdateWithoutInstanceInput>
    create: XOR<RabbitmqCreateWithoutInstanceInput, RabbitmqUncheckedCreateWithoutInstanceInput>
    where?: RabbitmqWhereInput
  }

  export type RabbitmqUpdateToOneWithWhereWithoutInstanceInput = {
    where?: RabbitmqWhereInput
    data: XOR<RabbitmqUpdateWithoutInstanceInput, RabbitmqUncheckedUpdateWithoutInstanceInput>
  }

  export type RabbitmqUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RabbitmqUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SqsUpsertWithoutInstanceInput = {
    update: XOR<SqsUpdateWithoutInstanceInput, SqsUncheckedUpdateWithoutInstanceInput>
    create: XOR<SqsCreateWithoutInstanceInput, SqsUncheckedCreateWithoutInstanceInput>
    where?: SqsWhereInput
  }

  export type SqsUpdateToOneWithWhereWithoutInstanceInput = {
    where?: SqsWhereInput
    data: XOR<SqsUpdateWithoutInstanceInput, SqsUncheckedUpdateWithoutInstanceInput>
  }

  export type SqsUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SqsUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsocketUpsertWithoutInstanceInput = {
    update: XOR<WebsocketUpdateWithoutInstanceInput, WebsocketUncheckedUpdateWithoutInstanceInput>
    create: XOR<WebsocketCreateWithoutInstanceInput, WebsocketUncheckedCreateWithoutInstanceInput>
    where?: WebsocketWhereInput
  }

  export type WebsocketUpdateToOneWithWhereWithoutInstanceInput = {
    where?: WebsocketWhereInput
    data: XOR<WebsocketUpdateWithoutInstanceInput, WebsocketUncheckedUpdateWithoutInstanceInput>
  }

  export type WebsocketUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebsocketUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypebotUpsertWithWhereUniqueWithoutInstanceInput = {
    where: TypebotWhereUniqueInput
    update: XOR<TypebotUpdateWithoutInstanceInput, TypebotUncheckedUpdateWithoutInstanceInput>
    create: XOR<TypebotCreateWithoutInstanceInput, TypebotUncheckedCreateWithoutInstanceInput>
  }

  export type TypebotUpdateWithWhereUniqueWithoutInstanceInput = {
    where: TypebotWhereUniqueInput
    data: XOR<TypebotUpdateWithoutInstanceInput, TypebotUncheckedUpdateWithoutInstanceInput>
  }

  export type TypebotUpdateManyWithWhereWithoutInstanceInput = {
    where: TypebotScalarWhereInput
    data: XOR<TypebotUpdateManyMutationInput, TypebotUncheckedUpdateManyWithoutInstanceInput>
  }

  export type TypebotScalarWhereInput = {
    AND?: TypebotScalarWhereInput | TypebotScalarWhereInput[]
    OR?: TypebotScalarWhereInput[]
    NOT?: TypebotScalarWhereInput | TypebotScalarWhereInput[]
    id?: StringFilter<"Typebot"> | string
    enabled?: BoolFilter<"Typebot"> | boolean
    description?: StringNullableFilter<"Typebot"> | string | null
    url?: StringFilter<"Typebot"> | string
    typebot?: StringFilter<"Typebot"> | string
    expire?: IntNullableFilter<"Typebot"> | number | null
    keywordFinish?: StringNullableFilter<"Typebot"> | string | null
    delayMessage?: IntNullableFilter<"Typebot"> | number | null
    unknownMessage?: StringNullableFilter<"Typebot"> | string | null
    listeningFromMe?: BoolNullableFilter<"Typebot"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"Typebot"> | boolean | null
    keepOpen?: BoolNullableFilter<"Typebot"> | boolean | null
    debounceTime?: IntNullableFilter<"Typebot"> | number | null
    createdAt?: DateTimeNullableFilter<"Typebot"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Typebot"> | Date | string | null
    ignoreJids?: JsonNullableFilter<"Typebot">
    triggerType?: EnumTriggerTypeNullableFilter<"Typebot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"Typebot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"Typebot"> | string | null
    instanceId?: StringFilter<"Typebot"> | string
  }

  export type SessionUpsertWithoutInstanceInput = {
    update: XOR<SessionUpdateWithoutInstanceInput, SessionUncheckedUpdateWithoutInstanceInput>
    create: XOR<SessionCreateWithoutInstanceInput, SessionUncheckedCreateWithoutInstanceInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutInstanceInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutInstanceInput, SessionUncheckedUpdateWithoutInstanceInput>
  }

  export type SessionUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    creds?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    creds?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateUpsertWithWhereUniqueWithoutInstanceInput = {
    where: MessageUpdateWhereUniqueInput
    update: XOR<MessageUpdateUpdateWithoutInstanceInput, MessageUpdateUncheckedUpdateWithoutInstanceInput>
    create: XOR<MessageUpdateCreateWithoutInstanceInput, MessageUpdateUncheckedCreateWithoutInstanceInput>
  }

  export type MessageUpdateUpdateWithWhereUniqueWithoutInstanceInput = {
    where: MessageUpdateWhereUniqueInput
    data: XOR<MessageUpdateUpdateWithoutInstanceInput, MessageUpdateUncheckedUpdateWithoutInstanceInput>
  }

  export type MessageUpdateUpdateManyWithWhereWithoutInstanceInput = {
    where: MessageUpdateScalarWhereInput
    data: XOR<MessageUpdateUpdateManyMutationInput, MessageUpdateUncheckedUpdateManyWithoutInstanceInput>
  }

  export type MessageUpdateScalarWhereInput = {
    AND?: MessageUpdateScalarWhereInput | MessageUpdateScalarWhereInput[]
    OR?: MessageUpdateScalarWhereInput[]
    NOT?: MessageUpdateScalarWhereInput | MessageUpdateScalarWhereInput[]
    id?: StringFilter<"MessageUpdate"> | string
    keyId?: StringFilter<"MessageUpdate"> | string
    remoteJid?: StringFilter<"MessageUpdate"> | string
    fromMe?: BoolFilter<"MessageUpdate"> | boolean
    participant?: StringNullableFilter<"MessageUpdate"> | string | null
    pollUpdates?: JsonNullableFilter<"MessageUpdate">
    status?: StringFilter<"MessageUpdate"> | string
    messageId?: StringFilter<"MessageUpdate"> | string
    instanceId?: StringFilter<"MessageUpdate"> | string
  }

  export type TypebotSettingUpsertWithoutInstanceInput = {
    update: XOR<TypebotSettingUpdateWithoutInstanceInput, TypebotSettingUncheckedUpdateWithoutInstanceInput>
    create: XOR<TypebotSettingCreateWithoutInstanceInput, TypebotSettingUncheckedCreateWithoutInstanceInput>
    where?: TypebotSettingWhereInput
  }

  export type TypebotSettingUpdateToOneWithWhereWithoutInstanceInput = {
    where?: TypebotSettingWhereInput
    data: XOR<TypebotSettingUpdateWithoutInstanceInput, TypebotSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type TypebotSettingUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fallback?: TypebotUpdateOneWithoutTypebotSettingNestedInput
  }

  export type TypebotSettingUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    typebotIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpsertWithWhereUniqueWithoutInstanceInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutInstanceInput, MediaUncheckedUpdateWithoutInstanceInput>
    create: XOR<MediaCreateWithoutInstanceInput, MediaUncheckedCreateWithoutInstanceInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutInstanceInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutInstanceInput, MediaUncheckedUpdateWithoutInstanceInput>
  }

  export type MediaUpdateManyWithWhereWithoutInstanceInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutInstanceInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    fileName?: StringFilter<"Media"> | string
    type?: StringFilter<"Media"> | string
    mimetype?: StringFilter<"Media"> | string
    createdAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    messageId?: StringFilter<"Media"> | string
    instanceId?: StringFilter<"Media"> | string
  }

  export type OpenaiCredsUpsertWithWhereUniqueWithoutInstanceInput = {
    where: OpenaiCredsWhereUniqueInput
    update: XOR<OpenaiCredsUpdateWithoutInstanceInput, OpenaiCredsUncheckedUpdateWithoutInstanceInput>
    create: XOR<OpenaiCredsCreateWithoutInstanceInput, OpenaiCredsUncheckedCreateWithoutInstanceInput>
  }

  export type OpenaiCredsUpdateWithWhereUniqueWithoutInstanceInput = {
    where: OpenaiCredsWhereUniqueInput
    data: XOR<OpenaiCredsUpdateWithoutInstanceInput, OpenaiCredsUncheckedUpdateWithoutInstanceInput>
  }

  export type OpenaiCredsUpdateManyWithWhereWithoutInstanceInput = {
    where: OpenaiCredsScalarWhereInput
    data: XOR<OpenaiCredsUpdateManyMutationInput, OpenaiCredsUncheckedUpdateManyWithoutInstanceInput>
  }

  export type OpenaiCredsScalarWhereInput = {
    AND?: OpenaiCredsScalarWhereInput | OpenaiCredsScalarWhereInput[]
    OR?: OpenaiCredsScalarWhereInput[]
    NOT?: OpenaiCredsScalarWhereInput | OpenaiCredsScalarWhereInput[]
    id?: StringFilter<"OpenaiCreds"> | string
    name?: StringNullableFilter<"OpenaiCreds"> | string | null
    apiKey?: StringNullableFilter<"OpenaiCreds"> | string | null
    createdAt?: DateTimeNullableFilter<"OpenaiCreds"> | Date | string | null
    updatedAt?: DateTimeFilter<"OpenaiCreds"> | Date | string
    instanceId?: StringFilter<"OpenaiCreds"> | string
  }

  export type OpenaiBotUpsertWithWhereUniqueWithoutInstanceInput = {
    where: OpenaiBotWhereUniqueInput
    update: XOR<OpenaiBotUpdateWithoutInstanceInput, OpenaiBotUncheckedUpdateWithoutInstanceInput>
    create: XOR<OpenaiBotCreateWithoutInstanceInput, OpenaiBotUncheckedCreateWithoutInstanceInput>
  }

  export type OpenaiBotUpdateWithWhereUniqueWithoutInstanceInput = {
    where: OpenaiBotWhereUniqueInput
    data: XOR<OpenaiBotUpdateWithoutInstanceInput, OpenaiBotUncheckedUpdateWithoutInstanceInput>
  }

  export type OpenaiBotUpdateManyWithWhereWithoutInstanceInput = {
    where: OpenaiBotScalarWhereInput
    data: XOR<OpenaiBotUpdateManyMutationInput, OpenaiBotUncheckedUpdateManyWithoutInstanceInput>
  }

  export type OpenaiBotScalarWhereInput = {
    AND?: OpenaiBotScalarWhereInput | OpenaiBotScalarWhereInput[]
    OR?: OpenaiBotScalarWhereInput[]
    NOT?: OpenaiBotScalarWhereInput | OpenaiBotScalarWhereInput[]
    id?: StringFilter<"OpenaiBot"> | string
    enabled?: BoolFilter<"OpenaiBot"> | boolean
    description?: StringNullableFilter<"OpenaiBot"> | string | null
    botType?: EnumOpenaiBotTypeFilter<"OpenaiBot"> | $Enums.OpenaiBotType
    assistantId?: StringNullableFilter<"OpenaiBot"> | string | null
    functionUrl?: StringNullableFilter<"OpenaiBot"> | string | null
    model?: StringNullableFilter<"OpenaiBot"> | string | null
    systemMessages?: JsonNullableFilter<"OpenaiBot">
    assistantMessages?: JsonNullableFilter<"OpenaiBot">
    userMessages?: JsonNullableFilter<"OpenaiBot">
    maxTokens?: IntNullableFilter<"OpenaiBot"> | number | null
    expire?: IntNullableFilter<"OpenaiBot"> | number | null
    keywordFinish?: StringNullableFilter<"OpenaiBot"> | string | null
    delayMessage?: IntNullableFilter<"OpenaiBot"> | number | null
    unknownMessage?: StringNullableFilter<"OpenaiBot"> | string | null
    listeningFromMe?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    keepOpen?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    debounceTime?: IntNullableFilter<"OpenaiBot"> | number | null
    ignoreJids?: JsonNullableFilter<"OpenaiBot">
    splitMessages?: BoolNullableFilter<"OpenaiBot"> | boolean | null
    timePerChar?: IntNullableFilter<"OpenaiBot"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"OpenaiBot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"OpenaiBot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"OpenaiBot"> | string | null
    createdAt?: DateTimeNullableFilter<"OpenaiBot"> | Date | string | null
    updatedAt?: DateTimeFilter<"OpenaiBot"> | Date | string
    openaiCredsId?: StringFilter<"OpenaiBot"> | string
    instanceId?: StringFilter<"OpenaiBot"> | string
  }

  export type OpenaiSettingUpsertWithoutInstanceInput = {
    update: XOR<OpenaiSettingUpdateWithoutInstanceInput, OpenaiSettingUncheckedUpdateWithoutInstanceInput>
    create: XOR<OpenaiSettingCreateWithoutInstanceInput, OpenaiSettingUncheckedCreateWithoutInstanceInput>
    where?: OpenaiSettingWhereInput
  }

  export type OpenaiSettingUpdateToOneWithWhereWithoutInstanceInput = {
    where?: OpenaiSettingWhereInput
    data: XOR<OpenaiSettingUpdateWithoutInstanceInput, OpenaiSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type OpenaiSettingUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OpenaiCreds?: OpenaiCredsUpdateOneWithoutOpenaiSettingNestedInput
    Fallback?: OpenaiBotUpdateOneWithoutOpenaiSettingNestedInput
  }

  export type OpenaiSettingUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
    openaiIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateUpsertWithWhereUniqueWithoutInstanceInput = {
    where: TemplateWhereUniqueInput
    update: XOR<TemplateUpdateWithoutInstanceInput, TemplateUncheckedUpdateWithoutInstanceInput>
    create: XOR<TemplateCreateWithoutInstanceInput, TemplateUncheckedCreateWithoutInstanceInput>
  }

  export type TemplateUpdateWithWhereUniqueWithoutInstanceInput = {
    where: TemplateWhereUniqueInput
    data: XOR<TemplateUpdateWithoutInstanceInput, TemplateUncheckedUpdateWithoutInstanceInput>
  }

  export type TemplateUpdateManyWithWhereWithoutInstanceInput = {
    where: TemplateScalarWhereInput
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyWithoutInstanceInput>
  }

  export type TemplateScalarWhereInput = {
    AND?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    OR?: TemplateScalarWhereInput[]
    NOT?: TemplateScalarWhereInput | TemplateScalarWhereInput[]
    id?: StringFilter<"Template"> | string
    templateId?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    template?: JsonFilter<"Template">
    webhookUrl?: StringNullableFilter<"Template"> | string | null
    createdAt?: DateTimeNullableFilter<"Template"> | Date | string | null
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    instanceId?: StringFilter<"Template"> | string
  }

  export type DifyUpsertWithWhereUniqueWithoutInstanceInput = {
    where: DifyWhereUniqueInput
    update: XOR<DifyUpdateWithoutInstanceInput, DifyUncheckedUpdateWithoutInstanceInput>
    create: XOR<DifyCreateWithoutInstanceInput, DifyUncheckedCreateWithoutInstanceInput>
  }

  export type DifyUpdateWithWhereUniqueWithoutInstanceInput = {
    where: DifyWhereUniqueInput
    data: XOR<DifyUpdateWithoutInstanceInput, DifyUncheckedUpdateWithoutInstanceInput>
  }

  export type DifyUpdateManyWithWhereWithoutInstanceInput = {
    where: DifyScalarWhereInput
    data: XOR<DifyUpdateManyMutationInput, DifyUncheckedUpdateManyWithoutInstanceInput>
  }

  export type DifyScalarWhereInput = {
    AND?: DifyScalarWhereInput | DifyScalarWhereInput[]
    OR?: DifyScalarWhereInput[]
    NOT?: DifyScalarWhereInput | DifyScalarWhereInput[]
    id?: StringFilter<"Dify"> | string
    enabled?: BoolFilter<"Dify"> | boolean
    description?: StringNullableFilter<"Dify"> | string | null
    botType?: EnumDifyBotTypeFilter<"Dify"> | $Enums.DifyBotType
    apiUrl?: StringNullableFilter<"Dify"> | string | null
    apiKey?: StringNullableFilter<"Dify"> | string | null
    expire?: IntNullableFilter<"Dify"> | number | null
    keywordFinish?: StringNullableFilter<"Dify"> | string | null
    delayMessage?: IntNullableFilter<"Dify"> | number | null
    unknownMessage?: StringNullableFilter<"Dify"> | string | null
    listeningFromMe?: BoolNullableFilter<"Dify"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"Dify"> | boolean | null
    keepOpen?: BoolNullableFilter<"Dify"> | boolean | null
    debounceTime?: IntNullableFilter<"Dify"> | number | null
    ignoreJids?: JsonNullableFilter<"Dify">
    splitMessages?: BoolNullableFilter<"Dify"> | boolean | null
    timePerChar?: IntNullableFilter<"Dify"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"Dify"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"Dify"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"Dify"> | string | null
    createdAt?: DateTimeNullableFilter<"Dify"> | Date | string | null
    updatedAt?: DateTimeFilter<"Dify"> | Date | string
    instanceId?: StringFilter<"Dify"> | string
  }

  export type DifySettingUpsertWithoutInstanceInput = {
    update: XOR<DifySettingUpdateWithoutInstanceInput, DifySettingUncheckedUpdateWithoutInstanceInput>
    create: XOR<DifySettingCreateWithoutInstanceInput, DifySettingUncheckedCreateWithoutInstanceInput>
    where?: DifySettingWhereInput
  }

  export type DifySettingUpdateToOneWithWhereWithoutInstanceInput = {
    where?: DifySettingWhereInput
    data: XOR<DifySettingUpdateWithoutInstanceInput, DifySettingUncheckedUpdateWithoutInstanceInput>
  }

  export type DifySettingUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fallback?: DifyUpdateOneWithoutDifySettingNestedInput
  }

  export type DifySettingUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difyIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntegrationSessionUpsertWithWhereUniqueWithoutInstanceInput = {
    where: IntegrationSessionWhereUniqueInput
    update: XOR<IntegrationSessionUpdateWithoutInstanceInput, IntegrationSessionUncheckedUpdateWithoutInstanceInput>
    create: XOR<IntegrationSessionCreateWithoutInstanceInput, IntegrationSessionUncheckedCreateWithoutInstanceInput>
  }

  export type IntegrationSessionUpdateWithWhereUniqueWithoutInstanceInput = {
    where: IntegrationSessionWhereUniqueInput
    data: XOR<IntegrationSessionUpdateWithoutInstanceInput, IntegrationSessionUncheckedUpdateWithoutInstanceInput>
  }

  export type IntegrationSessionUpdateManyWithWhereWithoutInstanceInput = {
    where: IntegrationSessionScalarWhereInput
    data: XOR<IntegrationSessionUpdateManyMutationInput, IntegrationSessionUncheckedUpdateManyWithoutInstanceInput>
  }

  export type IntegrationSessionScalarWhereInput = {
    AND?: IntegrationSessionScalarWhereInput | IntegrationSessionScalarWhereInput[]
    OR?: IntegrationSessionScalarWhereInput[]
    NOT?: IntegrationSessionScalarWhereInput | IntegrationSessionScalarWhereInput[]
    id?: StringFilter<"IntegrationSession"> | string
    sessionId?: StringFilter<"IntegrationSession"> | string
    remoteJid?: StringFilter<"IntegrationSession"> | string
    pushName?: StringNullableFilter<"IntegrationSession"> | string | null
    status?: EnumSessionStatusFilter<"IntegrationSession"> | $Enums.SessionStatus
    awaitUser?: BoolFilter<"IntegrationSession"> | boolean
    context?: JsonNullableFilter<"IntegrationSession">
    type?: StringNullableFilter<"IntegrationSession"> | string | null
    createdAt?: DateTimeNullableFilter<"IntegrationSession"> | Date | string | null
    updatedAt?: DateTimeFilter<"IntegrationSession"> | Date | string
    instanceId?: StringFilter<"IntegrationSession"> | string
    parameters?: JsonNullableFilter<"IntegrationSession">
    botId?: StringNullableFilter<"IntegrationSession"> | string | null
  }

  export type EvolutionBotUpsertWithWhereUniqueWithoutInstanceInput = {
    where: EvolutionBotWhereUniqueInput
    update: XOR<EvolutionBotUpdateWithoutInstanceInput, EvolutionBotUncheckedUpdateWithoutInstanceInput>
    create: XOR<EvolutionBotCreateWithoutInstanceInput, EvolutionBotUncheckedCreateWithoutInstanceInput>
  }

  export type EvolutionBotUpdateWithWhereUniqueWithoutInstanceInput = {
    where: EvolutionBotWhereUniqueInput
    data: XOR<EvolutionBotUpdateWithoutInstanceInput, EvolutionBotUncheckedUpdateWithoutInstanceInput>
  }

  export type EvolutionBotUpdateManyWithWhereWithoutInstanceInput = {
    where: EvolutionBotScalarWhereInput
    data: XOR<EvolutionBotUpdateManyMutationInput, EvolutionBotUncheckedUpdateManyWithoutInstanceInput>
  }

  export type EvolutionBotScalarWhereInput = {
    AND?: EvolutionBotScalarWhereInput | EvolutionBotScalarWhereInput[]
    OR?: EvolutionBotScalarWhereInput[]
    NOT?: EvolutionBotScalarWhereInput | EvolutionBotScalarWhereInput[]
    id?: StringFilter<"EvolutionBot"> | string
    enabled?: BoolFilter<"EvolutionBot"> | boolean
    description?: StringNullableFilter<"EvolutionBot"> | string | null
    apiUrl?: StringNullableFilter<"EvolutionBot"> | string | null
    apiKey?: StringNullableFilter<"EvolutionBot"> | string | null
    expire?: IntNullableFilter<"EvolutionBot"> | number | null
    keywordFinish?: StringNullableFilter<"EvolutionBot"> | string | null
    delayMessage?: IntNullableFilter<"EvolutionBot"> | number | null
    unknownMessage?: StringNullableFilter<"EvolutionBot"> | string | null
    listeningFromMe?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    keepOpen?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    debounceTime?: IntNullableFilter<"EvolutionBot"> | number | null
    ignoreJids?: JsonNullableFilter<"EvolutionBot">
    splitMessages?: BoolNullableFilter<"EvolutionBot"> | boolean | null
    timePerChar?: IntNullableFilter<"EvolutionBot"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"EvolutionBot"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"EvolutionBot"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"EvolutionBot"> | string | null
    createdAt?: DateTimeNullableFilter<"EvolutionBot"> | Date | string | null
    updatedAt?: DateTimeFilter<"EvolutionBot"> | Date | string
    instanceId?: StringFilter<"EvolutionBot"> | string
  }

  export type EvolutionBotSettingUpsertWithoutInstanceInput = {
    update: XOR<EvolutionBotSettingUpdateWithoutInstanceInput, EvolutionBotSettingUncheckedUpdateWithoutInstanceInput>
    create: XOR<EvolutionBotSettingCreateWithoutInstanceInput, EvolutionBotSettingUncheckedCreateWithoutInstanceInput>
    where?: EvolutionBotSettingWhereInput
  }

  export type EvolutionBotSettingUpdateToOneWithWhereWithoutInstanceInput = {
    where?: EvolutionBotSettingWhereInput
    data: XOR<EvolutionBotSettingUpdateWithoutInstanceInput, EvolutionBotSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type EvolutionBotSettingUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fallback?: EvolutionBotUpdateOneWithoutEvolutionBotSettingNestedInput
  }

  export type EvolutionBotSettingUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    botIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlowiseUpsertWithWhereUniqueWithoutInstanceInput = {
    where: FlowiseWhereUniqueInput
    update: XOR<FlowiseUpdateWithoutInstanceInput, FlowiseUncheckedUpdateWithoutInstanceInput>
    create: XOR<FlowiseCreateWithoutInstanceInput, FlowiseUncheckedCreateWithoutInstanceInput>
  }

  export type FlowiseUpdateWithWhereUniqueWithoutInstanceInput = {
    where: FlowiseWhereUniqueInput
    data: XOR<FlowiseUpdateWithoutInstanceInput, FlowiseUncheckedUpdateWithoutInstanceInput>
  }

  export type FlowiseUpdateManyWithWhereWithoutInstanceInput = {
    where: FlowiseScalarWhereInput
    data: XOR<FlowiseUpdateManyMutationInput, FlowiseUncheckedUpdateManyWithoutInstanceInput>
  }

  export type FlowiseScalarWhereInput = {
    AND?: FlowiseScalarWhereInput | FlowiseScalarWhereInput[]
    OR?: FlowiseScalarWhereInput[]
    NOT?: FlowiseScalarWhereInput | FlowiseScalarWhereInput[]
    id?: StringFilter<"Flowise"> | string
    enabled?: BoolFilter<"Flowise"> | boolean
    description?: StringNullableFilter<"Flowise"> | string | null
    apiUrl?: StringNullableFilter<"Flowise"> | string | null
    apiKey?: StringNullableFilter<"Flowise"> | string | null
    expire?: IntNullableFilter<"Flowise"> | number | null
    keywordFinish?: StringNullableFilter<"Flowise"> | string | null
    delayMessage?: IntNullableFilter<"Flowise"> | number | null
    unknownMessage?: StringNullableFilter<"Flowise"> | string | null
    listeningFromMe?: BoolNullableFilter<"Flowise"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"Flowise"> | boolean | null
    keepOpen?: BoolNullableFilter<"Flowise"> | boolean | null
    debounceTime?: IntNullableFilter<"Flowise"> | number | null
    ignoreJids?: JsonNullableFilter<"Flowise">
    splitMessages?: BoolNullableFilter<"Flowise"> | boolean | null
    timePerChar?: IntNullableFilter<"Flowise"> | number | null
    triggerType?: EnumTriggerTypeNullableFilter<"Flowise"> | $Enums.TriggerType | null
    triggerOperator?: EnumTriggerOperatorNullableFilter<"Flowise"> | $Enums.TriggerOperator | null
    triggerValue?: StringNullableFilter<"Flowise"> | string | null
    createdAt?: DateTimeNullableFilter<"Flowise"> | Date | string | null
    updatedAt?: DateTimeFilter<"Flowise"> | Date | string
    instanceId?: StringFilter<"Flowise"> | string
  }

  export type FlowiseSettingUpsertWithoutInstanceInput = {
    update: XOR<FlowiseSettingUpdateWithoutInstanceInput, FlowiseSettingUncheckedUpdateWithoutInstanceInput>
    create: XOR<FlowiseSettingCreateWithoutInstanceInput, FlowiseSettingUncheckedCreateWithoutInstanceInput>
    where?: FlowiseSettingWhereInput
  }

  export type FlowiseSettingUpdateToOneWithWhereWithoutInstanceInput = {
    where?: FlowiseSettingWhereInput
    data: XOR<FlowiseSettingUpdateWithoutInstanceInput, FlowiseSettingUncheckedUpdateWithoutInstanceInput>
  }

  export type FlowiseSettingUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fallback?: FlowiseUpdateOneWithoutFlowiseSettingNestedInput
  }

  export type FlowiseSettingUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flowiseIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PusherUpsertWithoutInstanceInput = {
    update: XOR<PusherUpdateWithoutInstanceInput, PusherUncheckedUpdateWithoutInstanceInput>
    create: XOR<PusherCreateWithoutInstanceInput, PusherUncheckedCreateWithoutInstanceInput>
    where?: PusherWhereInput
  }

  export type PusherUpdateToOneWithWhereWithoutInstanceInput = {
    where?: PusherWhereInput
    data: XOR<PusherUpdateWithoutInstanceInput, PusherUncheckedUpdateWithoutInstanceInput>
  }

  export type PusherUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    cluster?: StringFieldUpdateOperationsInput | string
    useTLS?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PusherUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    appId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    cluster?: StringFieldUpdateOperationsInput | string
    useTLS?: BoolFieldUpdateOperationsInput | boolean
    events?: JsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstanceCreateWithoutSessionInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutSessionInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutSessionInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutSessionInput, InstanceUncheckedCreateWithoutSessionInput>
  }

  export type InstanceUpsertWithoutSessionInput = {
    update: XOR<InstanceUpdateWithoutSessionInput, InstanceUncheckedUpdateWithoutSessionInput>
    create: XOR<InstanceCreateWithoutSessionInput, InstanceUncheckedCreateWithoutSessionInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutSessionInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutSessionInput, InstanceUncheckedUpdateWithoutSessionInput>
  }

  export type InstanceUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutChatInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutChatInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutChatInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutChatInput, InstanceUncheckedCreateWithoutChatInput>
  }

  export type InstanceUpsertWithoutChatInput = {
    update: XOR<InstanceUpdateWithoutChatInput, InstanceUncheckedUpdateWithoutChatInput>
    create: XOR<InstanceCreateWithoutChatInput, InstanceUncheckedCreateWithoutChatInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutChatInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutChatInput, InstanceUncheckedUpdateWithoutChatInput>
  }

  export type InstanceUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutContactInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutContactInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutContactInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutContactInput, InstanceUncheckedCreateWithoutContactInput>
  }

  export type InstanceUpsertWithoutContactInput = {
    update: XOR<InstanceUpdateWithoutContactInput, InstanceUncheckedUpdateWithoutContactInput>
    create: XOR<InstanceCreateWithoutContactInput, InstanceUncheckedCreateWithoutContactInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutContactInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutContactInput, InstanceUncheckedUpdateWithoutContactInput>
  }

  export type InstanceUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutMessageInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutMessageInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutMessageInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutMessageInput, InstanceUncheckedCreateWithoutMessageInput>
  }

  export type MessageUpdateCreateWithoutMessageInput = {
    id?: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant?: string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status: string
    Instance: InstanceCreateNestedOneWithoutMessageUpdateInput
  }

  export type MessageUpdateUncheckedCreateWithoutMessageInput = {
    id?: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant?: string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status: string
    instanceId: string
  }

  export type MessageUpdateCreateOrConnectWithoutMessageInput = {
    where: MessageUpdateWhereUniqueInput
    create: XOR<MessageUpdateCreateWithoutMessageInput, MessageUpdateUncheckedCreateWithoutMessageInput>
  }

  export type MessageUpdateCreateManyMessageInputEnvelope = {
    data: MessageUpdateCreateManyMessageInput | MessageUpdateCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutMessageInput = {
    id?: string
    fileName: string
    type: string
    mimetype: string
    createdAt?: Date | string | null
    Instance: InstanceCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutMessageInput = {
    id?: string
    fileName: string
    type: string
    mimetype: string
    createdAt?: Date | string | null
    instanceId: string
  }

  export type MediaCreateOrConnectWithoutMessageInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutMessageInput, MediaUncheckedCreateWithoutMessageInput>
  }

  export type IntegrationSessionCreateWithoutMessageInput = {
    id?: string
    sessionId: string
    remoteJid: string
    pushName?: string | null
    status: $Enums.SessionStatus
    awaitUser?: boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: string | null
    Instance: InstanceCreateNestedOneWithoutIntegrationSessionsInput
  }

  export type IntegrationSessionUncheckedCreateWithoutMessageInput = {
    id?: string
    sessionId: string
    remoteJid: string
    pushName?: string | null
    status: $Enums.SessionStatus
    awaitUser?: boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: string | null
  }

  export type IntegrationSessionCreateOrConnectWithoutMessageInput = {
    where: IntegrationSessionWhereUniqueInput
    create: XOR<IntegrationSessionCreateWithoutMessageInput, IntegrationSessionUncheckedCreateWithoutMessageInput>
  }

  export type InstanceUpsertWithoutMessageInput = {
    update: XOR<InstanceUpdateWithoutMessageInput, InstanceUncheckedUpdateWithoutMessageInput>
    create: XOR<InstanceCreateWithoutMessageInput, InstanceUncheckedCreateWithoutMessageInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutMessageInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutMessageInput, InstanceUncheckedUpdateWithoutMessageInput>
  }

  export type InstanceUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type MessageUpdateUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageUpdateWhereUniqueInput
    update: XOR<MessageUpdateUpdateWithoutMessageInput, MessageUpdateUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageUpdateCreateWithoutMessageInput, MessageUpdateUncheckedCreateWithoutMessageInput>
  }

  export type MessageUpdateUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageUpdateWhereUniqueInput
    data: XOR<MessageUpdateUpdateWithoutMessageInput, MessageUpdateUncheckedUpdateWithoutMessageInput>
  }

  export type MessageUpdateUpdateManyWithWhereWithoutMessageInput = {
    where: MessageUpdateScalarWhereInput
    data: XOR<MessageUpdateUpdateManyMutationInput, MessageUpdateUncheckedUpdateManyWithoutMessageInput>
  }

  export type MediaUpsertWithoutMessageInput = {
    update: XOR<MediaUpdateWithoutMessageInput, MediaUncheckedUpdateWithoutMessageInput>
    create: XOR<MediaCreateWithoutMessageInput, MediaUncheckedCreateWithoutMessageInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutMessageInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutMessageInput, MediaUncheckedUpdateWithoutMessageInput>
  }

  export type MediaUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Instance?: InstanceUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type IntegrationSessionUpsertWithoutMessageInput = {
    update: XOR<IntegrationSessionUpdateWithoutMessageInput, IntegrationSessionUncheckedUpdateWithoutMessageInput>
    create: XOR<IntegrationSessionCreateWithoutMessageInput, IntegrationSessionUncheckedCreateWithoutMessageInput>
    where?: IntegrationSessionWhereInput
  }

  export type IntegrationSessionUpdateToOneWithWhereWithoutMessageInput = {
    where?: IntegrationSessionWhereInput
    data: XOR<IntegrationSessionUpdateWithoutMessageInput, IntegrationSessionUncheckedUpdateWithoutMessageInput>
  }

  export type IntegrationSessionUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    awaitUser?: BoolFieldUpdateOperationsInput | boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    Instance?: InstanceUpdateOneRequiredWithoutIntegrationSessionsNestedInput
  }

  export type IntegrationSessionUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    awaitUser?: BoolFieldUpdateOperationsInput | boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageCreateWithoutMessageUpdateInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    Instance: InstanceCreateNestedOneWithoutMessageInput
    Media?: MediaCreateNestedOneWithoutMessageInput
    session?: IntegrationSessionCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutMessageUpdateInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    instanceId: string
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    sessionId?: string | null
    Media?: MediaUncheckedCreateNestedOneWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutMessageUpdateInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutMessageUpdateInput, MessageUncheckedCreateWithoutMessageUpdateInput>
  }

  export type InstanceCreateWithoutMessageUpdateInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutMessageUpdateInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutMessageUpdateInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutMessageUpdateInput, InstanceUncheckedCreateWithoutMessageUpdateInput>
  }

  export type MessageUpsertWithoutMessageUpdateInput = {
    update: XOR<MessageUpdateWithoutMessageUpdateInput, MessageUncheckedUpdateWithoutMessageUpdateInput>
    create: XOR<MessageCreateWithoutMessageUpdateInput, MessageUncheckedCreateWithoutMessageUpdateInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutMessageUpdateInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutMessageUpdateInput, MessageUncheckedUpdateWithoutMessageUpdateInput>
  }

  export type MessageUpdateWithoutMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    Instance?: InstanceUpdateOneRequiredWithoutMessageNestedInput
    Media?: MediaUpdateOneWithoutMessageNestedInput
    session?: IntegrationSessionUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    instanceId?: StringFieldUpdateOperationsInput | string
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    Media?: MediaUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type InstanceUpsertWithoutMessageUpdateInput = {
    update: XOR<InstanceUpdateWithoutMessageUpdateInput, InstanceUncheckedUpdateWithoutMessageUpdateInput>
    create: XOR<InstanceCreateWithoutMessageUpdateInput, InstanceUncheckedCreateWithoutMessageUpdateInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutMessageUpdateInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutMessageUpdateInput, InstanceUncheckedUpdateWithoutMessageUpdateInput>
  }

  export type InstanceUpdateWithoutMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutWebhookInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutWebhookInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutWebhookInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutWebhookInput, InstanceUncheckedCreateWithoutWebhookInput>
  }

  export type InstanceUpsertWithoutWebhookInput = {
    update: XOR<InstanceUpdateWithoutWebhookInput, InstanceUncheckedUpdateWithoutWebhookInput>
    create: XOR<InstanceCreateWithoutWebhookInput, InstanceUncheckedCreateWithoutWebhookInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutWebhookInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutWebhookInput, InstanceUncheckedUpdateWithoutWebhookInput>
  }

  export type InstanceUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutWebhookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutChatwootInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutChatwootInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutChatwootInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutChatwootInput, InstanceUncheckedCreateWithoutChatwootInput>
  }

  export type InstanceUpsertWithoutChatwootInput = {
    update: XOR<InstanceUpdateWithoutChatwootInput, InstanceUncheckedUpdateWithoutChatwootInput>
    create: XOR<InstanceCreateWithoutChatwootInput, InstanceUncheckedCreateWithoutChatwootInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutChatwootInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutChatwootInput, InstanceUncheckedUpdateWithoutChatwootInput>
  }

  export type InstanceUpdateWithoutChatwootInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutChatwootInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutLabelInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutLabelInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutLabelInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutLabelInput, InstanceUncheckedCreateWithoutLabelInput>
  }

  export type InstanceUpsertWithoutLabelInput = {
    update: XOR<InstanceUpdateWithoutLabelInput, InstanceUncheckedUpdateWithoutLabelInput>
    create: XOR<InstanceCreateWithoutLabelInput, InstanceUncheckedCreateWithoutLabelInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutLabelInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutLabelInput, InstanceUncheckedUpdateWithoutLabelInput>
  }

  export type InstanceUpdateWithoutLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutLabelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutProxyInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutProxyInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutProxyInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutProxyInput, InstanceUncheckedCreateWithoutProxyInput>
  }

  export type InstanceUpsertWithoutProxyInput = {
    update: XOR<InstanceUpdateWithoutProxyInput, InstanceUncheckedUpdateWithoutProxyInput>
    create: XOR<InstanceCreateWithoutProxyInput, InstanceUncheckedCreateWithoutProxyInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutProxyInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutProxyInput, InstanceUncheckedUpdateWithoutProxyInput>
  }

  export type InstanceUpdateWithoutProxyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutProxyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutSettingInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutSettingInput, InstanceUncheckedCreateWithoutSettingInput>
  }

  export type InstanceUpsertWithoutSettingInput = {
    update: XOR<InstanceUpdateWithoutSettingInput, InstanceUncheckedUpdateWithoutSettingInput>
    create: XOR<InstanceCreateWithoutSettingInput, InstanceUncheckedCreateWithoutSettingInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutSettingInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutSettingInput, InstanceUncheckedUpdateWithoutSettingInput>
  }

  export type InstanceUpdateWithoutSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutRabbitmqInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutRabbitmqInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutRabbitmqInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutRabbitmqInput, InstanceUncheckedCreateWithoutRabbitmqInput>
  }

  export type InstanceUpsertWithoutRabbitmqInput = {
    update: XOR<InstanceUpdateWithoutRabbitmqInput, InstanceUncheckedUpdateWithoutRabbitmqInput>
    create: XOR<InstanceCreateWithoutRabbitmqInput, InstanceUncheckedCreateWithoutRabbitmqInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutRabbitmqInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutRabbitmqInput, InstanceUncheckedUpdateWithoutRabbitmqInput>
  }

  export type InstanceUpdateWithoutRabbitmqInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutRabbitmqInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutSqsInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutSqsInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutSqsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutSqsInput, InstanceUncheckedCreateWithoutSqsInput>
  }

  export type InstanceUpsertWithoutSqsInput = {
    update: XOR<InstanceUpdateWithoutSqsInput, InstanceUncheckedUpdateWithoutSqsInput>
    create: XOR<InstanceCreateWithoutSqsInput, InstanceUncheckedCreateWithoutSqsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutSqsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutSqsInput, InstanceUncheckedUpdateWithoutSqsInput>
  }

  export type InstanceUpdateWithoutSqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutSqsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutWebsocketInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutWebsocketInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutWebsocketInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutWebsocketInput, InstanceUncheckedCreateWithoutWebsocketInput>
  }

  export type InstanceUpsertWithoutWebsocketInput = {
    update: XOR<InstanceUpdateWithoutWebsocketInput, InstanceUncheckedUpdateWithoutWebsocketInput>
    create: XOR<InstanceCreateWithoutWebsocketInput, InstanceUncheckedCreateWithoutWebsocketInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutWebsocketInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutWebsocketInput, InstanceUncheckedUpdateWithoutWebsocketInput>
  }

  export type InstanceUpdateWithoutWebsocketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutWebsocketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutPusherInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutPusherInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutPusherInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutPusherInput, InstanceUncheckedCreateWithoutPusherInput>
  }

  export type InstanceUpsertWithoutPusherInput = {
    update: XOR<InstanceUpdateWithoutPusherInput, InstanceUncheckedUpdateWithoutPusherInput>
    create: XOR<InstanceCreateWithoutPusherInput, InstanceUncheckedCreateWithoutPusherInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutPusherInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutPusherInput, InstanceUncheckedUpdateWithoutPusherInput>
  }

  export type InstanceUpdateWithoutPusherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutPusherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutTypebotInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutTypebotInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutTypebotInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutTypebotInput, InstanceUncheckedCreateWithoutTypebotInput>
  }

  export type TypebotSettingCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutTypebotSettingInput
  }

  export type TypebotSettingUncheckedCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type TypebotSettingCreateOrConnectWithoutFallbackInput = {
    where: TypebotSettingWhereUniqueInput
    create: XOR<TypebotSettingCreateWithoutFallbackInput, TypebotSettingUncheckedCreateWithoutFallbackInput>
  }

  export type TypebotSettingCreateManyFallbackInputEnvelope = {
    data: TypebotSettingCreateManyFallbackInput | TypebotSettingCreateManyFallbackInput[]
    skipDuplicates?: boolean
  }

  export type InstanceUpsertWithoutTypebotInput = {
    update: XOR<InstanceUpdateWithoutTypebotInput, InstanceUncheckedUpdateWithoutTypebotInput>
    create: XOR<InstanceCreateWithoutTypebotInput, InstanceUncheckedCreateWithoutTypebotInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutTypebotInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutTypebotInput, InstanceUncheckedUpdateWithoutTypebotInput>
  }

  export type InstanceUpdateWithoutTypebotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutTypebotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type TypebotSettingUpsertWithWhereUniqueWithoutFallbackInput = {
    where: TypebotSettingWhereUniqueInput
    update: XOR<TypebotSettingUpdateWithoutFallbackInput, TypebotSettingUncheckedUpdateWithoutFallbackInput>
    create: XOR<TypebotSettingCreateWithoutFallbackInput, TypebotSettingUncheckedCreateWithoutFallbackInput>
  }

  export type TypebotSettingUpdateWithWhereUniqueWithoutFallbackInput = {
    where: TypebotSettingWhereUniqueInput
    data: XOR<TypebotSettingUpdateWithoutFallbackInput, TypebotSettingUncheckedUpdateWithoutFallbackInput>
  }

  export type TypebotSettingUpdateManyWithWhereWithoutFallbackInput = {
    where: TypebotSettingScalarWhereInput
    data: XOR<TypebotSettingUpdateManyMutationInput, TypebotSettingUncheckedUpdateManyWithoutFallbackInput>
  }

  export type TypebotSettingScalarWhereInput = {
    AND?: TypebotSettingScalarWhereInput | TypebotSettingScalarWhereInput[]
    OR?: TypebotSettingScalarWhereInput[]
    NOT?: TypebotSettingScalarWhereInput | TypebotSettingScalarWhereInput[]
    id?: StringFilter<"TypebotSetting"> | string
    expire?: IntNullableFilter<"TypebotSetting"> | number | null
    keywordFinish?: StringNullableFilter<"TypebotSetting"> | string | null
    delayMessage?: IntNullableFilter<"TypebotSetting"> | number | null
    unknownMessage?: StringNullableFilter<"TypebotSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"TypebotSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"TypebotSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"TypebotSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"TypebotSetting"> | number | null
    typebotIdFallback?: StringNullableFilter<"TypebotSetting"> | string | null
    ignoreJids?: JsonNullableFilter<"TypebotSetting">
    createdAt?: DateTimeNullableFilter<"TypebotSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"TypebotSetting"> | Date | string
    instanceId?: StringFilter<"TypebotSetting"> | string
  }

  export type TypebotCreateWithoutTypebotSettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    url: string
    typebot: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    Instance: InstanceCreateNestedOneWithoutTypebotInput
  }

  export type TypebotUncheckedCreateWithoutTypebotSettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    url: string
    typebot: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    instanceId: string
  }

  export type TypebotCreateOrConnectWithoutTypebotSettingInput = {
    where: TypebotWhereUniqueInput
    create: XOR<TypebotCreateWithoutTypebotSettingInput, TypebotUncheckedCreateWithoutTypebotSettingInput>
  }

  export type InstanceCreateWithoutTypebotSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutTypebotSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutTypebotSettingInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutTypebotSettingInput, InstanceUncheckedCreateWithoutTypebotSettingInput>
  }

  export type TypebotUpsertWithoutTypebotSettingInput = {
    update: XOR<TypebotUpdateWithoutTypebotSettingInput, TypebotUncheckedUpdateWithoutTypebotSettingInput>
    create: XOR<TypebotCreateWithoutTypebotSettingInput, TypebotUncheckedCreateWithoutTypebotSettingInput>
    where?: TypebotWhereInput
  }

  export type TypebotUpdateToOneWithWhereWithoutTypebotSettingInput = {
    where?: TypebotWhereInput
    data: XOR<TypebotUpdateWithoutTypebotSettingInput, TypebotUncheckedUpdateWithoutTypebotSettingInput>
  }

  export type TypebotUpdateWithoutTypebotSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    typebot?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    Instance?: InstanceUpdateOneRequiredWithoutTypebotNestedInput
  }

  export type TypebotUncheckedUpdateWithoutTypebotSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    typebot?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type InstanceUpsertWithoutTypebotSettingInput = {
    update: XOR<InstanceUpdateWithoutTypebotSettingInput, InstanceUncheckedUpdateWithoutTypebotSettingInput>
    create: XOR<InstanceCreateWithoutTypebotSettingInput, InstanceUncheckedCreateWithoutTypebotSettingInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutTypebotSettingInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutTypebotSettingInput, InstanceUncheckedUpdateWithoutTypebotSettingInput>
  }

  export type InstanceUpdateWithoutTypebotSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutTypebotSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type MessageCreateWithoutSessionInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    Instance: InstanceCreateNestedOneWithoutMessageInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutMessageInput
    Media?: MediaCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSessionInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    instanceId: string
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutMessageInput
    Media?: MediaUncheckedCreateNestedOneWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSessionInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput>
  }

  export type MessageCreateManySessionInputEnvelope = {
    data: MessageCreateManySessionInput | MessageCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type InstanceCreateWithoutIntegrationSessionsInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutIntegrationSessionsInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutIntegrationSessionsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutIntegrationSessionsInput, InstanceUncheckedCreateWithoutIntegrationSessionsInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSessionInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSessionInput, MessageUncheckedUpdateWithoutSessionInput>
    create: XOR<MessageCreateWithoutSessionInput, MessageUncheckedCreateWithoutSessionInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSessionInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSessionInput, MessageUncheckedUpdateWithoutSessionInput>
  }

  export type MessageUpdateManyWithWhereWithoutSessionInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSessionInput>
  }

  export type InstanceUpsertWithoutIntegrationSessionsInput = {
    update: XOR<InstanceUpdateWithoutIntegrationSessionsInput, InstanceUncheckedUpdateWithoutIntegrationSessionsInput>
    create: XOR<InstanceCreateWithoutIntegrationSessionsInput, InstanceUncheckedCreateWithoutIntegrationSessionsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutIntegrationSessionsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutIntegrationSessionsInput, InstanceUncheckedUpdateWithoutIntegrationSessionsInput>
  }

  export type InstanceUpdateWithoutIntegrationSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutIntegrationSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type MessageCreateWithoutMediaInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    Instance: InstanceCreateNestedOneWithoutMessageInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutMessageInput
    session?: IntegrationSessionCreateNestedOneWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutMediaInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    instanceId: string
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    sessionId?: string | null
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutMediaInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutMediaInput, MessageUncheckedCreateWithoutMediaInput>
  }

  export type InstanceCreateWithoutMediaInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutMediaInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutMediaInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutMediaInput, InstanceUncheckedCreateWithoutMediaInput>
  }

  export type MessageUpsertWithoutMediaInput = {
    update: XOR<MessageUpdateWithoutMediaInput, MessageUncheckedUpdateWithoutMediaInput>
    create: XOR<MessageCreateWithoutMediaInput, MessageUncheckedCreateWithoutMediaInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutMediaInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutMediaInput, MessageUncheckedUpdateWithoutMediaInput>
  }

  export type MessageUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    Instance?: InstanceUpdateOneRequiredWithoutMessageNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutMessageNestedInput
    session?: IntegrationSessionUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    instanceId?: StringFieldUpdateOperationsInput | string
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type InstanceUpsertWithoutMediaInput = {
    update: XOR<InstanceUpdateWithoutMediaInput, InstanceUncheckedUpdateWithoutMediaInput>
    create: XOR<InstanceCreateWithoutMediaInput, InstanceUncheckedCreateWithoutMediaInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutMediaInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutMediaInput, InstanceUncheckedUpdateWithoutMediaInput>
  }

  export type InstanceUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutOpenaiCredsInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutOpenaiCredsInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutOpenaiCredsInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutOpenaiCredsInput, InstanceUncheckedCreateWithoutOpenaiCredsInput>
  }

  export type OpenaiBotCreateWithoutOpenaiCredsInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutOpenaiBotInput
    OpenaiSetting?: OpenaiSettingCreateNestedManyWithoutFallbackInput
  }

  export type OpenaiBotUncheckedCreateWithoutOpenaiCredsInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedManyWithoutFallbackInput
  }

  export type OpenaiBotCreateOrConnectWithoutOpenaiCredsInput = {
    where: OpenaiBotWhereUniqueInput
    create: XOR<OpenaiBotCreateWithoutOpenaiCredsInput, OpenaiBotUncheckedCreateWithoutOpenaiCredsInput>
  }

  export type OpenaiBotCreateManyOpenaiCredsInputEnvelope = {
    data: OpenaiBotCreateManyOpenaiCredsInput | OpenaiBotCreateManyOpenaiCredsInput[]
    skipDuplicates?: boolean
  }

  export type OpenaiSettingCreateWithoutOpenaiCredsInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Fallback?: OpenaiBotCreateNestedOneWithoutOpenaiSettingInput
    Instance: InstanceCreateNestedOneWithoutOpenaiSettingInput
  }

  export type OpenaiSettingUncheckedCreateWithoutOpenaiCredsInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiIdFallback?: string | null
    instanceId: string
  }

  export type OpenaiSettingCreateOrConnectWithoutOpenaiCredsInput = {
    where: OpenaiSettingWhereUniqueInput
    create: XOR<OpenaiSettingCreateWithoutOpenaiCredsInput, OpenaiSettingUncheckedCreateWithoutOpenaiCredsInput>
  }

  export type InstanceUpsertWithoutOpenaiCredsInput = {
    update: XOR<InstanceUpdateWithoutOpenaiCredsInput, InstanceUncheckedUpdateWithoutOpenaiCredsInput>
    create: XOR<InstanceCreateWithoutOpenaiCredsInput, InstanceUncheckedCreateWithoutOpenaiCredsInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutOpenaiCredsInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutOpenaiCredsInput, InstanceUncheckedUpdateWithoutOpenaiCredsInput>
  }

  export type InstanceUpdateWithoutOpenaiCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutOpenaiCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type OpenaiBotUpsertWithWhereUniqueWithoutOpenaiCredsInput = {
    where: OpenaiBotWhereUniqueInput
    update: XOR<OpenaiBotUpdateWithoutOpenaiCredsInput, OpenaiBotUncheckedUpdateWithoutOpenaiCredsInput>
    create: XOR<OpenaiBotCreateWithoutOpenaiCredsInput, OpenaiBotUncheckedCreateWithoutOpenaiCredsInput>
  }

  export type OpenaiBotUpdateWithWhereUniqueWithoutOpenaiCredsInput = {
    where: OpenaiBotWhereUniqueInput
    data: XOR<OpenaiBotUpdateWithoutOpenaiCredsInput, OpenaiBotUncheckedUpdateWithoutOpenaiCredsInput>
  }

  export type OpenaiBotUpdateManyWithWhereWithoutOpenaiCredsInput = {
    where: OpenaiBotScalarWhereInput
    data: XOR<OpenaiBotUpdateManyMutationInput, OpenaiBotUncheckedUpdateManyWithoutOpenaiCredsInput>
  }

  export type OpenaiSettingUpsertWithoutOpenaiCredsInput = {
    update: XOR<OpenaiSettingUpdateWithoutOpenaiCredsInput, OpenaiSettingUncheckedUpdateWithoutOpenaiCredsInput>
    create: XOR<OpenaiSettingCreateWithoutOpenaiCredsInput, OpenaiSettingUncheckedCreateWithoutOpenaiCredsInput>
    where?: OpenaiSettingWhereInput
  }

  export type OpenaiSettingUpdateToOneWithWhereWithoutOpenaiCredsInput = {
    where?: OpenaiSettingWhereInput
    data: XOR<OpenaiSettingUpdateWithoutOpenaiCredsInput, OpenaiSettingUncheckedUpdateWithoutOpenaiCredsInput>
  }

  export type OpenaiSettingUpdateWithoutOpenaiCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Fallback?: OpenaiBotUpdateOneWithoutOpenaiSettingNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutOpenaiSettingNestedInput
  }

  export type OpenaiSettingUncheckedUpdateWithoutOpenaiCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiIdFallback?: NullableStringFieldUpdateOperationsInput | string | null
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenaiCredsCreateWithoutOpenaiAssistantInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutOpenaiCredsInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutOpenaiCredsInput
  }

  export type OpenaiCredsUncheckedCreateWithoutOpenaiAssistantInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutOpenaiCredsInput
  }

  export type OpenaiCredsCreateOrConnectWithoutOpenaiAssistantInput = {
    where: OpenaiCredsWhereUniqueInput
    create: XOR<OpenaiCredsCreateWithoutOpenaiAssistantInput, OpenaiCredsUncheckedCreateWithoutOpenaiAssistantInput>
  }

  export type InstanceCreateWithoutOpenaiBotInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutOpenaiBotInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutOpenaiBotInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutOpenaiBotInput, InstanceUncheckedCreateWithoutOpenaiBotInput>
  }

  export type OpenaiSettingCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    OpenaiCreds?: OpenaiCredsCreateNestedOneWithoutOpenaiSettingInput
    Instance: InstanceCreateNestedOneWithoutOpenaiSettingInput
  }

  export type OpenaiSettingUncheckedCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
    instanceId: string
  }

  export type OpenaiSettingCreateOrConnectWithoutFallbackInput = {
    where: OpenaiSettingWhereUniqueInput
    create: XOR<OpenaiSettingCreateWithoutFallbackInput, OpenaiSettingUncheckedCreateWithoutFallbackInput>
  }

  export type OpenaiSettingCreateManyFallbackInputEnvelope = {
    data: OpenaiSettingCreateManyFallbackInput | OpenaiSettingCreateManyFallbackInput[]
    skipDuplicates?: boolean
  }

  export type OpenaiCredsUpsertWithoutOpenaiAssistantInput = {
    update: XOR<OpenaiCredsUpdateWithoutOpenaiAssistantInput, OpenaiCredsUncheckedUpdateWithoutOpenaiAssistantInput>
    create: XOR<OpenaiCredsCreateWithoutOpenaiAssistantInput, OpenaiCredsUncheckedCreateWithoutOpenaiAssistantInput>
    where?: OpenaiCredsWhereInput
  }

  export type OpenaiCredsUpdateToOneWithWhereWithoutOpenaiAssistantInput = {
    where?: OpenaiCredsWhereInput
    data: XOR<OpenaiCredsUpdateWithoutOpenaiAssistantInput, OpenaiCredsUncheckedUpdateWithoutOpenaiAssistantInput>
  }

  export type OpenaiCredsUpdateWithoutOpenaiAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutOpenaiCredsNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutOpenaiCredsNestedInput
  }

  export type OpenaiCredsUncheckedUpdateWithoutOpenaiAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutOpenaiCredsNestedInput
  }

  export type InstanceUpsertWithoutOpenaiBotInput = {
    update: XOR<InstanceUpdateWithoutOpenaiBotInput, InstanceUncheckedUpdateWithoutOpenaiBotInput>
    create: XOR<InstanceCreateWithoutOpenaiBotInput, InstanceUncheckedCreateWithoutOpenaiBotInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutOpenaiBotInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutOpenaiBotInput, InstanceUncheckedUpdateWithoutOpenaiBotInput>
  }

  export type InstanceUpdateWithoutOpenaiBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutOpenaiBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type OpenaiSettingUpsertWithWhereUniqueWithoutFallbackInput = {
    where: OpenaiSettingWhereUniqueInput
    update: XOR<OpenaiSettingUpdateWithoutFallbackInput, OpenaiSettingUncheckedUpdateWithoutFallbackInput>
    create: XOR<OpenaiSettingCreateWithoutFallbackInput, OpenaiSettingUncheckedCreateWithoutFallbackInput>
  }

  export type OpenaiSettingUpdateWithWhereUniqueWithoutFallbackInput = {
    where: OpenaiSettingWhereUniqueInput
    data: XOR<OpenaiSettingUpdateWithoutFallbackInput, OpenaiSettingUncheckedUpdateWithoutFallbackInput>
  }

  export type OpenaiSettingUpdateManyWithWhereWithoutFallbackInput = {
    where: OpenaiSettingScalarWhereInput
    data: XOR<OpenaiSettingUpdateManyMutationInput, OpenaiSettingUncheckedUpdateManyWithoutFallbackInput>
  }

  export type OpenaiSettingScalarWhereInput = {
    AND?: OpenaiSettingScalarWhereInput | OpenaiSettingScalarWhereInput[]
    OR?: OpenaiSettingScalarWhereInput[]
    NOT?: OpenaiSettingScalarWhereInput | OpenaiSettingScalarWhereInput[]
    id?: StringFilter<"OpenaiSetting"> | string
    expire?: IntNullableFilter<"OpenaiSetting"> | number | null
    keywordFinish?: StringNullableFilter<"OpenaiSetting"> | string | null
    delayMessage?: IntNullableFilter<"OpenaiSetting"> | number | null
    unknownMessage?: StringNullableFilter<"OpenaiSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"OpenaiSetting"> | number | null
    ignoreJids?: JsonNullableFilter<"OpenaiSetting">
    splitMessages?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    timePerChar?: IntNullableFilter<"OpenaiSetting"> | number | null
    speechToText?: BoolNullableFilter<"OpenaiSetting"> | boolean | null
    createdAt?: DateTimeNullableFilter<"OpenaiSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"OpenaiSetting"> | Date | string
    openaiCredsId?: StringFilter<"OpenaiSetting"> | string
    openaiIdFallback?: StringNullableFilter<"OpenaiSetting"> | string | null
    instanceId?: StringFilter<"OpenaiSetting"> | string
  }

  export type OpenaiCredsCreateWithoutOpenaiSettingInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutOpenaiCredsInput
    OpenaiAssistant?: OpenaiBotCreateNestedManyWithoutOpenaiCredsInput
  }

  export type OpenaiCredsUncheckedCreateWithoutOpenaiSettingInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
    OpenaiAssistant?: OpenaiBotUncheckedCreateNestedManyWithoutOpenaiCredsInput
  }

  export type OpenaiCredsCreateOrConnectWithoutOpenaiSettingInput = {
    where: OpenaiCredsWhereUniqueInput
    create: XOR<OpenaiCredsCreateWithoutOpenaiSettingInput, OpenaiCredsUncheckedCreateWithoutOpenaiSettingInput>
  }

  export type OpenaiBotCreateWithoutOpenaiSettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    OpenaiCreds: OpenaiCredsCreateNestedOneWithoutOpenaiAssistantInput
    Instance: InstanceCreateNestedOneWithoutOpenaiBotInput
  }

  export type OpenaiBotUncheckedCreateWithoutOpenaiSettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
    instanceId: string
  }

  export type OpenaiBotCreateOrConnectWithoutOpenaiSettingInput = {
    where: OpenaiBotWhereUniqueInput
    create: XOR<OpenaiBotCreateWithoutOpenaiSettingInput, OpenaiBotUncheckedCreateWithoutOpenaiSettingInput>
  }

  export type InstanceCreateWithoutOpenaiSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutOpenaiSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutOpenaiSettingInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutOpenaiSettingInput, InstanceUncheckedCreateWithoutOpenaiSettingInput>
  }

  export type OpenaiCredsUpsertWithoutOpenaiSettingInput = {
    update: XOR<OpenaiCredsUpdateWithoutOpenaiSettingInput, OpenaiCredsUncheckedUpdateWithoutOpenaiSettingInput>
    create: XOR<OpenaiCredsCreateWithoutOpenaiSettingInput, OpenaiCredsUncheckedCreateWithoutOpenaiSettingInput>
    where?: OpenaiCredsWhereInput
  }

  export type OpenaiCredsUpdateToOneWithWhereWithoutOpenaiSettingInput = {
    where?: OpenaiCredsWhereInput
    data: XOR<OpenaiCredsUpdateWithoutOpenaiSettingInput, OpenaiCredsUncheckedUpdateWithoutOpenaiSettingInput>
  }

  export type OpenaiCredsUpdateWithoutOpenaiSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutOpenaiCredsNestedInput
    OpenaiAssistant?: OpenaiBotUpdateManyWithoutOpenaiCredsNestedInput
  }

  export type OpenaiCredsUncheckedUpdateWithoutOpenaiSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    OpenaiAssistant?: OpenaiBotUncheckedUpdateManyWithoutOpenaiCredsNestedInput
  }

  export type OpenaiBotUpsertWithoutOpenaiSettingInput = {
    update: XOR<OpenaiBotUpdateWithoutOpenaiSettingInput, OpenaiBotUncheckedUpdateWithoutOpenaiSettingInput>
    create: XOR<OpenaiBotCreateWithoutOpenaiSettingInput, OpenaiBotUncheckedCreateWithoutOpenaiSettingInput>
    where?: OpenaiBotWhereInput
  }

  export type OpenaiBotUpdateToOneWithWhereWithoutOpenaiSettingInput = {
    where?: OpenaiBotWhereInput
    data: XOR<OpenaiBotUpdateWithoutOpenaiSettingInput, OpenaiBotUncheckedUpdateWithoutOpenaiSettingInput>
  }

  export type OpenaiBotUpdateWithoutOpenaiSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OpenaiCreds?: OpenaiCredsUpdateOneRequiredWithoutOpenaiAssistantNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutOpenaiBotNestedInput
  }

  export type OpenaiBotUncheckedUpdateWithoutOpenaiSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type InstanceUpsertWithoutOpenaiSettingInput = {
    update: XOR<InstanceUpdateWithoutOpenaiSettingInput, InstanceUncheckedUpdateWithoutOpenaiSettingInput>
    create: XOR<InstanceCreateWithoutOpenaiSettingInput, InstanceUncheckedCreateWithoutOpenaiSettingInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutOpenaiSettingInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutOpenaiSettingInput, InstanceUncheckedUpdateWithoutOpenaiSettingInput>
  }

  export type InstanceUpdateWithoutOpenaiSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutOpenaiSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutTemplateInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutTemplateInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutTemplateInput, InstanceUncheckedCreateWithoutTemplateInput>
  }

  export type InstanceUpsertWithoutTemplateInput = {
    update: XOR<InstanceUpdateWithoutTemplateInput, InstanceUncheckedUpdateWithoutTemplateInput>
    create: XOR<InstanceCreateWithoutTemplateInput, InstanceUncheckedCreateWithoutTemplateInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutTemplateInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutTemplateInput, InstanceUncheckedUpdateWithoutTemplateInput>
  }

  export type InstanceUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutDifyInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutDifyInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutDifyInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutDifyInput, InstanceUncheckedCreateWithoutDifyInput>
  }

  export type DifySettingCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutDifySettingInput
  }

  export type DifySettingUncheckedCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type DifySettingCreateOrConnectWithoutFallbackInput = {
    where: DifySettingWhereUniqueInput
    create: XOR<DifySettingCreateWithoutFallbackInput, DifySettingUncheckedCreateWithoutFallbackInput>
  }

  export type DifySettingCreateManyFallbackInputEnvelope = {
    data: DifySettingCreateManyFallbackInput | DifySettingCreateManyFallbackInput[]
    skipDuplicates?: boolean
  }

  export type InstanceUpsertWithoutDifyInput = {
    update: XOR<InstanceUpdateWithoutDifyInput, InstanceUncheckedUpdateWithoutDifyInput>
    create: XOR<InstanceCreateWithoutDifyInput, InstanceUncheckedCreateWithoutDifyInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutDifyInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutDifyInput, InstanceUncheckedUpdateWithoutDifyInput>
  }

  export type InstanceUpdateWithoutDifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutDifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type DifySettingUpsertWithWhereUniqueWithoutFallbackInput = {
    where: DifySettingWhereUniqueInput
    update: XOR<DifySettingUpdateWithoutFallbackInput, DifySettingUncheckedUpdateWithoutFallbackInput>
    create: XOR<DifySettingCreateWithoutFallbackInput, DifySettingUncheckedCreateWithoutFallbackInput>
  }

  export type DifySettingUpdateWithWhereUniqueWithoutFallbackInput = {
    where: DifySettingWhereUniqueInput
    data: XOR<DifySettingUpdateWithoutFallbackInput, DifySettingUncheckedUpdateWithoutFallbackInput>
  }

  export type DifySettingUpdateManyWithWhereWithoutFallbackInput = {
    where: DifySettingScalarWhereInput
    data: XOR<DifySettingUpdateManyMutationInput, DifySettingUncheckedUpdateManyWithoutFallbackInput>
  }

  export type DifySettingScalarWhereInput = {
    AND?: DifySettingScalarWhereInput | DifySettingScalarWhereInput[]
    OR?: DifySettingScalarWhereInput[]
    NOT?: DifySettingScalarWhereInput | DifySettingScalarWhereInput[]
    id?: StringFilter<"DifySetting"> | string
    expire?: IntNullableFilter<"DifySetting"> | number | null
    keywordFinish?: StringNullableFilter<"DifySetting"> | string | null
    delayMessage?: IntNullableFilter<"DifySetting"> | number | null
    unknownMessage?: StringNullableFilter<"DifySetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"DifySetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"DifySetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"DifySetting"> | boolean | null
    debounceTime?: IntNullableFilter<"DifySetting"> | number | null
    ignoreJids?: JsonNullableFilter<"DifySetting">
    splitMessages?: BoolNullableFilter<"DifySetting"> | boolean | null
    timePerChar?: IntNullableFilter<"DifySetting"> | number | null
    createdAt?: DateTimeNullableFilter<"DifySetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"DifySetting"> | Date | string
    difyIdFallback?: StringNullableFilter<"DifySetting"> | string | null
    instanceId?: StringFilter<"DifySetting"> | string
  }

  export type DifyCreateWithoutDifySettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.DifyBotType
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutDifyInput
  }

  export type DifyUncheckedCreateWithoutDifySettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.DifyBotType
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type DifyCreateOrConnectWithoutDifySettingInput = {
    where: DifyWhereUniqueInput
    create: XOR<DifyCreateWithoutDifySettingInput, DifyUncheckedCreateWithoutDifySettingInput>
  }

  export type InstanceCreateWithoutDifySettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutDifySettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutDifySettingInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutDifySettingInput, InstanceUncheckedCreateWithoutDifySettingInput>
  }

  export type DifyUpsertWithoutDifySettingInput = {
    update: XOR<DifyUpdateWithoutDifySettingInput, DifyUncheckedUpdateWithoutDifySettingInput>
    create: XOR<DifyCreateWithoutDifySettingInput, DifyUncheckedCreateWithoutDifySettingInput>
    where?: DifyWhereInput
  }

  export type DifyUpdateToOneWithWhereWithoutDifySettingInput = {
    where?: DifyWhereInput
    data: XOR<DifyUpdateWithoutDifySettingInput, DifyUncheckedUpdateWithoutDifySettingInput>
  }

  export type DifyUpdateWithoutDifySettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumDifyBotTypeFieldUpdateOperationsInput | $Enums.DifyBotType
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutDifyNestedInput
  }

  export type DifyUncheckedUpdateWithoutDifySettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumDifyBotTypeFieldUpdateOperationsInput | $Enums.DifyBotType
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type InstanceUpsertWithoutDifySettingInput = {
    update: XOR<InstanceUpdateWithoutDifySettingInput, InstanceUncheckedUpdateWithoutDifySettingInput>
    create: XOR<InstanceCreateWithoutDifySettingInput, InstanceUncheckedCreateWithoutDifySettingInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutDifySettingInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutDifySettingInput, InstanceUncheckedUpdateWithoutDifySettingInput>
  }

  export type InstanceUpdateWithoutDifySettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutDifySettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutEvolutionBotInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutEvolutionBotInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutEvolutionBotInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutEvolutionBotInput, InstanceUncheckedCreateWithoutEvolutionBotInput>
  }

  export type EvolutionBotSettingCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutEvolutionBotSettingInput
  }

  export type EvolutionBotSettingUncheckedCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type EvolutionBotSettingCreateOrConnectWithoutFallbackInput = {
    where: EvolutionBotSettingWhereUniqueInput
    create: XOR<EvolutionBotSettingCreateWithoutFallbackInput, EvolutionBotSettingUncheckedCreateWithoutFallbackInput>
  }

  export type EvolutionBotSettingCreateManyFallbackInputEnvelope = {
    data: EvolutionBotSettingCreateManyFallbackInput | EvolutionBotSettingCreateManyFallbackInput[]
    skipDuplicates?: boolean
  }

  export type InstanceUpsertWithoutEvolutionBotInput = {
    update: XOR<InstanceUpdateWithoutEvolutionBotInput, InstanceUncheckedUpdateWithoutEvolutionBotInput>
    create: XOR<InstanceCreateWithoutEvolutionBotInput, InstanceUncheckedCreateWithoutEvolutionBotInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutEvolutionBotInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutEvolutionBotInput, InstanceUncheckedUpdateWithoutEvolutionBotInput>
  }

  export type InstanceUpdateWithoutEvolutionBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutEvolutionBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type EvolutionBotSettingUpsertWithWhereUniqueWithoutFallbackInput = {
    where: EvolutionBotSettingWhereUniqueInput
    update: XOR<EvolutionBotSettingUpdateWithoutFallbackInput, EvolutionBotSettingUncheckedUpdateWithoutFallbackInput>
    create: XOR<EvolutionBotSettingCreateWithoutFallbackInput, EvolutionBotSettingUncheckedCreateWithoutFallbackInput>
  }

  export type EvolutionBotSettingUpdateWithWhereUniqueWithoutFallbackInput = {
    where: EvolutionBotSettingWhereUniqueInput
    data: XOR<EvolutionBotSettingUpdateWithoutFallbackInput, EvolutionBotSettingUncheckedUpdateWithoutFallbackInput>
  }

  export type EvolutionBotSettingUpdateManyWithWhereWithoutFallbackInput = {
    where: EvolutionBotSettingScalarWhereInput
    data: XOR<EvolutionBotSettingUpdateManyMutationInput, EvolutionBotSettingUncheckedUpdateManyWithoutFallbackInput>
  }

  export type EvolutionBotSettingScalarWhereInput = {
    AND?: EvolutionBotSettingScalarWhereInput | EvolutionBotSettingScalarWhereInput[]
    OR?: EvolutionBotSettingScalarWhereInput[]
    NOT?: EvolutionBotSettingScalarWhereInput | EvolutionBotSettingScalarWhereInput[]
    id?: StringFilter<"EvolutionBotSetting"> | string
    expire?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    keywordFinish?: StringNullableFilter<"EvolutionBotSetting"> | string | null
    delayMessage?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    unknownMessage?: StringNullableFilter<"EvolutionBotSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    ignoreJids?: JsonNullableFilter<"EvolutionBotSetting">
    splitMessages?: BoolNullableFilter<"EvolutionBotSetting"> | boolean | null
    timePerChar?: IntNullableFilter<"EvolutionBotSetting"> | number | null
    createdAt?: DateTimeNullableFilter<"EvolutionBotSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"EvolutionBotSetting"> | Date | string
    botIdFallback?: StringNullableFilter<"EvolutionBotSetting"> | string | null
    instanceId?: StringFilter<"EvolutionBotSetting"> | string
  }

  export type EvolutionBotCreateWithoutEvolutionBotSettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutEvolutionBotInput
  }

  export type EvolutionBotUncheckedCreateWithoutEvolutionBotSettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type EvolutionBotCreateOrConnectWithoutEvolutionBotSettingInput = {
    where: EvolutionBotWhereUniqueInput
    create: XOR<EvolutionBotCreateWithoutEvolutionBotSettingInput, EvolutionBotUncheckedCreateWithoutEvolutionBotSettingInput>
  }

  export type InstanceCreateWithoutEvolutionBotSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutEvolutionBotSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutEvolutionBotSettingInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutEvolutionBotSettingInput, InstanceUncheckedCreateWithoutEvolutionBotSettingInput>
  }

  export type EvolutionBotUpsertWithoutEvolutionBotSettingInput = {
    update: XOR<EvolutionBotUpdateWithoutEvolutionBotSettingInput, EvolutionBotUncheckedUpdateWithoutEvolutionBotSettingInput>
    create: XOR<EvolutionBotCreateWithoutEvolutionBotSettingInput, EvolutionBotUncheckedCreateWithoutEvolutionBotSettingInput>
    where?: EvolutionBotWhereInput
  }

  export type EvolutionBotUpdateToOneWithWhereWithoutEvolutionBotSettingInput = {
    where?: EvolutionBotWhereInput
    data: XOR<EvolutionBotUpdateWithoutEvolutionBotSettingInput, EvolutionBotUncheckedUpdateWithoutEvolutionBotSettingInput>
  }

  export type EvolutionBotUpdateWithoutEvolutionBotSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutEvolutionBotNestedInput
  }

  export type EvolutionBotUncheckedUpdateWithoutEvolutionBotSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type InstanceUpsertWithoutEvolutionBotSettingInput = {
    update: XOR<InstanceUpdateWithoutEvolutionBotSettingInput, InstanceUncheckedUpdateWithoutEvolutionBotSettingInput>
    create: XOR<InstanceCreateWithoutEvolutionBotSettingInput, InstanceUncheckedCreateWithoutEvolutionBotSettingInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutEvolutionBotSettingInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutEvolutionBotSettingInput, InstanceUncheckedUpdateWithoutEvolutionBotSettingInput>
  }

  export type InstanceUpdateWithoutEvolutionBotSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutEvolutionBotSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceCreateWithoutFlowiseInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingCreateNestedOneWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutFlowiseInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    FlowiseSetting?: FlowiseSettingUncheckedCreateNestedOneWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutFlowiseInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutFlowiseInput, InstanceUncheckedCreateWithoutFlowiseInput>
  }

  export type FlowiseSettingCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutFlowiseSettingInput
  }

  export type FlowiseSettingUncheckedCreateWithoutFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type FlowiseSettingCreateOrConnectWithoutFallbackInput = {
    where: FlowiseSettingWhereUniqueInput
    create: XOR<FlowiseSettingCreateWithoutFallbackInput, FlowiseSettingUncheckedCreateWithoutFallbackInput>
  }

  export type FlowiseSettingCreateManyFallbackInputEnvelope = {
    data: FlowiseSettingCreateManyFallbackInput | FlowiseSettingCreateManyFallbackInput[]
    skipDuplicates?: boolean
  }

  export type InstanceUpsertWithoutFlowiseInput = {
    update: XOR<InstanceUpdateWithoutFlowiseInput, InstanceUncheckedUpdateWithoutFlowiseInput>
    create: XOR<InstanceCreateWithoutFlowiseInput, InstanceUncheckedCreateWithoutFlowiseInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutFlowiseInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutFlowiseInput, InstanceUncheckedUpdateWithoutFlowiseInput>
  }

  export type InstanceUpdateWithoutFlowiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutFlowiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    FlowiseSetting?: FlowiseSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type FlowiseSettingUpsertWithWhereUniqueWithoutFallbackInput = {
    where: FlowiseSettingWhereUniqueInput
    update: XOR<FlowiseSettingUpdateWithoutFallbackInput, FlowiseSettingUncheckedUpdateWithoutFallbackInput>
    create: XOR<FlowiseSettingCreateWithoutFallbackInput, FlowiseSettingUncheckedCreateWithoutFallbackInput>
  }

  export type FlowiseSettingUpdateWithWhereUniqueWithoutFallbackInput = {
    where: FlowiseSettingWhereUniqueInput
    data: XOR<FlowiseSettingUpdateWithoutFallbackInput, FlowiseSettingUncheckedUpdateWithoutFallbackInput>
  }

  export type FlowiseSettingUpdateManyWithWhereWithoutFallbackInput = {
    where: FlowiseSettingScalarWhereInput
    data: XOR<FlowiseSettingUpdateManyMutationInput, FlowiseSettingUncheckedUpdateManyWithoutFallbackInput>
  }

  export type FlowiseSettingScalarWhereInput = {
    AND?: FlowiseSettingScalarWhereInput | FlowiseSettingScalarWhereInput[]
    OR?: FlowiseSettingScalarWhereInput[]
    NOT?: FlowiseSettingScalarWhereInput | FlowiseSettingScalarWhereInput[]
    id?: StringFilter<"FlowiseSetting"> | string
    expire?: IntNullableFilter<"FlowiseSetting"> | number | null
    keywordFinish?: StringNullableFilter<"FlowiseSetting"> | string | null
    delayMessage?: IntNullableFilter<"FlowiseSetting"> | number | null
    unknownMessage?: StringNullableFilter<"FlowiseSetting"> | string | null
    listeningFromMe?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    stopBotFromMe?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    keepOpen?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    debounceTime?: IntNullableFilter<"FlowiseSetting"> | number | null
    ignoreJids?: JsonNullableFilter<"FlowiseSetting">
    splitMessages?: BoolNullableFilter<"FlowiseSetting"> | boolean | null
    timePerChar?: IntNullableFilter<"FlowiseSetting"> | number | null
    createdAt?: DateTimeNullableFilter<"FlowiseSetting"> | Date | string | null
    updatedAt?: DateTimeFilter<"FlowiseSetting"> | Date | string
    flowiseIdFallback?: StringNullableFilter<"FlowiseSetting"> | string | null
    instanceId?: StringFilter<"FlowiseSetting"> | string
  }

  export type FlowiseCreateWithoutFlowiseSettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    Instance: InstanceCreateNestedOneWithoutFlowiseInput
  }

  export type FlowiseUncheckedCreateWithoutFlowiseSettingInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type FlowiseCreateOrConnectWithoutFlowiseSettingInput = {
    where: FlowiseWhereUniqueInput
    create: XOR<FlowiseCreateWithoutFlowiseSettingInput, FlowiseUncheckedCreateWithoutFlowiseSettingInput>
  }

  export type InstanceCreateWithoutFlowiseSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatCreateNestedManyWithoutInstanceInput
    Contact?: ContactCreateNestedManyWithoutInstanceInput
    Message?: MessageCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootCreateNestedOneWithoutInstanceInput
    Label?: LabelCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyCreateNestedOneWithoutInstanceInput
    Setting?: SettingCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqCreateNestedOneWithoutInstanceInput
    Sqs?: SqsCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotCreateNestedManyWithoutInstanceInput
    Session?: SessionCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingCreateNestedOneWithoutInstanceInput
    Media?: MediaCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingCreateNestedOneWithoutInstanceInput
    Template?: TemplateCreateNestedManyWithoutInstanceInput
    Dify?: DifyCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseCreateNestedManyWithoutInstanceInput
    Pusher?: PusherCreateNestedOneWithoutInstanceInput
  }

  export type InstanceUncheckedCreateWithoutFlowiseSettingInput = {
    id?: string
    name: string
    connectionStatus?: $Enums.InstanceConnectionStatus
    ownerJid?: string | null
    profileName?: string | null
    profilePicUrl?: string | null
    integration?: string | null
    number?: string | null
    businessId?: string | null
    token?: string | null
    clientName?: string | null
    disconnectionReasonCode?: number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: Date | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Chat?: ChatUncheckedCreateNestedManyWithoutInstanceInput
    Contact?: ContactUncheckedCreateNestedManyWithoutInstanceInput
    Message?: MessageUncheckedCreateNestedManyWithoutInstanceInput
    Webhook?: WebhookUncheckedCreateNestedOneWithoutInstanceInput
    Chatwoot?: ChatwootUncheckedCreateNestedOneWithoutInstanceInput
    Label?: LabelUncheckedCreateNestedManyWithoutInstanceInput
    Proxy?: ProxyUncheckedCreateNestedOneWithoutInstanceInput
    Setting?: SettingUncheckedCreateNestedOneWithoutInstanceInput
    Rabbitmq?: RabbitmqUncheckedCreateNestedOneWithoutInstanceInput
    Sqs?: SqsUncheckedCreateNestedOneWithoutInstanceInput
    Websocket?: WebsocketUncheckedCreateNestedOneWithoutInstanceInput
    Typebot?: TypebotUncheckedCreateNestedManyWithoutInstanceInput
    Session?: SessionUncheckedCreateNestedOneWithoutInstanceInput
    MessageUpdate?: MessageUpdateUncheckedCreateNestedManyWithoutInstanceInput
    TypebotSetting?: TypebotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Media?: MediaUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiCreds?: OpenaiCredsUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiBot?: OpenaiBotUncheckedCreateNestedManyWithoutInstanceInput
    OpenaiSetting?: OpenaiSettingUncheckedCreateNestedOneWithoutInstanceInput
    Template?: TemplateUncheckedCreateNestedManyWithoutInstanceInput
    Dify?: DifyUncheckedCreateNestedManyWithoutInstanceInput
    DifySetting?: DifySettingUncheckedCreateNestedOneWithoutInstanceInput
    integrationSessions?: IntegrationSessionUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBot?: EvolutionBotUncheckedCreateNestedManyWithoutInstanceInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedCreateNestedOneWithoutInstanceInput
    Flowise?: FlowiseUncheckedCreateNestedManyWithoutInstanceInput
    Pusher?: PusherUncheckedCreateNestedOneWithoutInstanceInput
  }

  export type InstanceCreateOrConnectWithoutFlowiseSettingInput = {
    where: InstanceWhereUniqueInput
    create: XOR<InstanceCreateWithoutFlowiseSettingInput, InstanceUncheckedCreateWithoutFlowiseSettingInput>
  }

  export type FlowiseUpsertWithoutFlowiseSettingInput = {
    update: XOR<FlowiseUpdateWithoutFlowiseSettingInput, FlowiseUncheckedUpdateWithoutFlowiseSettingInput>
    create: XOR<FlowiseCreateWithoutFlowiseSettingInput, FlowiseUncheckedCreateWithoutFlowiseSettingInput>
    where?: FlowiseWhereInput
  }

  export type FlowiseUpdateToOneWithWhereWithoutFlowiseSettingInput = {
    where?: FlowiseWhereInput
    data: XOR<FlowiseUpdateWithoutFlowiseSettingInput, FlowiseUncheckedUpdateWithoutFlowiseSettingInput>
  }

  export type FlowiseUpdateWithoutFlowiseSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutFlowiseNestedInput
  }

  export type FlowiseUncheckedUpdateWithoutFlowiseSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type InstanceUpsertWithoutFlowiseSettingInput = {
    update: XOR<InstanceUpdateWithoutFlowiseSettingInput, InstanceUncheckedUpdateWithoutFlowiseSettingInput>
    create: XOR<InstanceCreateWithoutFlowiseSettingInput, InstanceUncheckedCreateWithoutFlowiseSettingInput>
    where?: InstanceWhereInput
  }

  export type InstanceUpdateToOneWithWhereWithoutFlowiseSettingInput = {
    where?: InstanceWhereInput
    data: XOR<InstanceUpdateWithoutFlowiseSettingInput, InstanceUncheckedUpdateWithoutFlowiseSettingInput>
  }

  export type InstanceUpdateWithoutFlowiseSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUpdateManyWithoutInstanceNestedInput
    Message?: MessageUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUpdateOneWithoutInstanceNestedInput
    Label?: LabelUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUpdateManyWithoutInstanceNestedInput
    Session?: SessionUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUpdateOneWithoutInstanceNestedInput
    Media?: MediaUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUpdateManyWithoutInstanceNestedInput
    Pusher?: PusherUpdateOneWithoutInstanceNestedInput
  }

  export type InstanceUncheckedUpdateWithoutFlowiseSettingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    connectionStatus?: EnumInstanceConnectionStatusFieldUpdateOperationsInput | $Enums.InstanceConnectionStatus
    ownerJid?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    integration?: NullableStringFieldUpdateOperationsInput | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    disconnectionReasonCode?: NullableIntFieldUpdateOperationsInput | number | null
    disconnectionObject?: NullableJsonNullValueInput | InputJsonValue
    disconnectionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Chat?: ChatUncheckedUpdateManyWithoutInstanceNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutInstanceNestedInput
    Message?: MessageUncheckedUpdateManyWithoutInstanceNestedInput
    Webhook?: WebhookUncheckedUpdateOneWithoutInstanceNestedInput
    Chatwoot?: ChatwootUncheckedUpdateOneWithoutInstanceNestedInput
    Label?: LabelUncheckedUpdateManyWithoutInstanceNestedInput
    Proxy?: ProxyUncheckedUpdateOneWithoutInstanceNestedInput
    Setting?: SettingUncheckedUpdateOneWithoutInstanceNestedInput
    Rabbitmq?: RabbitmqUncheckedUpdateOneWithoutInstanceNestedInput
    Sqs?: SqsUncheckedUpdateOneWithoutInstanceNestedInput
    Websocket?: WebsocketUncheckedUpdateOneWithoutInstanceNestedInput
    Typebot?: TypebotUncheckedUpdateManyWithoutInstanceNestedInput
    Session?: SessionUncheckedUpdateOneWithoutInstanceNestedInput
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutInstanceNestedInput
    TypebotSetting?: TypebotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Media?: MediaUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiCreds?: OpenaiCredsUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiBot?: OpenaiBotUncheckedUpdateManyWithoutInstanceNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Template?: TemplateUncheckedUpdateManyWithoutInstanceNestedInput
    Dify?: DifyUncheckedUpdateManyWithoutInstanceNestedInput
    DifySetting?: DifySettingUncheckedUpdateOneWithoutInstanceNestedInput
    integrationSessions?: IntegrationSessionUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBot?: EvolutionBotUncheckedUpdateManyWithoutInstanceNestedInput
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateOneWithoutInstanceNestedInput
    Flowise?: FlowiseUncheckedUpdateManyWithoutInstanceNestedInput
    Pusher?: PusherUncheckedUpdateOneWithoutInstanceNestedInput
  }

  export type ChatCreateManyInstanceInput = {
    id?: string
    remoteJid: string
    name?: string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    unreadMessages?: number
  }

  export type ContactCreateManyInstanceInput = {
    id?: string
    remoteJid: string
    pushName?: string | null
    profilePicUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type MessageCreateManyInstanceInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
    sessionId?: string | null
  }

  export type LabelCreateManyInstanceInput = {
    id?: string
    labelId?: string | null
    name: string
    color: string
    predefinedId?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type TypebotCreateManyInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    url: string
    typebot: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
  }

  export type MessageUpdateCreateManyInstanceInput = {
    id?: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant?: string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status: string
    messageId: string
  }

  export type MediaCreateManyInstanceInput = {
    id?: string
    fileName: string
    type: string
    mimetype: string
    createdAt?: Date | string | null
    messageId: string
  }

  export type OpenaiCredsCreateManyInstanceInput = {
    id?: string
    name?: string | null
    apiKey?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type OpenaiBotCreateManyInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
  }

  export type TemplateCreateManyInstanceInput = {
    id?: string
    templateId: string
    name: string
    template: JsonNullValueInput | InputJsonValue
    webhookUrl?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type DifyCreateManyInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.DifyBotType
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type IntegrationSessionCreateManyInstanceInput = {
    id?: string
    sessionId: string
    remoteJid: string
    pushName?: string | null
    status: $Enums.SessionStatus
    awaitUser?: boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: string | null
  }

  export type EvolutionBotCreateManyInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type FlowiseCreateManyInstanceInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    apiUrl?: string | null
    apiKey?: string | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
  }

  export type ChatUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadMessages?: IntFieldUpdateOperationsInput | number
  }

  export type ChatUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadMessages?: IntFieldUpdateOperationsInput | number
  }

  export type ChatUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    labels?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unreadMessages?: IntFieldUpdateOperationsInput | number
  }

  export type ContactUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ContactUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    MessageUpdate?: MessageUpdateUpdateManyWithoutMessageNestedInput
    Media?: MediaUpdateOneWithoutMessageNestedInput
    session?: IntegrationSessionUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutMessageNestedInput
    Media?: MediaUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LabelUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    predefinedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    predefinedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabelUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    labelId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    predefinedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypebotUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    typebot?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    TypebotSetting?: TypebotSettingUpdateManyWithoutFallbackNestedInput
  }

  export type TypebotUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    typebot?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    TypebotSetting?: TypebotSettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type TypebotUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    typebot?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageUpdateUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    Message?: MessageUpdateOneRequiredWithoutMessageUpdateNestedInput
  }

  export type MessageUpdateUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Message?: MessageUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    mimetype?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenaiCredsUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OpenaiAssistant?: OpenaiBotUpdateManyWithoutOpenaiCredsNestedInput
    OpenaiSetting?: OpenaiSettingUpdateOneWithoutOpenaiCredsNestedInput
  }

  export type OpenaiCredsUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OpenaiAssistant?: OpenaiBotUncheckedUpdateManyWithoutOpenaiCredsNestedInput
    OpenaiSetting?: OpenaiSettingUncheckedUpdateOneWithoutOpenaiCredsNestedInput
  }

  export type OpenaiCredsUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OpenaiBotUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OpenaiCreds?: OpenaiCredsUpdateOneRequiredWithoutOpenaiAssistantNestedInput
    OpenaiSetting?: OpenaiSettingUpdateManyWithoutFallbackNestedInput
  }

  export type OpenaiBotUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
    OpenaiSetting?: OpenaiSettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type OpenaiBotUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    template?: JsonNullValueInput | InputJsonValue
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DifyUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumDifyBotTypeFieldUpdateOperationsInput | $Enums.DifyBotType
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DifySetting?: DifySettingUpdateManyWithoutFallbackNestedInput
  }

  export type DifyUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumDifyBotTypeFieldUpdateOperationsInput | $Enums.DifyBotType
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DifySetting?: DifySettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type DifyUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumDifyBotTypeFieldUpdateOperationsInput | $Enums.DifyBotType
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationSessionUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    awaitUser?: BoolFieldUpdateOperationsInput | boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: MessageUpdateManyWithoutSessionNestedInput
  }

  export type IntegrationSessionUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    awaitUser?: BoolFieldUpdateOperationsInput | boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: NullableStringFieldUpdateOperationsInput | string | null
    Message?: MessageUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type IntegrationSessionUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    awaitUser?: BoolFieldUpdateOperationsInput | boolean
    context?: NullableJsonNullValueInput | InputJsonValue
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    botId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvolutionBotUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EvolutionBotSetting?: EvolutionBotSettingUpdateManyWithoutFallbackNestedInput
  }

  export type EvolutionBotUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    EvolutionBotSetting?: EvolutionBotSettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type EvolutionBotUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlowiseUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FlowiseSetting?: FlowiseSettingUpdateManyWithoutFallbackNestedInput
  }

  export type FlowiseUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FlowiseSetting?: FlowiseSettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type FlowiseUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apiUrl?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateCreateManyMessageInput = {
    id?: string
    keyId: string
    remoteJid: string
    fromMe: boolean
    participant?: string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status: string
    instanceId: string
  }

  export type MessageUpdateUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    Instance?: InstanceUpdateOneRequiredWithoutMessageUpdateNestedInput
  }

  export type MessageUpdateUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    remoteJid?: StringFieldUpdateOperationsInput | string
    fromMe?: BoolFieldUpdateOperationsInput | boolean
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    pollUpdates?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type TypebotSettingCreateManyFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type TypebotSettingUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutTypebotSettingNestedInput
  }

  export type TypebotSettingUncheckedUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type TypebotSettingUncheckedUpdateManyWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManySessionInput = {
    id?: string
    key: JsonNullValueInput | InputJsonValue
    pushName?: string | null
    participant?: string | null
    messageType: string
    message: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source: $Enums.DeviceMessage
    messageTimestamp: number
    chatwootMessageId?: number | null
    chatwootInboxId?: number | null
    chatwootConversationId?: number | null
    chatwootContactInboxSourceId?: string | null
    chatwootIsRead?: boolean | null
    instanceId: string
    typebotSessionId?: string | null
    webhookUrl?: string | null
    status?: string | null
  }

  export type MessageUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    Instance?: InstanceUpdateOneRequiredWithoutMessageNestedInput
    MessageUpdate?: MessageUpdateUpdateManyWithoutMessageNestedInput
    Media?: MediaUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    instanceId?: StringFieldUpdateOperationsInput | string
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    MessageUpdate?: MessageUpdateUncheckedUpdateManyWithoutMessageNestedInput
    Media?: MediaUncheckedUpdateOneWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: JsonNullValueInput | InputJsonValue
    pushName?: NullableStringFieldUpdateOperationsInput | string | null
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    messageType?: StringFieldUpdateOperationsInput | string
    message?: JsonNullValueInput | InputJsonValue
    contextInfo?: NullableJsonNullValueInput | InputJsonValue
    source?: EnumDeviceMessageFieldUpdateOperationsInput | $Enums.DeviceMessage
    messageTimestamp?: IntFieldUpdateOperationsInput | number
    chatwootMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootInboxId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootConversationId?: NullableIntFieldUpdateOperationsInput | number | null
    chatwootContactInboxSourceId?: NullableStringFieldUpdateOperationsInput | string | null
    chatwootIsRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    instanceId?: StringFieldUpdateOperationsInput | string
    typebotSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OpenaiBotCreateManyOpenaiCredsInput = {
    id?: string
    enabled?: boolean
    description?: string | null
    botType: $Enums.OpenaiBotType
    assistantId?: string | null
    functionUrl?: string | null
    model?: string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: number | null
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    triggerType?: $Enums.TriggerType | null
    triggerOperator?: $Enums.TriggerOperator | null
    triggerValue?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type OpenaiBotUpdateWithoutOpenaiCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutOpenaiBotNestedInput
    OpenaiSetting?: OpenaiSettingUpdateManyWithoutFallbackNestedInput
  }

  export type OpenaiBotUncheckedUpdateWithoutOpenaiCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
    OpenaiSetting?: OpenaiSettingUncheckedUpdateManyWithoutFallbackNestedInput
  }

  export type OpenaiBotUncheckedUpdateManyWithoutOpenaiCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    botType?: EnumOpenaiBotTypeFieldUpdateOperationsInput | $Enums.OpenaiBotType
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    functionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    systemMessages?: NullableJsonNullValueInput | InputJsonValue
    assistantMessages?: NullableJsonNullValueInput | InputJsonValue
    userMessages?: NullableJsonNullValueInput | InputJsonValue
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    triggerType?: NullableEnumTriggerTypeFieldUpdateOperationsInput | $Enums.TriggerType | null
    triggerOperator?: NullableEnumTriggerOperatorFieldUpdateOperationsInput | $Enums.TriggerOperator | null
    triggerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenaiSettingCreateManyFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    speechToText?: boolean | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    openaiCredsId: string
    instanceId: string
  }

  export type OpenaiSettingUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    OpenaiCreds?: OpenaiCredsUpdateOneWithoutOpenaiSettingNestedInput
    Instance?: InstanceUpdateOneRequiredWithoutOpenaiSettingNestedInput
  }

  export type OpenaiSettingUncheckedUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type OpenaiSettingUncheckedUpdateManyWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    speechToText?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openaiCredsId?: StringFieldUpdateOperationsInput | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type DifySettingCreateManyFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type DifySettingUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutDifySettingNestedInput
  }

  export type DifySettingUncheckedUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type DifySettingUncheckedUpdateManyWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type EvolutionBotSettingCreateManyFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type EvolutionBotSettingUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutEvolutionBotSettingNestedInput
  }

  export type EvolutionBotSettingUncheckedUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type EvolutionBotSettingUncheckedUpdateManyWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type FlowiseSettingCreateManyFallbackInput = {
    id?: string
    expire?: number | null
    keywordFinish?: string | null
    delayMessage?: number | null
    unknownMessage?: string | null
    listeningFromMe?: boolean | null
    stopBotFromMe?: boolean | null
    keepOpen?: boolean | null
    debounceTime?: number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: boolean | null
    timePerChar?: number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string
    instanceId: string
  }

  export type FlowiseSettingUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Instance?: InstanceUpdateOneRequiredWithoutFlowiseSettingNestedInput
  }

  export type FlowiseSettingUncheckedUpdateWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }

  export type FlowiseSettingUncheckedUpdateManyWithoutFallbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    expire?: NullableIntFieldUpdateOperationsInput | number | null
    keywordFinish?: NullableStringFieldUpdateOperationsInput | string | null
    delayMessage?: NullableIntFieldUpdateOperationsInput | number | null
    unknownMessage?: NullableStringFieldUpdateOperationsInput | string | null
    listeningFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stopBotFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    keepOpen?: NullableBoolFieldUpdateOperationsInput | boolean | null
    debounceTime?: NullableIntFieldUpdateOperationsInput | number | null
    ignoreJids?: NullableJsonNullValueInput | InputJsonValue
    splitMessages?: NullableBoolFieldUpdateOperationsInput | boolean | null
    timePerChar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instanceId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}